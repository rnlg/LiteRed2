(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



If[NextCell[]===None,(*If starting with clean notebook, paste template*)
Print["Empty file, template will be generated"];
LiteRed`Private`template=True,(*set flag to paste template in the end*)
LiteRed`Private`template=False 
]


Vectors`VectorsLog=False;
Needs["Vectors`","RNL`Vectors`"];
Needs["LinearFunctions`","RNL`LinearFunctions`"];


Needs["Numbers`","RNL`Numbers`"];
Needs["Types`","RNL`Types`"];
BeginPackage["LiteRed`",{"Vectors`","LinearFunctions`","Numbers`","Types`"}]


$LiteRedVersion="2.019b";
$LiteRedReleaseDate="10.02.2019";
$LiteRedVersion::usage="$LiteRedVersion is the current version of the LiteRed package.";
$LiteRedReleaseDate::usage="$LiteRedReleaseDate is the release date of the current version.";


SetAttributes[LiteRed`Private`WarnSet,HoldAll];
LiteRed`Private`WarnSet::warn="Use `2` instead of `1`.";
LiteRed`Private`WarnSet[LiteRed`Private`a_,LiteRed`Private`b_]:=(LiteRed`Private`a:=(Message[LiteRed`Private`WarnSet::warn,Unevaluated[LiteRed`Private`a],Unevaluated[LiteRed`Private`b]];LiteRed`Private`b))


$ActiveBases={};


LiteRed`Private`WarnSet[CompleteMomentaFlow,(Print["CompleteMomentaFlow is outdated, use GraphToDs instead."];#)&];(*outdated*)
GraphToDs;(*Does exactly what it says*)


PowerShifts;(*additions to power of denominators*)


NewDsSet;
DsSetQ;

Relations;


GeneratePFGB;
PFGB;
PFReduce;


LiteRed`Private`WarnSet[NewBasis,NewDsBasis];
DsBasisQ;

SectorsPattern;
Ds;NDs;
LMs;
EMs;
SPs;
MIs;
BasisDirectory;
Definitions;
ExecuteDefinitions;
CheckDefinitions;


CurrentState;


j;(*j will allow for extra index, like j[nm,1,0,....,d+2]. If the last index is not indicated it defaults to current dimensionality*)
Toj;
Fromj;


js;
jSector;
jSubsectors;


jsSignature;
jsSignaturePermutations;
jSignature;


ToAB;FromAB;FromTildeAB;AtoLeft;A;B;
InverseTildeConjugate;
TildeConjugate;
ABIBP;ABLI;ABIBPLI;


MakeOrderMatrix;
jsOrder;
jComplexity;
jVars;
Highj;
Highjs;
HighjIndex;


Collectj;(*outdated, simply Collect[..,_J] should work fine*)
CollectjList;
SimplifyFunction;SimplifyAlways;
jPattern;


Factor1;Factor2;Factor3;



Solvej;
(*Bloodhound;BloodhoundSearch;*)(*too  raw to include*)
SolvejSector;
	SubstituteAlways;
	CheckZeroAlways;
	CheckZeroFunction;
	NMIs;
	RRs;
	MaxDepth;
	UseFermat;
BloodhoundSearch;


GenerateIBP;
	IBP;
	LI;
	IBPLI;


AddjRule;
RefreshMIs;


AnalyzeSectors;
    ZeroSectors;
    NonZeroSectors;
    SimpleSectors;
    BasisSectors;
    ZerojRule;
   CutDs;
(*AnalyzeSectorsFP;*)


SectorHierarchy;


FindShifts;
FindSymmetries;
    UniqueSectors;
    MappedSectors;
    SectorsMappings;
(*    jSymMatrices;*)
    jSymmetries;
    jRules;
    SR; (*jsOrderingFunction;*)


ZeroSectorQ;
NonZeroSectorQ;
MappedSectorQ;
UniqueSectorQ;


IdentifyMIs;


MIsHierarchyGraph;


FindExtSymmetries;
    ExtUniqueSectors;
    ExtMappedSectors;
    jExtRules;
    ExtSectorsMappings;


AttachGraph;
jGraph;


GenerateFeynParUF;
FeynParUF;FeynParGdG;


GramP;GramPFunction;


FactorizeFP;FactorizejSector;


PolyNForm;
PolySignature;
PolySignaturePermutations;
(*FromPolySignature;
FromPolySignaturePermutation;*)


NamingFunction;


DiskSave;
DiskRecover;


IBPReduce;
(*    DWeight;*)


ToMIsRule;


(*GenerateDRR;*)(*not yet implemented*)
LoweringDRR;RaisingDRR;(*Now LoweringDRR[nm] will give a rule*)
LowerDim;RaiseDim;


Dinv;


$LiteRedLog::usage="$LiteRedLog=True turns on some log information of the package.";
$LiteRedMonitor::usage="$LiteRedMonitor=True turns on some temporary log information of the package.";
If[!ValueQ[$LiteRedLog],$LiteRedLog=True];
If[!ValueQ[$LiteRedMonitor],$LiteRedMonitor=True];


$NamingFunction::usage="$NamingFunction is a global naming function for the symbolic indices of the integral. The argument is the length of the index list.\
By default it is set so that, e.g., $NamingFunction[5] returns {n1,n2,n3,n4,n5}.\n\
To change to default definition, use $NamingFunction=(\[Ellipsis])&.";


$NamingFunction=Array[ToExpression["n"<>ToString[#]]&,{#}]&;


LiteRed`Private`LiteRedPrint=If[$LiteRedLog,Print[##]]&;
LiteRed`Private`LiteRedPrintTemporary=If[$LiteRedLog,PrintTemporary[##]]&;
LiteRed`Private`LiteRedMonitor:=If[$LiteRedMonitor,Monitor,#&];


$LiteRedSyzygy;
GenerateFPIBP;jsFPIBP;FPIBP;


{ToDShifts,FromDShifts,NumeratorsToDShifts,FindSymmetriesDen,UniqueSectorsDen,MappedSectorsDen,SolvejSectorDen,SolvejSectorD,jRulesDen,jSymmetriesDen,IBPReduceDen,NumDepth};


$LiteRedHomeDirectory=DirectoryName[$InputFileName];


LiteRed`Private`LiteRedPrint["**************** ",Style["LiteRed v"<>ToString[$LiteRedVersion],{Bold,Lighter@Red}]," ********************\n\
Author: Roman N. Lee, Budker Institute of Nuclear Physics, Novosibirsk.\n\
Release Date: "<>$LiteRedReleaseDate<>"\n\
Timestamp: "<>DateString[FileDate[$InputFileName]]<>"\nMD5: "<>ToString[FileHash[$InputFileName,"MD5"]]<>
"\n\nLiteRed stands for ",Style["L",{Lighter@Red}],"oop ",Style["i",{Lighter@Red}],"n",Style["te",{Lighter@Red}],"grals ",Style["Red",{Lighter@Red}],"uction.\n\
The package is designed for the search and application of the Integration-By-Part reduction rules. \
It also contains some other useful tools.\n\nSee ?LiteRed`* for a list of functions. "];


 SectorLayer


Begin["`Private`"]


todolist={};
todo[s_String]:=AppendTo[todolist,s];


debug::msg="Debug: `1`";


disjointFlags::usage="disjointFlags[sets_List] gives a boolean matrix with each row corresponding to a disjoint component. I.e., Union@@Pick[sets,#]&/@disjointFlags[sets] splits sets into minimal non-intersecting unions."


disjointFlags[sets_List]:=Module[{c,m={##,Not@Or[##]}&@@@Outer[MemberQ,sets,Union@@sets,1] (*add one column for trivial rows*)},
c=DeleteDuplicates@Reap[Do[c=Flatten[Position[m[[i]],True,{1}]];(*c is nonempty for sure*)Assert[c=!={}];
m[[All,Sow@First@c]]=Or@@@m[[All,c]],{i,Length@m}]][[-1,-1]];Transpose[m][[c]]]


(* added 21.12.2012 *)
PutUpValues[b_,fn_]:=Put@@Append[Unevaluated@@@Apply[TagSetDelayed,Hold/@(Prepend[ReplacePart[Hold@@#,{1,0}->Sequence],b]&/@UpValues[b]),{2}],fn];
PutAppendUpValues[b_,fn_]:=PutAppend@@Append[Unevaluated@@@Apply[TagSetDelayed,Hold/@(Prepend[ReplacePart[Hold@@#,{1,0}->Sequence],b]&/@UpValues[b]),{2}],fn];
(*/added 21.12.2012 *)


If[Not[NameQ["Compositions"]],
SetSharedFunction[Symbol["Compositions"]];
Symbol["Compositions"][0,0]={{}};
Symbol["Compositions"][n_Integer?Positive,0]={};Symbol["Compositions"][n_Integer,k_Integer?Positive] :=
	Map[
		(Map[(#[[2]]-#[[1]]-1)&, Partition[Join[{0},#,{n+k}],2,1] ])&,
		Subsets[Range[n+k-1],{k-1}]
	]
]


If[Not[NameQ["SplitCases"]],
SetSharedFunction[Symbol["SplitCases"]];
Evaluate[Symbol["SplitCases"]]::usage="SplitCases[\!\(\*
StyleBox[\"list\", \"TI\"]\),{\!\(\*
StyleBox[\"pat1\", \"TI\"]\),\!\(\*
StyleBox[\"pat2\", \"TI\"]\),\[Ellipsis]}] splits \!\(\*
StyleBox[\"list\", \"TI\"]\) into parts, matching patterns \!\(\*
StyleBox[\"pat1\", \"TI\"]\),\!\(\*
StyleBox[\"pat2\", \"TI\"]\),\[Ellipsis],_.";
Symbol["SplitCases"][l_,ps_List] :=
	Module[{pn},
{Sequence@@Last/@SortBy[#2,First@#&],#1}&@@Reap[Replace[l,MapThread[(Sow[pn,Symbol["SplitCases"]@#2];pn:#:>(Sow[pn,Symbol["SplitCases"]@#2];
Unevaluated[Sequence[]]))&,
{ps,Range[Length[ps]]}],{1}],Blank[Symbol["SplitCases"]],{First@#1,Head@l@@(#2/.pn->Sequence[])}&]]
]


Unflatten[list_List,tmpl_List]:=Module[{fn,f,i=1},
SetAttributes[fn,HoldAll];
fn[x_List]:=fn/@x;
fn[x_]:=list[[i++]];
fn[tmpl]
]


If[Not[NameQ["MaximalBy"]],
maximal=Fold[If[OrderedQ[{##}],#2,#1]&,#]&,
maximal=First@Symbol["MaximalBy"][#,Identity,1]&
]


If[Not[NameQ["MinimalBy"]],
minimal=Fold[If[OrderedQ[{##}],#1,#2]&,#]&,
minimal=First@Symbol["MinimalBy"][#,Identity,1]&
]


CurrentState::usage="CurrentState[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the information about current state of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).\nCurrentState[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"command\", \"TI\"]\)] gives True or False depending on whether \!\(\*
StyleBox[\"command\", \"TI\"]\)[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] was evaluated.";


Function[stages,
CurrentState[_Symbol]=Association@@Thread[stages->False];
(
CurrentState[nm_Symbol,x:#]:=CurrentState[nm][x];
CurrentState/:Set[CurrentState[nm_Symbol,x:#],y_]:=Module[{cs=CurrentState[nm]},cs[x]=y;CurrentState[nm]^=cs;y];
CurrentState/:Set[CurrentState[nm_Symbol,x_List],y_]:=((CurrentState[nm,#1]=#2)&@@@Thread[{x,y}])
)&[Alternatives@@stages]

][{NewDsBasis,GenerateIBP,AnalyzeSectors,FindSymmetries}];


NewDsSet::usage="NewDsSet[\!\(\*
StyleBox[\"set\", \"TI\"]\),\*
StyleBox[\(\!\(\*
StyleBox[\"denominators\", \"TI\"]\)_List\)],\!\(\*
StyleBox[\"loopmomenta\", \"TI\"]\)_List] determines a set of propagators.\nThe difference with the basis is that linear relations between denominators are allowed in the set.\nFirst argument is a name of the set.\nSecond argument is a set of denominators. Shortcuts are allowed here: for the massless propagator sp[l,l] just put l in the list. sp[a,b] stands for the scalar product of two vectors, sp[a] is a shortcut for sp[a,a].\nThird argument is the list of loop momenta.\nOptions:\n    Append\[Rule]False|True \[LongDash] determines whether to append irreducible numerators if needed.\n    Directory\[Rule]False|\!\(\*
StyleBox[\"dirname\", \"TI\"]\) \[LongDash] determines the directory in which the basis is saved.";


DsSetQ::usage="DsSetQ[\!\(\*
StyleBox[\"var\", \"TI\"]\)] gives True if \!\(\*
StyleBox[\"var\", \"TI\"]\) is a DsSet, i.e., if NewDsSet[\!\(\*
StyleBox[\"var\", \"TI\"]\),\[Ellipsis]] was executed.";
DsSetQ[_]=False;


Relations::usage="Relations[\!\(\*
StyleBox[\"set\", \"TI\"]\)] gives a set of relations between the denominators of the \!\(\*
StyleBox[\"set\", \"TI\"]\).";


PowerShifts[nm_?DsSetQ]:=PowerShifts[nm]=ConstantArray[0,Length@Ds[nm]]


Options[NewDsSet]={Directory->False,Append->False,PowerShifts->None,SectorsPattern->{___}};


NewDsSet::nums="The set of denominators is not a basis.\nAdd irreducible numerator(s) `1`, or try your own set of `2` numerator(s).\nAborting...";
NewDsSet::ovrw="Warning: definitions for `1` has been found. They may interfere with the upcoming definitions.";
NewDsSet[nm_Symbol, ds : {(_?VecQ | _?NumQ) ..}, lms : {__?VecVarQ}, 
  OptionsPattern[]] := Module[{
d=MetricTensor[],
 dens, ddens,m,
dim, ems, sps, toj,ns,l},
If[Length@UpValues[nm]>0,Message[NewDsBasis::ovrw,nm]];
SectorsPattern[nm]^=OptionValue[SectorsPattern];
(*Normalize denominators*)
dens = Replace[ds,x_?VecQ :> sp[x, x], {1}];
ems = Complement[Union@Cases[dens, _?VecVarQ, Infinity], lms];
sps = Union @@ Outer[sp, lms, Join[lms, ems]];
ddens=Expand@LFDistribute[dens,sp];
(*add numerators*)
m=RowReduce@Outer[Coefficient,ddens, sps];
ns=Length@sps-MatrixRank[m];
If[ns>0,
Quiet[ns=Complement[sps,Solve[m.sps==0,sps][[1,All,1]]]];
If[TrueQ[!OptionValue[Append]],Message[NewDsSet::nums,ns,Length@ns]; Abort[]];
dens=Join[dens,ns];ddens=Join[ddens,LFDistribute[ns]];
LiteRedPrint["Irreducible numerator(s) appended: ",Sequence@@Riffle[ns,","],".\nUsing {___,"<>StringTake[ToString[0&/@ns],{2,-1}]<>" as a pattern for AnalyzeSectors."];
SectorsPattern[nm]^={___,Sequence@@(0&/@ns)};
];(*/add numerators*)
dim=Length@dens;
(*linear relations*)m=NullSpace[Transpose[Outer[Coefficient,ddens, sps]]];
ns=$NamingFunction[dim];
If[m=!={},m=Numerator@Factor@LFDistribute[m.(ns-ddens)]];
nm/:Relations[nm]=Function[#1,#2]&[ns,m];
LiteRedPrint[StringJoin@@Riffle[Flatten[{"Found relations",ToString/@Thread[m==0]}],"\n    "]];
(*/linear relations*)
Toj[nm]^=Thread[sps-> Most[PseudoInverse[Append[Transpose[Append[Transpose[Outer[Coefficient,ddens, sps]],ddens/.Thread[sps->0]]],PadLeft[{1},Length@sps+1]]]].(j[nm,##]&@@@Append[-IdentityMatrix[dim],ConstantArray[0,dim]])];
nm /: Ds[nm] = dens;
nm /: NDs[nm] = dim;
nm /: SPs[nm] = sps;
nm /: LMs[nm] = lms;
nm /: EMs[nm] = ems;
(*Definitions 21.11.13*)
l=DeleteCases[{Sort[{##}],Replace[sp[##],sp->List,{1},Heads->True]}&@@@Replace[Subsets[ems,{1,2}],{x_}:> {x,x},{1}],{l_,l_}];
Definitions[nm]^=Flatten[{If[AtomQ[MetricTensor[]],Hold[MetricTensor[]===#,SetDim[#]]&[MetricTensor[]],Unevaluated[Sequence[]]],
Hold[VecQ[#],Declare[#,Vector]]&/@Join[lms,ems],
Hold[TypeOf[#]===#2,Declare[#,#2]]&@@@({#,TypeOf[#]}&/@Select[Variables[l],AtomQ]),
Replace[l,{{x_,y_},z_}:>Hold[sp[x,y]===z,sp[x,y]=z],{1}]}];
(*/Definitions 21.11.13*)
BasisDirectory[nm]=OptionValue[Directory];
PowerShifts[nm]^=OptionValue[PowerShifts]/.{None->ConstantArray[0,dim]};
(*TODO: add consistency check:nonzero integer shifts and shifts differing by nonzero integer are forbidden.Denominators with the same shift can be mapped onto each other. Denominator can not be simultaneously cut and shifted!!! Or can they?*)

nm::usage=ToString[Length@lms]<>"-loop set with "<>ToString[dim]<>" denominators and "<>ToString[Length@ems]<>" external momenta.\nUse Information["<>ToString[nm]<>"] to get set summary.\nThis string can be redefined by setting "<>ToString[nm]<>"::usage=\"\[Ellipsis]\"";
nm/:Information[nm]:=(If[ValueQ[nm::usage],Information[nm,LongForm->False]];
Print@Grid[Partition[Union[Replace[Replace[First/@UpValues[nm]/.HoldPattern->HoldForm,{HoldPattern[HoldForm[f_[nm,__]]]:>HoldForm[f[nm,"\[Ellipsis]"]]},{1}],{HoldPattern[x:HoldForm[f_[nm,___]]]:>Button[x,(SelectionMove[ButtonNotebook[],All,GeneratedCell];NotebookDelete[];Information[Evaluate@x[[1,0]],LongForm->False];Print[TableForm[Cases[UpValues[nm],HoldPattern[a_:>b_]/;MatchQ[a[[1,0]],x[[1,0]]]]/.HoldPattern->HoldForm]])&,Appearance->"Frameless",BaseStyle->"InformationLink"]},{1}]],5],DefaultBaseStyle->"InfoGrid"]);

(*default syntax*)
nm[j,inds__]:=j[nm,inds];
nm[js,inds__]:=js[nm,inds];
SyntaxInformation[nm]={"ArgumentsPattern"->(ConstantArray[_,dim+1])};
(*/default syntax*)
(*PowerShifts[nm]^=ConstantArray[0,dim];*)
DsSetQ[nm]^=True;
LiteRedPrint["Valid set.\n    Ds[" <> # <>"] \[LongDash] denominators,\n    SPs[" <> # <>"] \[LongDash] scalar products involving loop momenta,\n    LMs[" <> # <>"] \[LongDash] loop momenta,\n    EMs[" <> # <>"] \[LongDash] external momenta,\n    Relations[" <> # <>"] \[LongDash] relations between denominators."(*<>",\n    PowerShifts[" <> # <>"] \[LongDash] vector of constant shifts in powers."*)<>(If[Not@TrueQ@Not@BasisDirectory[nm],"\nThe definitions of the set will be saved in "<>BasisDirectory[nm],""])] &@ToString[nm];
If[Not@TrueQ@Not@BasisDirectory[nm],DiskSave[nm,Save->"Basis"]];
nm(*return basis*)
];


GeneratePFGB::usage="GeneratePFGB[\!\(\*
StyleBox[\"set\", \"TI\"]\)] generates groebner basis for partial fractioning. See "<>ToString[ Hyperlink["A. Pak, J. Phys. Conf. Ser. 368 (2012) 012049","http://iopscience.iop.org/article/10.1088/1742-6596/368/1/012049/meta"],StandardForm]<>".";


GeneratePFGB[nm_]:=Module[{
ds,ns,dsns,gb,nds=NDs[nm],wm},
wm=Join[{ConstantArray[1,2*nds],Join[ConstantArray[1,nds],ConstantArray[0,nds]]},Delete[IdentityMatrix[2*nds],{{nds},{2*nds}}]];
(*A strange way to avoid problems with valued variables. Could be much simpler if assuming d1,d2,...,n1,n2,... are not set*)
dsns=ToExpression["Hold[Unevaluated@{"<>StringJoin@@Riffle[("d"<>#&/@Array[ToString,nds]),","]<>"},Unevaluated@{"<>StringJoin@@Riffle[("n"<>#&/@Array[ToString,nds]),","]<>"}]"];
Function[{ds,ns},Block[ds,Block[ns,
PFGB[nm]^=HoldForm@@{{ds,ns,GroebnerBasis[Join[ds ns-1,Relations[nm]@@ns],Join[ds,ns],MonomialOrder->wm]}};
]]]@@dsns;
LiteRedPrint["Groebner basis for partial fractioning is generated.\n    PFGB["<>ToString[nm]<>"] \[LongDash] a list  (wrapped in HoldForm) {denominators,numerators,basis}."]
]


PFGB::usage="PFGB[\!\(\*
StyleBox[\"set\", \"TI\"]\)] returns groebner basis for partial fractioning. See  "<>ToString[ Hyperlink["A. Pak, J. Phys. Conf. Ser. 368 (2012) 012049","http://iopscience.iop.org/article/10.1088/1742-6596/368/1/012049/meta"],StandardForm]<>".";
PFGB[nm_]:=(GeneratePFGB[nm];PFGB[nm]);


PFReduce::usage="PFReduce[\!\(\*
StyleBox[\"expression\", \"TI\"]\)] makes partial fractioning in \!\(\*
StyleBox[\"expression\", \"TI\"]\) containing j[\!\(\*
StyleBox[\"set\", \"TI\"]\),\[Ellipsis]].";


PFReduce[expr_]:=Module[{ex=expr,bs=Union[Cases[expr,j[b_,__]:>b,{0,\[Infinity]}]],wm,nds},
Scan[Function[b,
nds=NDs[b];
wm=Join[{ConstantArray[1,2*nds],Join[ConstantArray[1,nds],ConstantArray[0,nds]]},Delete[IdentityMatrix[2*nds],{{nds},{2*nds}}]];
Function[{ds,ns,gb},Block[ds,Block[ns,
ex=Plus@@(((j[b,##]&@@Subtract@@Partition[#1,Length@ds]) *#2)&@@@CoefficientRules[Last@PolynomialReduce[ex/.j[b,k__]:>Times@@MapThread[If[Positive[#1],#2^#1,#3^(-#1)]&,{{k},ds,ns}],gb,Join[ds,ns],MonomialOrder->wm],Join[ds,ns]]);
]]]@@Delete[PFGB[b],{1,0}]],bs];
ex]


NewDsBasis::usage="NewDsBasis[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\*
StyleBox[\(\!\(\*
StyleBox[\"denominators\", \"TI\"]\)_List\)],\!\(\*
StyleBox[\"loopmomenta\", \"TI\"]\)_List] determines a basis.\nFirst argument is a name of the basis.\nSecond argument is a complete set of independent denominators. Shortcuts are allowed here: for the massless propagator sp[l,l] just put l in the list. sp[a,b] stands for the scalar product of two vectors, sp[a] is a shortcut for sp[a,a].\nThird argument is the list of loop momenta.\nOptions:\n    GenerateIBP\[Rule]True|False \[LongDash] determines whether to generate IBPs afterward,\n    AnalyzeSectors\[Rule]True|False|pattern:False \[LongDash] determines whether to find zero sectors.\n    FindSymmetries\[Rule]True|False \[LongDash] determines whether to find symmetries.\n    Append\[Rule]False|True \[LongDash] determines whether to append irreducible numerators if needed.\n    CutDs\[Rule]None|{1,0,\[Ellipsis]}:None \[LongDash] declares which denominators are cut (each 1 in the list corresponds to a cut denominator).\n    PowerShifts\[Rule]{\[Nu]1,\[Ellipsis]}|None:None \[LongDash] determines shifts in powers of denominators (experimental).\n    Directory\[Rule]False|\!\(\*
StyleBox[\"dirname\", \"TI\"]\) \[LongDash] determines the directory in which the basis is saved.";
Ds::usage="Ds[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list of denominators in \!\(\*
StyleBox[\"basis\", \"TI\"]\).\nDs[j[\[Ellipsis]]] and Ds[js[\[Ellipsis]]] give a list of denominators in j[\[Ellipsis]] and js[\[Ellipsis]].";
NDs::usage="NDs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a number of denominators  in \!\(\*
StyleBox[\"basis\", \"TI\"]\).\nNDs[j[\[Ellipsis]]] and NDs[js[\[Ellipsis]]] give a number of denominators in j[\[Ellipsis]] and js[\[Ellipsis]].";
SectorsPattern::usage="SectorsPattern[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a pattern for all relevant sectors of the basis.This pattern matches exactly those sectors which enter ZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] or NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)].";
CutDs::usage="CutDs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list {1,0,\[Ellipsis]}, where each 1 corresponds to a cut denominator.";
SPs::usage="SPs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list of scalar products involving loop momenta in basis.";
LMs::usage="LMs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list of loop momenta in \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
EMs::usage="EMs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list of external momenta in \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
MIs::usage="MIs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list of master integrals of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) so far revealed.";
BasisDirectory::usage="BasisDirectory[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the directory in which the definitions of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) will be save with DiskSave[\!\(\*
StyleBox[\"basis\", \"TI\"]\)].";


Options[NewDsBasis]={GenerateIBP->False,SectorsPattern->Automatic,CutDs->Automatic,AnalyzeSectors->False,FindSymmetries->False,FindExtSymmetries->False,Directory->False,Append->False,PowerShifts->None,SolvejSector->False};


PowerShifts[nm_?DsBasisQ]:=PowerShifts[nm]=ConstantArray[0,Length@Ds[nm]]


PowerShifts[nm_]:=ConstantArray[0,Length@Ds[nm]];


DsBasisQ::usage="DsBasisQ[\!\(\*
StyleBox[\"var\", \"TI\"]\)] gives True if \!\(\*
StyleBox[\"var\", \"TI\"]\) is a DsBasis, i.e., if NewDsBasis[\!\(\*
StyleBox[\"var\", \"TI\"]\),\[Ellipsis]] was executed.";
DsBasisQ[_]=False;


NewDsBasis::notb="Overdetermined set of denominators. Not a basis. Aborting...";
NewDsBasis::ps="PowerShifts: All nonzero power shifts should preceed zero ones. All numerators should have zero power shifts. Aborting...";
NewDsBasis::nums="The set of denominators is not a basis.\nAdd irreducible numerator(s) `1`, or try your own set of `2` numerator(s).\nAborting...";
NewDsBasis::ovrw="Warning: definitions for `1` has been found. They may interfere with the upcoming definitions. Clearing definitions\[Ellipsis]";
NewDsBasis[nm_Symbol, ds : {(_?VecQ | _?NumQ) ..}, lms : {__?VecVarQ}, 
  OptionsPattern[]] := Module[{
d=MetricTensor[],
 dens, ddens,
dim, ems, sps, toj,ns,nums,l,
gi,as,fs,fes,ss,save,ps},
{gi,as,fs,fes,ss,save,ps}={OptionValue[GenerateIBP],OptionValue[AnalyzeSectors],OptionValue[FindSymmetries],OptionValue[FindExtSymmetries],OptionValue[SolvejSector],OptionValue[Directory],OptionValue[PowerShifts]};
If[Length@UpValues[nm]>0,Message[NewDsBasis::ovrw,nm];Clear[nm]];
CurrentState[nm,{SolvejSector,FindSymmetries,AnalyzeSectors,GenerateIBP,NewDsBasis}]=False;
SectorsPattern[nm]^=Replace[as,True|False->OptionValue[SectorsPattern]];
as=Not[TrueQ[Not[as]]];
(*Normalize denominators*)
dens = Replace[ds,x_?VecQ :> sp[x, x], {1}];
ems = Complement[Union@Cases[dens, _?VecVarQ, Infinity], lms];
 sps = Union @@ Outer[sp, lms, Join[lms, ems]];
ddens=Expand@LFDistribute[dens,sp];
dim=Length@dens;ns=Length@sps-dim;
(*add numerators*)
If[ns<0,Message[NewDsBasis::notb]; Abort[]];
If[MatrixRank[Coefficient[ddens, #] & /@ sps]<dim,Message[NewDsBasis::notb]; Abort[]];
If[ns>0,
Quiet[nums=Complement[sps,Solve[ddens==0,sps][[1,All,1]]]];
If[TrueQ[!OptionValue[Append]],Message[NewDsBasis::nums,nums,Length@nums]; Abort[]];
dens=Join[dens,nums];ddens=Join[ddens,nums];
dim=Length@sps;
LiteRedPrint["Irreducible numerator(s) appended: ",Sequence@@Riffle[nums,","],".\nUsing {___, "<>StringTake[ToString[ConstantArray[0,ns]],{2,-2}]<>"} as a pattern for AnalyzeSectors."];
];(*/add numerators*)
ps=PadRight[ps/.{None->ConstantArray[0,dim]},dim];
If[Not[MatchQ[ps,{Except[0]...,0...}]&&MatchQ[Take[ps,-ns],{0...}]],Message[NewDsBasis::ps];Abort[]];
SectorsPattern[nm]^=Replace[SectorsPattern[nm],Automatic->{___,Sequence@@ConstantArray[0,ns]}];
(*If[dim != Length[sps] || Det[Coefficient[ddens, #] & /@ sps] == 0,Message[NewDsBasis::notb];Abort[]];*)
{toj}=Solve[MapIndexed[#1 == (j[nm, ##] & @@ (-IntegerDigits[2^(dim - First@#2), 2, dim])) &,ddens], sps];
nm /: Ds[nm] = dens;
nm /: NDs[nm] = dim;
nm /: SPs[nm] = sps;
nm /: LMs[nm] = lms;
nm /: EMs[nm] = ems;
nm/:Toj[nm]=toj;
jSector[nm]=js@@Prepend[ConstantArray[1,dim],nm];
MIs[nm]^={};
(*Doubtful*)
(*Probably, should be defined somewhere else*)
SR[nm]^=Function[Module[{jsc=jSector@j[nm,##]},
If[MemberQ[UniqueSectors@nm,jsc],
DeleteCases[DeleteDuplicates[Collectj[j[nm,##]-(j[nm,##]/.jSymmetries@@jsc)]],0],
{}
]
]];
(*/Doubtful*)
(*Definitions 21.11.13*)
l=DeleteCases[{Sort[{##}],Replace[sp[##],sp->List,{1},Heads->True]}&@@@Replace[Subsets[ems,{1,2}],{x_}:> {x,x},{1}],{l_,l_}];
Definitions[nm]^=Flatten[{If[AtomQ[MetricTensor[]],Hold[MetricTensor[]===#,SetDim[#]]&[MetricTensor[]],Unevaluated[Sequence[]]],
Hold[VecQ[#],Declare[#,Vector]]&/@Join[lms,ems],
Hold[TypeOf[#]===#2,Declare[#,#2]]&@@@({#,TypeOf[#]}&/@Select[Variables[l],AtomQ]),
Replace[l,{{x_,y_},z_}:>Hold[sp[x,y]===z,sp[x,y]=z],{1}]}];
(*/Definitions 21.11.13*)
PowerShifts[nm]^=ps;
(*TODO: add consistency check:nonzero integer shifts and shifts differing by nonzero integer are forbidden.Denominators with the same shift can be mapped onto each other. Denominator can not be simultaneously cut and shifted!!! Or can they?*)
CutDs[nm]^=Replace[OptionValue[CutDs],{None->ConstantArray[0,dim],Automatic:>cutds[SectorsPattern[nm],dim]}];
SectorsPattern[nm]^=SectorsPattern[nm]/. (1)->(_);
nm::usage=ToString[Length@lms]<>"-loop basis with "<>ToString[Length@ems]<>" external momenta.\nUse Information["<>ToString[nm]<>"] to get basis summary.\nThis string can be redefined by setting "<>ToString[nm]<>"::usage=\"\[Ellipsis]\"";
nm/:Information[nm]:=(If[ValueQ[nm::usage],Information[nm,LongForm->False]];
Print@Grid[Partition[Union[Replace[Replace[First/@UpValues[nm]/.HoldPattern->HoldForm,{HoldPattern[HoldForm[f_[nm,__]]]:>HoldForm[f[nm,"\[Ellipsis]"]]},{1}],{HoldPattern[x:HoldForm[f_[nm,___]]]:>Button[x,(SelectionMove[ButtonNotebook[],All,GeneratedCell];NotebookDelete[];Information[Evaluate@x[[1,0]],LongForm->False];Print[TableForm[Cases[UpValues[nm],HoldPattern[a_:>b_]/;MatchQ[a[[1,0]],x[[1,0]]]]/.HoldPattern->HoldForm]])&,Appearance->"Frameless",BaseStyle->"InformationLink"]},{1}]],5],DefaultBaseStyle->"InfoGrid"]);

(*default syntax*)
nm[j,inds__]:=j[nm,inds];
nm[js,inds__]:=js[nm,inds];
SyntaxInformation[nm]={"ArgumentsPattern"->(ConstantArray[_,Length@dens+1])};
(*/default syntax*)
DsBasisQ[nm]^=True;
MappedSectors[nm]^={};
SectorsMappings[nm]^={};
ExtMappedSectors[nm]^={};
ExtSectorsMappings[nm]^={};
LiteRedPrint["Valid basis."<>(If[save=!=False," The definitions of the basis will be saved in \""<>save<>"\" directory.",""])<>"\n    Ds[" <> # <>"] \[LongDash] denominators,\n    SPs[" <> # <>"] \[LongDash] scalar products involving loop momenta,\n    LMs[" <> # <>"] \[LongDash] loop momenta,\n    EMs[" <> # <>"] \[LongDash] external momenta,\n    Toj[" <> # <>"] \[LongDash] rules to transform scalar products to denominators,\n    CutDs[" <> # <>"] \[LongDash] flag vector of cut denominators."] &@ToString[nm];
CurrentState[nm,NewDsBasis]=True;
If[save=!=False,
BasisDirectory[nm]=save;
DiskSave[nm,Save->"Basis"]];
(*Options processing*)
If[TrueQ[ss||fs||as||gi],
LiteRedPrint[Style["Generating IBP\[Ellipsis]",Bold]];GenerateIBP[nm]];
If[TrueQ[ss||fs||as],
LiteRedPrint[Style["Analyzing sectors\[Ellipsis]",Bold]];AnalyzeSectors[nm]];
If[TrueQ[ss||fs],
If[Not@TrueQ[Not@fes],
LiteRedPrint[Style["Finding external symmetries\[Ellipsis]",Bold]];
FindExtSymmetries[nm,##]&@@Replace[fes,True->$ActiveBases];
];
LiteRedPrint[Style["Finding symmetries\[Ellipsis]",Bold]];FindSymmetries[nm]];
If[TrueQ[ss],
LiteRedPrint[Style["Solving sectors\[Ellipsis]",Bold]];
SolvejSector[nm]];
(*/Options processing*)
If[save=!=False,
BasisDirectory[nm]=save;
DiskSave[nm]];
nm(*return basis*)
];


MIs[nm_,n:(0|1)..]:=Select[MIs[nm],jSector[#]==js[nm,n]&];
MIs[sec_js]:=MIs@@sec;


MIs/:Set[MIs[nm_,inds:(0|1)..],mis_List]:=(MIs[nm]^=jVars[{DeleteCases[MIs[nm],_?(jSector[#]===js[nm,inds]&)],mis},Sort->jSector]);


Ds[js[nm_,x:(0|1)..]]:=Pick[Ds[nm],{x},1];
(*Ds[j[nm_,x__Integer]]:=Pick[Ds[nm],{x},_?Positive];*)
Ds[jj_j]:=Ds[jSector@jj];


NDs[js[nm_,x:(0|1)..]]:=Count[{x},1];
(*Ds[j[nm_,x__Integer]]:=Pick[Ds[nm],{x},_?Positive];*)
NDs[jj_j]:=NDs[jSector@jj];
NDs[expr__]:=Length@Ds[expr];


cutds[patt_,nds_]:=Module[{pn,s0},
pn={patt/.{Alternatives->Sequence,Verbatim[BlankSequence[]]|Verbatim[BlankNullSequence[]]->s0,Verbatim[Blank[]]->0}}/.{a___,s0,(0)...,s0,b___}:>{a,s0,b};
If[MatchQ[pn,{({(1|0)..}|{(1|0)...,s0,(1|0)...})..}],
Times@@Replace[pn,list_List:>(list/.s0:>Sequence@@ConstantArray[0,{nds-Length[list]+1}]),{1}],
ConstantArray[0,nds]
]
]


Definitions::usage="Definitions[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] keeps external definitions required by \!\(\*
StyleBox[\"basis\", \"TI\"]\).";


ExecuteDefinitions::usage="ExecuteDefinitions[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] executes external definitions required by \!\(\*
StyleBox[\"basis\", \"TI\"]\): declares variables, sets dimensionality and scalar products.";
ExecuteDefinitions::nodefs="No definitions found.";
Options[ExecuteDefinitions]={Print->True};
ExecuteDefinitions[nm_,OptionsPattern[]]:=Module[{pr=OptionValue[Print]},
If[ValueQ[Definitions[nm]],
If[!ReleaseHold[#1],If[TrueQ@pr,LiteRedPrint["Condition ",#1, " is not satisfied. Executing ",Style[#2,Bold],"."]];ReleaseHold[#2]]&@@@((HoldForm/@#)&/@Definitions[nm]);,
Message[ExecuteDefinitions::nodefs];
]
]


CheckDefinitions::usage="CheckDefinitions[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] checks external definitions required by \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
CheckDefinitions::warn="Some external definitions used in '`1`' basis are missing. Probably, you should run ExecuteDefinitions[`1`].";
CheckDefinitions[nm_]:=
Module[{f=checkdefs[nm]},If[f=!={},Print["    Condition ",#1, " is not satisfied. Needs executing ",Style[#2,Bold],"."]&@@@f;Print["Probably, you should run ExecuteDefinitions["<>ToString[nm]<>"]"]];];


CheckDefs[nm_]:=Module[{f=checkdefs[nm]},If[f=!={},Message[CheckDefinitions::warn,nm]];];


checkdefs[nm_]:=If[ValueQ[Definitions[nm]],If[!ReleaseHold[#1],{#1,#2},Unevaluated[Sequence[]]]&@@@((HoldForm/@#)&/@Definitions[nm]),
Message[ExecuteDefinitions::nodefs];{}]


GraphToDs::usage="GraphToDs[graph,{l1,l2,\[Ellipsis]},dfun] constructs list of denominators from graph.\ngraph is a list of edges given in the form {n1->n2,label,[momemtum]}, where n1 and n2 are the numbers of vertices. Nonpositive n1 or n2 corresponds to external legs.\nIf dfun is omitted, the function (sp[#2]-#1&) is applied.\nExample:\n    GraphToDs[{{1->2,mm,l1},{1->3,mm},{2->3,0},{2->4,mm,l2},{3->4,mm},{0->1,q,q},{4->0,q,q}},{l1,l2},dfun] \[DoubleLongRightArrow]\n    {dfun[mm,l1],dfun[mm,-l1+q],dfun[0,l1-l2],dfun[mm,l2],dfun[mm,-l2+q]}";


GraphToDs[graph_,LMs_,Df_:(sp[#2]-#1&)]:=Module[
{vs,moms={},moms1,ngraph,eqs,sol,lms=LMs},
lms=Select[lms,FreeQ[graph,#]&];
(*get vertices*)
ngraph=Replace[#,{{e_,l_}:>((AppendTo[moms,#];{e,l,#})&[Unique[]]),{e_}:>((AppendTo[moms,#];{e,"",#})&[Unique[]])}]&/@graph;
eqs=Reap[Replace[ngraph,{a_->b_,_,m_}:>(Sow[-m,Max[0,a]];Sow[m,Max[0,b]]),{1}],_,Plus@@#2&][[-1]];
Quiet[sol=Solve[eqs==0,moms]];
If[sol=={},Return[$Failed]];
sol=First@sol;
moms1=Complement[moms,First/@sol];
ngraph=Df[##2]&@@@DeleteCases[ngraph/.sol/.Thread[moms1->lms],{(_?NonPositive->_)|(_->_?NonPositive),__}]
]


DiskSave::usage="DiskSave[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"dir\", \"TI\"]\)] saves to disk memory-consuming definitions for the basis at the cost of speed.It can be used also to save the basis to reuse it later.\nDiskSave[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] saves definitions to BasisDirectory[\!\(\*
StyleBox[\"basis\", \"TI\"]\)]\nOptions:\n    Save\[Rule](All|\"Basis\"|\"jRules\"|\"Sectors\"|\"Identities\"|{\"Basis\"|\"jRules\"|\"Sectors\"|\"Identities\"}) \[LongDash] determines what definitions to save. Save\[Rule]\"Basis\" saves the basis for further reuse. The default is Save\[Rule]All;\n    Replace\[Rule]True|False \[LongDash] determines whether to overwrite existing files.";


Options[DiskSave]={Directory->Automatic,Save->All,Replace->True};
DiskSave::dir="The directory `1` has been created.";
DiskSave::nodir="The directory for `1` has not been set. Use BasisDirectory[`1`]=\!\(\*
StyleBox[\"dirname\", \"TI\"]\).";
DiskSave::overwrite="The file `1` has been overwritten.";
DiskSave::warn="Warning: the file `1` exists. The basis has not been saved.";
DiskSave::optx="Unknown option value `1`.";
DiskSave::bd="Basis directory changed to `1`";


DiskSave[nm_,opts:OptionsPattern[]]:=
Module[
{t=Alternatives[],dir,tb=False,t1,t2,t3},
dir=OptionValue[Directory];
If[MatchQ[dir,_String],
If[!TrueQ@Not@BasisDirectory[nm],Message[DiskSave::bd,dir]],
dir=BasisDirectory[nm];
If[TrueQ@Not@dir,Message[DiskSave::nodir,nm];Return[$Failed]];
];
Replace[OptionValue[Save],
{All|Max:>(t="jRules[*"|"jExtRules[*"|"jSymmetries[*"|"jSymMatrices[*"|"MIs[*"|"ZeroSectors[*"|"NonZeroSectors[*"|"SimpleSectors[*"|"BasisSectors[*"|"UniqueSectors[*"|"MappedSectors[*"|"IBP[*"|"LI[*"|"SR[*";tb=True),
"Basis"|Min:>(tb=True),
"jRules":>(t="jRules[*"|"jExtRules[*"|"jSymmetries[*"|"jSymMatrices[*"),
"Sectors":>(t="ZeroSectors[*"|"NonZeroSectors[*"|"SimpleSectors[*"|"BasisSectors[*"|"UniqueSectors[*"|"MappedSectors[*"),
"Identities":>(t="IBP[*"|"LI[*"|"SR[*"),
x:{("jRules"|"Sectors"|"Identities"|"Basis")..}:>(
If[MemberQ[x,"jRules"],t=t|"jRules[*"|"jExtRules[*"|"jSymmetries[*"|"jSymMatrices[*"|"MIs[*"];
If[MemberQ[x,"Sectors"],t=t|"ZeroSectors[*"|"NonZeroSectors[*"|"SimpleSectors[*"|"BasisSectors[*"|"UniqueSectors[*"|"MappedSectors[*"];
If[MemberQ[x,"Identities"],t=t|"IBP[*"|"LI[*"|"SR[*"];
If[MemberQ[x,"Basis"],tb=True];
), 
x_:>Message[DiskSave::optx,Save->x]
}
];
If[!DirectoryQ[dir],CreateDirectory[dir];Message[DiskSave::dir,dir]];
If[t=!=Alternatives[],
(t1=ToString[HoldForm@@(First@#)];t2=Last@MapAt[Hold,#,{2}];
If[StringMatchQ[t1,t],
If[
(dir=!=BasisDirectory[nm]||!MatchQ[t2,Hold[Get[BasisDirectory[nm]<>#]]&["/"<>t1]])&&(!FileExistsQ[dir<>"/"<>t1]||OptionValue[Replace]),
If[FileExistsQ[dir<>"/"<>t1],Message[DiskSave::overwrite,t1]];
If[Check[If[dir=!=BasisDirectory[nm],
Put[First@t2,dir<>"/"<>t1],
ReleaseHold[ReplacePart[Hold[Put[##]],{1,1,0}->Unevaluated]]&[t2,dir<>"/"<>t1]];True,False],
ToExpression[ToString[nm]<>"/:"<>t1<>":=Get[BasisDirectory["<>ToString[nm]<>"]<>"<>"\"/"<>t1<>"\"]"]
]
];
])&/@UpValues[nm]];
If[tb,
t3=dir<>"/"<>ToString[nm];
BasisDirectory[nm]=dir;
If[!FileExistsQ[t3]||OptionValue[Replace],If[FileExistsQ[t3],Message[DiskSave::overwrite,t3]];Put[Unevaluated[BasisDirectory[nm]=StringDrop[DirectoryName[$Input],-1]],t3];(* modified 21.12.2012 *)(*PutAppend[Definition[nm],t3]*)
PutAppendUpValues[nm,t3](*/modified 21.12.2012 *);If[ValueQ[nm::usage],PutAppend[Unevaluated[nm::usage=#;Information[nm,LongForm->False];],t3]&[nm::usage]];PutAppend[Unevaluated[CheckDefs[nm]],t3];PutAppend[Unevaluated[BasisDirectory[nm]],t3],
Message[DiskSave::warn,t3];
]
];
];


DiskSave[nm_,dir_String]:=DiskSave[nm,Directory->dir,Save->All];


DiskRecover::usage="DiskRecover[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] recovers from disk memory-consuming definitions.\n\
Options:\n\
    Get\[Rule](All|\"jRules\"|\"Sectors\"|\"Identities\"|{\"jRules\"|\"Sectors\"|\"Identities\"})\
 \[LongDash] determines what definitions to recover. The default is Get\[Rule]All;\n\
    Remove\[Rule]True|False \[LongDash] determines whether to remove files afterwards.";


Options[DiskRecover]={Get->All,Remove->True};
DiskRecover::warn="Warning: the file `1` does not exists.";
DiskRecover::optx="Unknown option value `1`.";


DiskRecover[nm_,OptionsPattern[]]:=Module[
{t=Alternatives[],t1,t2,t3},
Replace[OptionValue[Get],
{All|Max:>(t="jRules[*"|"jExtRules[*"|"jSymmetries[*"|"jSymMatrices[*"|"MIs[*"|"ZeroSectors[*"|"NonZeroSectors[*"|"SimpleSectors[*"|"BasisSectors[*"|"UniqueSectors[*"|"MappedSectors[*"|"IBP[*"|"LI[*"|"SR[*"),
"jRules":>(t="jRules[*"|"jExtRules[*"|"jSymmetries[*"|"jSymMatrices[*"|"MIs[*"),
"Sectors":>(t="ZeroSectors[*"|"NonZeroSectors[*"|"SimpleSectors[*"|"BasisSectors[*"|"UniqueSectors[*"|"MappedSectors[*"),
"Identities":>(t="IBP[*"|"LI[*"|"SR[*"),
x:{("jRules"|"Sectors"|"Identities")..}:>(
If[MemberQ[x,"jRules"],t=t|"jRules[*"|"jExtRules[*"|"jSymmetries[*"|"jSymMatrices[*"];
If[MemberQ[x,"Sectors"],t=t|"ZeroSectors[*"|"NonZeroSectors[*"|"SimpleSectors[*"|"BasisSectors[*"|"UniqueSectors[*"|"MappedSectors[*"];
If[MemberQ[x,"Identities"],t=t|"IBP[*"|"LI[*"|"SR[*"];
), 
x_:>(Message[DiskRecover::optx,Get->x];Return[$Failed])
}
];
If[t=!=Alternatives[],
(t1=ToString[HoldForm@@(First@#)];t2=Last@MapAt[Hold,#,{2}];
If[StringMatchQ[t1,t],
If[t2[[1,0]]===Get,
t3=t2[[1,1]];
If[FileExistsQ[t3],
If[Check[ToExpression[ToString[nm]<>"/:"<>t1<>"=Get["<>"\""<>t3<>"\"]"];True,False]&&OptionValue[Remove],
DeleteFile[t3]],
Message[DiskRecover::warn,t3]
]
];
])&/@UpValues[nm]];
]


j::usage="j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"n1\", \"TI\"]\),\!\(\*
StyleBox[\"n2\", \"TI\"]\),\[Ellipsis]] denotes the integrand of the loop integral in \!\(\*
StyleBox[\"basis\", \"TI\"]\). \
Integer indices \!\(\*
StyleBox[\"n1\", \"TI\"]\),\!\(\*
StyleBox[\"n2\", \"TI\"]\),\[Ellipsis] denote powers of denominators. Negative values correspond to numerators.\n\
To compare the complexity of the integrals, use operators <,>,\[LessEqual],\[GreaterEqual].";


MakeBoxes[j[nm_,inds__],TraditionalForm]:=InterpretationBox[SubsuperscriptBox["j",RowBox[ToBoxes[#,TraditionalForm]&/@{inds}],ToBoxes[nm,TraditionalForm]],j[nm,inds]]


j/:Power[j[nm_,\[Alpha]__],\[Beta]_]/;Length@{\[Alpha]}===NDs[nm]:=j[nm,##]&@@(\[Beta]*{\[Alpha]});

j/:j[nm_,\[Alpha]__]*j[nm_,\[Beta]__]/;Length@{\[Alpha]}===Length@{\[Beta]}===NDs[nm]:=j[nm,##]&@@({\[Alpha]}+{\[Beta]});


j/:j[nm_][{\[Alpha]__}]:=j[nm,\[Alpha]];
j/:j[nm_][\[Alpha]__]:=j[nm,\[Alpha]];


js/:js[nm_][{\[Alpha]__}]:=js[nm,\[Alpha]];
js/:js[nm_][\[Alpha]__]:=js[nm,\[Alpha]];


js/:FromDigits[js[_,digits:(0|1)...]]:=FromDigits[Reverse[{digits}],2]


Toj::usage="Toj[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives rules to transform scalar products to denominators of the basis \!\(\*
StyleBox[\"basis\", \"TI\"]\).\nToj[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"expr\", \"TI\"]\)] transforms \!\(\*
StyleBox[\"expr\", \"TI\"]\) to linear combination of j[\!\(\*
StyleBox[\"basis\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)].\nToj[{\!\(\*
StyleBox[\"basis1\", \"TI\"]\),\!\(\*
StyleBox[\"basis2\", \"TI\"]\),\[Ellipsis]},expr] transforms expr to linear combination of j[\!\(\*
StyleBox[\"basis1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)],j[\!\(\*
StyleBox[\"basis2\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)],\[Ellipsis]\nOption SectorsPattern\[Rule]True|False:True indicates whether appearing j[\!\(\*
StyleBox[\"basis\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)] should fall into SectorsPattern[\!\(\*
StyleBox[\"basis\", \"TI\"]\)].";
Toj::fail="Failed to express `1` via j[\[Ellipsis]]";


Options[Toj]={SectorsPattern->False,PolynomialQ->True};


Toj[nm_,expr_List,opts:OptionsPattern[]]:=Toj[nm,#,opts]&/@expr;


Toj[nm_,expr_,OptionsPattern[]]:=Module[{
nms=Flatten[{nm}],
monoms,polyjQ,fail=False,mn},
polyjQ=If[TrueQ[OptionValue@PolynomialQ],TrueQ[(#===0||jVars[#]=!={})&&PolynomialQ[#,jVars[#]]&&(Not[TrueQ[OptionValue[SectorsPattern]]]||And@@(MatchQ[Rest[List@@#],SectorsPattern[First@#]]&/@DeleteDuplicates[jSector/@jVars[#]]))]&,True&];
monoms=Replace[{expr},Plus->Sequence,{2},Heads->True];
monoms=Map[Function[m, 
Catch[Scan[(mn=toj[#,m];If[polyjQ[mn],Throw[mn]])&,nms];fail=True;Throw[m]]
],monoms];
If[fail,Message[Toj::fail,expr]];
(*Modified 27.05.2019*)Collectj[Plus@@monoms](*/Modified 27.05.2019*)
];


toj[nm_,expr_Plus]:=toj[nm,#]&/@expr;(*just in case*)


toj[nm_?DsBasisQ,expr_]:=Module[{},
Collect[ExpandAll@Factor[j[nm,Sequence@@(0&/@Ds@nm)]*(LFDistribute[expr,sp]/.Toj[nm])],_j,Factor]
];


toj[nm_?DsSetQ,expr_]:=Module[{fexpr=Factor[expr],den,num,ds=LFDistribute[Ds[nm],sp],l,lms=Alternatives@@LMs[nm],df,tojf},
l=Length@ds;
tojf=Times@@((If[FreeQ[#1,lms],#1,df=#1;Do[If[FreeQ[Factor[#1/ds[[i]]],lms],df=j[nm,##]&@@RotateRight[PadLeft[{-1},l],i];Break[]],{i,l}];df/.Toj[nm]]^#2)&@@@LFDistribute[FactorList@#,sp])&;
(*tojf expresses polynomial expressions in terms of j trying to make it in optimal way*)
(*denominator is supposed to be proportional to j[...], so each factor should be either proportional to D_i or independent of loop momenta*)
den=tojf@Denominator[fexpr];
(*numerator is not supposed to be proportional to j[...], but still we try*)
num=tojf@Numerator[fexpr];
Expand[j[nm,Sequence@@ConstantArray[0,l]]*num/den]
];


Fromj::usage="Fromj[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] rewrites all j[\[Ellipsis]] in \!\(\*
StyleBox[\"expr\", \"TI\"]\) via scalar products."


Fromj[js[nm_,x:(0|1)...]]:=Pick[Ds[nm],{x},1];
Fromj[expr_]:=expr/.j[nm_,x:Except[_List]..]:>Times@@((Ds[nm])^(-{x}));


MakeOrderMatrix::usage="MakeOrderMatrix[{0,1,\[Ellipsis]},{spec2,spec2,\[Ellipsis]}] constructs the order matrix for the sector {0,1,\[Ellipsis]}.\n\
MakeOrderMatrix[] prints an extended help (in particular, possible values for spec1,spec2,\[Ellipsis]).";


MakeOrderMatrix::bad="Order matrix `1` is not definitive.";


MakeOrderMatrix[]:=Print[Style["MakeOrderMatrix[{0, 1, \[Ellipsis]}, {spec1, spec2, \[Ellipsis]}]",Bold]," constructs the order matrix for the sector {0,1,\[Ellipsis]}. Each spec1,spec2,\[Ellipsis] can be one of the following:\n    \"\[PlusMinus]np\" \[LongDash] plus/minus total power of numerators,\n    \"\[PlusMinus]dp\" \[LongDash] plus/minus total power of denominators,\n    \"\[PlusMinus]ns\" \[LongDash] plus/minus numerator powers,\n    \"\[PlusMinus]ds\" \[LongDash] plus/minus denominator powers,\n    \[PlusMinus]1,\[PlusMinus]2,etc \[LongDash] power of the corresponding denominator or numerator.\nPlus sign can be omitted.\n",Style["MakeOrderMatrix[{0,1,\[Ellipsis]}]",Bold]," is equivalent to ",Style["MakeOrderMatrix[{0,1,\[Ellipsis]},{\"np\",\"ns\",\"ds\"}]",Bold],".\n",Style["MakeOrderMatrix[js[nm,0,1,\[Ellipsis]],{\[Ellipsis]}]",Bold]," is equivalent to ",Style["MakeOrderMatrix[{0,1,\[Ellipsis]},{\[Ellipsis]}].",Bold]];


MakeOrderMatrix[js[_,ns:(0|1)...],spec___]:=MakeOrderMatrix[{ns},spec]
MakeOrderMatrix[sec:{(0|1)...},spec:_List:{"np","ns","ds"}]:=Module[{
l=Length[sec],
m={2sec-1}(*First criterion is total power, obligatory!*),
unfold,
r=0,
mf={}
},
unfold=MapIndexed[(If[#1===0,Unevaluated[Sequence[]],RotateRight[PadLeft[{#1},l],First@#2]])&,#]&;
Replace[
spec,
{
"np"|"+np":>AppendTo[m,sec-1],
"-np":>AppendTo[m,1-sec],
"dp"|"+dp":>AppendTo[m,sec],
"-dp":>AppendTo[m,-sec],
"ns"|"+ns":>(m=Join[m,unfold[sec-1]]),
"-ns":>(m=Join[m,unfold[1-sec]]),
"ds"|"+ds":>(m=Join[m,unfold[sec]]),
"-ds":>(m=Join[m,unfold[-sec]]),
i_Integer?Positive:>AppendTo[m,RotateRight[PadLeft[{1},l],i]],
i_Integer?Negative:>AppendTo[m,RotateRight[PadLeft[{-1},l],-i]]
},
{1}
];
(*Matrix should be constructed, but we need to check consistency and trim extra lines*)
If[MatrixRank[m]<l,Message[MakeOrderMatrix::bad,m]];
m
]


jsOrder::usage="jsOrder[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,...] determines the ordering in the specific sector.\n\
Use jsOrder[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,...]=specification to set the ordering of the specific sector.\n\
specification can be one of the following:\n\
    {-1|1, -1|0|1, permutation},\n\
    {-1|1, permutation} \[LongDash] shortcut for {-1|1, 0, permutation},\n\
    {permutation} \[LongDash] shortcut for {1, -1, permutation}.\n\
Here {permutation} \[LongDash] permutation list of length #indices. Specification {1,0, permutation} means that jComplexity[j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"indices\", \"TI\"]\)]] gives {\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"#denominators\", \"TI\"]\),\!\(\*
StyleBox[\"#ofsector\", \"TI\"]\),\!\(\*
StyleBox[\"\[CapitalSigma]all_powers\", \"TI\"]\),\!\(\*
StyleBox[\"\[CapitalSigma]den_powers\", \"TI\"]\),\!\(\*
StyleBox[\"permutation_of\", \"TI\"]\)\!\(\*
StyleBox[\"_indices\", \"TI\"]\)}, while {-1,0, permutation} corresponds to  {\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"#denominators\", \"TI\"]\),\!\(\*
StyleBox[\"#ofsector\", \"TI\"]\),\!\(\*
StyleBox[\"\[CapitalSigma]all_powers\", \"TI\"]\),\!\(\*
StyleBox[\"\[CapitalSigma]num_powers\", \"TI\"]\),\!\(\*
StyleBox[\"permutation_of\", \"TI\"]\)\!\(\*
StyleBox[\"_indices\", \"TI\"]\)}.
The specification {s, \[PlusMinus]1, permutation} applies additional permutation to secure that indices, corresponding to denominators/numerators come first.\n\ 
Default setting is {1,-1,1,2,3,\[Ellipsis],n}.";
jsOrder::wrng="Wrong specification of order. See ?jsOrder.";


jsOrder[nm_,ns:(0|1)...]:=(nm/:jsOrder[nm,ns]=MakeOrderMatrix[{ns}]);


todo["Standartize length of jsorder!"];


jsOrder/:TagSet[nm_,jsOrder[nm_,n__],y_List]:=Module[{nm1,n1,y1,l=Length[{n}],pl,cr,sort},
(*Possible formats for y:*)
If[MatrixQ[y],
pl=y(*PadRight[y,Length[{n}]+2,0*Last[y]]*)(*new format*),
(*DEPRECATED branch*)
(*old shortcuts*)
If[!(l<=Length@y<=l+2),Message[jsOrder::wrng];Return[jsOrder[nm,n]]];
pl=Take[y,-l];(*take last l elements*)
If[Sort@pl=!=Range[l],Message[jsOrder::wrng];Return[jsOrder[nm,n]]];(*check consistency*)
sort=Join[Pick[#1,{n}[[#1]],#2],Pick[#1,{n}[[#1]],1-#2]]&;
pl=Replace[Drop[y,-l],{
{1,-1}|{}:>(pl=sort[pl,0];MakeOrderMatrix[{n},{"-dp",Sequence@@(pl(1-2{n}[[pl]]))}]),
{1}|{1,0}:>MakeOrderMatrix[{n},{"-dp",Sequence@@(pl(1-2{n}[[pl]]))}],
{-1}|{-1,0}:>MakeOrderMatrix[{n},{"dp",Sequence@@(pl(1-2{n}[[pl]]))}],
{-1,-1}:>(pl=sort[pl,0];MakeOrderMatrix[{n},{"dp",Sequence@@(pl(1-2{n}[[pl]]))}]),
{1,1}:>(pl=sort[pl,1];MakeOrderMatrix[{n},{"-dp",Sequence@@(pl(1-2{n}[[pl]]))}]),
{-1,1}:>(pl=sort[pl,1];MakeOrderMatrix[{n},{"dp",Sequence@@(pl(1-2{n}[[pl]]))}]),
_:>(Message[jsOrder::wrng];Return[jsOrder[nm,n]])
}
]
(*/DEPRECATED branch*)
];
(*Big replace goes here*)
Internal`InheritedBlock[{jsOrder},
(*First, clean definition to avoid recursion*)
jsOrder/:TagSet[nm1_,jsOrder[nm1_,n1__],y1_List]=.;
nm/:jsOrder[nm,n]=pl
]
];


jsOrder/:Set[jsOrder[nm_,n__],y_List]:=TagSet[nm,jsOrder[nm,n],y]


jComplexity::usage="jComplexity[j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"indices\", \"TI\"]\)]] gives a complexity level of the integral, which is {\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"#denominators\", \"TI\"]\),\!\(\*
StyleBox[\"#ofsector\", \"TI\"]\),\!\(\*
StyleBox[\"\[CapitalSigma]all_powers\", \"TI\"]\),\!\(\*
StyleBox[\"\[CapitalSigma]num_powers\", \"TI\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\",\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"num_powers\", \"TI\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\",\", \"TI\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"den_powers\", \"TI\",\nFontVariations->{\"Underline\"->True}]\)}.\n\
One can modify underlined part via setting jsOrder (see ?jsOrder).
jComplexity[\!\(\*
StyleBox[\"j1\", \"TI\"]\),\!\(\*
StyleBox[\"j2\", \"TI\"]\)] is a shortcut for Expand[jComplexity@j1-jComplexity@j2].";


SetAttributes[jComplexity,Listable];


jComplexity[j[nm_,n__]]:=Module[
{jsec0=jSector@nm,jsec,jsec1,
jsorder,num},
If[Head[jsec0]=!=js,Message[jSector::jtop,nm];Abort[]];
jsec0=Rest[List@@jsec0];
{jsec1,jsec}=Transpose[Replace[Transpose[{{n},jsec0}],{x_Integer,_}:>{x,Boole[Positive[x]]},{1}]];
(*added 19.07.2014*)jsec0=FromDigits[jsec,2];(*/added 19.07.2014*)
jsorder=jsOrder[nm,##]&@@jsec;
If[MatrixQ[jsorder],
Return[{nm,Plus@@jsec,jsec0,Sequence@@(jsorder.jsec1)}]
,
(*DEPRECATED branch*)
jsorder=PadLeft[jsorder,Length@{n}+1,1];(*just in case*)
num=First@jsorder;jsorder=Rest[jsorder];
{jsec1,jsec}={permute[jsec1,jsorder],permute[jsec,jsorder]};
Return[{nm,Plus@@jsec,jsec0,Plus@@#,-num*#.jsec,Sequence@@(-#)}&[jsec1*(2 jsec-1)]]
(*/DEPRECATED branch*)
]
]


jComplexity[j1_j,j2_j]:=Expand[jComplexity@j1-jComplexity@j2]


j/:j[nm1_,inds1__]<j[nm2_,inds2__]:=Module[{jc=jComplexity[j[nm1,inds1],j[nm2,inds2]],jc0},jc0=0&/@jc;
Return[(jc=!=jc0)&&MatchQ[Expand[{inds1}-{inds2}],{__Integer}]&&OrderedQ[{jc,jc0}]]]
j/:j[nm1_,inds1__]>j[nm2_,inds2__]:=Module[{jc=jComplexity[j[nm1,inds1],j[nm2,inds2]],jc0},jc0=0&/@jc;
Return[(jc=!=jc0)&&MatchQ[Expand[{inds1}-{inds2}],{__Integer}]&&OrderedQ[{jc0,jc}]]]
j/:j[nm1_,inds1__]<=j[nm2_,inds2__]:=Module[{jc=jComplexity[j[nm1,inds1],j[nm2,inds2]],jc0},jc0=0&/@jc;
Return[MatchQ[Expand[{inds1}-{inds2}],{__Integer}]&&OrderedQ[{jc,jc0}]]]
j/:j[nm1_,inds1__]>=j[nm2_,inds2__]:=Module[{jc=jComplexity[j[nm1,inds1],j[nm2,inds2]],jc0},jc0=0&/@jc;
Return[MatchQ[Expand[{inds1}-{inds2}],{__Integer}]&&OrderedQ[{jc0,jc}]]]


jsSignature::usage="jsSignature[\!\(\*
StyleBox[\"basis\", \"TI\"]\),1,0,\!\(\*
StyleBox[\"...\", \"TI\"]\)] returns unique signature of the sector. Two sectors are equivalent iff they have the same signature. Shortcut: jsSignature[js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),1,0,\!\(\*
StyleBox[\"...\", \"TI\"]\)]].";


jsSignature[js[nm_,inds:(0|1)...]]:=jsSignature[nm,inds];
jsSignature[nm_,inds:(0|1)...]:=Module[
{U,F,xs,x0},
{U,F,xs}=FeynParUF[js[nm,inds],Function->False];
PolySignature[{U+F,xs.Pick[CutDs[nm],{inds},1]},Append[xs,x0]]
]


jsSignature[ds_List,ls_List]:=Module[
{U,F,xs},
{U,F,xs}=FeynParUF[ds,ls,Function->False];
PolySignature[U+F,xs]
]


jsSignaturePermutations::usage="jsSignaturePermutations[\!\(\*
StyleBox[\"basis\", \"TI\"]\),1,0,\!\(\*
StyleBox[\"...\", \"TI\"]\)] gives a list {\!\(\*
StyleBox[\"signature\", \"TI\"]\),\!\(\*
StyleBox[\"permutations\", \"TI\"]\)}. See ?jsSignature for the explanation of the first element. Second element gives permutations of the variables which leave polynomial invariant.";


jsSignaturePermutations[js[nm_,inds:(0|1)...]]:=jsSignaturePermutations[nm,inds];
jsSignaturePermutations[nm_,inds:(0|1)...]:=Module[
{U,F,xs,x0},
{U,F,xs}=FeynParUF[js[nm,inds],Function->False];
{#1,DeleteCases[#,1+Length@xs]&/@#2}&@@PolySignaturePermutations[U+F+x0*Total[Pick[xs,Pick[CutDs[nm],{inds},1],1]],Append[xs,x0]]
]


jsSignaturePermutations[ds_List,ls_List]:=Module[
{U,F,xs},
{U,F,xs}=FeynParUF[ds,ls,Function->False];
PolySignaturePermutations[U+F,xs]
]


jSignature::usage="jSignature[j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),1,0,\!\(\*
StyleBox[\"...\", \"TI\"]\)]] returns unique signature for the master integral. Two masters are equal if they have the same signature."


jSignature[j[nm_,ii__Integer]]:=Module[{U,F,cds,xs},
{U,F,xs}=FeynParUF[Pick[Ds[nm],#=!=0&/@{ii}],LMs[nm]];
cds=Pick[CutDs[nm],#=!=0&/@{ii}];
PolySignature[{U+F,xs.cds,xs.DeleteCases[{ii},0]},xs]
]


todo["jVars work very slowly due to ordering."];


jVars::usage="jVars[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] gives all j[\[Ellipsis]] of \!\(\*
StyleBox[\"expr\", \"TI\"]\) in the order from simplest to the most complex.";


Options[jVars]={Sort->Less};


jVars[expr_,OptionsPattern[]]:=Replace[OptionValue@Sort,
{
jSector:>Flatten[Sort[Sort[#,Less]&/@GatherBy[DeleteDuplicates@Cases[{expr},_j,\[Infinity]],jSector],(#1[[1]]<#2[[1]])&]],
s_:>Sort[DeleteDuplicates[Cases[{expr},_j,\[Infinity]]],s]
}
];
jVars[expr_,jsec_,OptionsPattern[]]:=Replace[OptionValue@Sort,
{
jSector:>Flatten[Sort[Sort[#,Less]&/@GatherBy[DeleteDuplicates@Cases[{expr},_j?(MatchQ[jSector[#],jsec]&),\[Infinity]],jSector],(#1[[1]]<#2[[1]])&]],
s_:>Sort[DeleteDuplicates[Cases[{expr},_j?(MatchQ[jSector[#],jsec]&),\[Infinity]]],s]
}
];


Highj::usage="Highj[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] gives the most complex j[\[Ellipsis]] of \!\(\*
StyleBox[\"expr\", \"TI\"]\). If there are no j[\[Ellipsis]] in \!\(\*
StyleBox[\"expr\", \"TI\"]\) then Highj[\!\(\*
StyleBox[\"expr\", \"TI\"]\)]\[Rule]{}.\n\
Essentially, it gives the same result as Last[jVars[\!\(\*
StyleBox[\"expr\", \"TI\"]\)]] but does it faster.";


Highjs::usage="Highjs[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] gives the list of the most complex j[\[Ellipsis]] of \!\(\*
StyleBox[\"expr\", \"TI\"]\).";


Highj[expr_]:=Module[{jv,jvars=Union[Cases[{expr},_j,\[Infinity]]],jc0,jc,jc1},
If[jvars==={},{},
jv=First@jvars;jc=jComplexity@jv;
jc0=ConstantArray[0,Length@jc];
Scan[If[OrderedQ[{Expand[jc-(jc1=jComplexity@#)],jc0}],jv=#;jc=jc1]&,Rest@jvars];
jv
]]


Highjs[expr_]:=Module[{jv,jvars=DeleteDuplicates[Cases[{expr},_j,\[Infinity]]],jc0,jc,jc1},
If[jvars==={},{},
jv={First@jvars};jc=Take[jComplexity@First@jv,3];
jc0=ConstantArray[0,Length@jc];
Scan[(jc1=Take[jComplexity@#,3];Which[jc1===jc,AppendTo[jv,#],OrderedQ[{Expand[jc-jc1],jc0}],jv={#};jc=jc1])&,Rest@jvars];
jv
]]


HighjIndex::usage="HighjIndex[{j[\[Ellipsis]],j[\[Ellipsis]]\[Ellipsis]}] gives the index of the most complex j[\[Ellipsis]] in the list. If the list is empty it returns zero.\n\
Since this function is designed to be as fast as possible, there is no fool proof, so the proper argument is your responsibility.";


HighjIndex[jvars_List]:=Module[{ji,jc0,jc,jc1},
Global`deb1="hji="<>ToString[Length@jvars];
If[jvars==={},Global`deb1="";0,
ji=1;jc=jComplexity@First@jvars;
jc0=ConstantArray[0,Length@jc];
MapIndexed[If[OrderedQ[{Expand[jc-(jc1=jComplexity@#)],jc0}],ji=1+First@#2;jc=jc1]&,Rest@jvars];
Global`deb1="";
ji
]];


LowjIndex[jvars_List]:=Module[{ji,jc0,jc,jc1},
If[jvars==={},0,
ji=1;jc=jComplexity@First@jvars;
jc0=ConstantArray[0,Length@jc];
MapIndexed[If[OrderedQ[{jc0,Expand[jc-(jc1=jComplexity@#)]}],ji=1+First@#2;jc=jc1]&,Rest@jvars];
ji
]];


js::usage="js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),1,0,\[Ellipsis]] denotes a sector. You can use comparisons <,>,\[LessEqual],\[GreaterEqual] between two sectors."
jSector::usage="jSector[j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\[Ellipsis]]] gives the sector of the integral, that is, the object of the form js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),1,0,\[Ellipsis]] \
with 1 denoting the presence of the corresponding denominator.\n\
jSector[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a 'default' sector of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) used to resolve the sign of symbolic indices.";


jSector::jtop="jSector[`1`] is not defined.";


jSector[nm_]:=js[nm,##]&@@ConstantArray[1,Length@Ds@nm];


(*Added*)jSector[j[{nm_,d_},\[Alpha]__]]:=jSector[j[nm,\[Alpha]]];(*/Added*)
jSector[j[nm_,\[Alpha]__]]:=js@@Replace[Transpose[{{nm,\[Alpha]},List@@jSector@nm}],{{x_Integer,_}:>UnitStep[x-1/2],{_,x:(0|1)}:>x,_:>nm},{1}];


js/:Less[js[nm1_,x1:(0|1)...],js[nm2_,x2:(0|1)...]]:=nm1===nm2&&jsectlt[{x1}-{x2}];
js/:LessEqual[js[nm1_,x1:(0|1)...],js[nm2_,x2:(0|1)...]]:=nm1===nm2&&jsectle[{x1}-{x2}];
js/:Greater[js[nm1_,x1:(0|1)...],js[nm2_,x2:(0|1)...]]:=nm1===nm2&&jsectgt[{x1}-{x2}];
js/:GreaterEqual[js[nm1_,x1:(0|1)...],js[nm2_,x2:(0|1)...]]:=nm1===nm2&&jsectge[{x1}-{x2}];


jSubsectors::usage="jSubsectors[js[basis,1,0,\[Ellipsis]]] gives the list of subsectors  of the sector.\nOptions: \n    MappedSectors\[Rule]True|False:True \[LongDash] whether to use mapping between the sectors,\n    Depth\[Rule]\!\(\*
StyleBox[\"nmax\", \"TI\"]\)|{\!\(\*
StyleBox[\"nonly\", \"TI\"]\)}|{\!\(\*
StyleBox[\"nmin\", \"TI\"]\),\!\(\*
StyleBox[\"nmax\", \"TI\"]\)}:Infinity \[LongDash] determines how many propagators are contracted.";


Options[jSubsectors]={MappedSectors->True,Depth->Infinity};jSubsectors[jsec:js[nm_,(0|1)...],OptionsPattern[]]:=Module[{nd=Count[jsec,1],res},
(*Form the list of subsectors by striking out some 1s*)res=DeleteCases[ReplacePart[jsec,Thread[#->0]]&/@Subsets[Flatten@Position[jsec,1],OptionValue[Depth]],Alternatives@@ZeroSectors[nm]];
If[OptionValue[MappedSectors],
res=DeleteDuplicates[(#/.ExtSectorsMappings[nm]/.SectorsMappings[nm])&/@res]
];
res
]


SectorHierarchy::usage="SectorHierarchy[{js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,\[Ellipsis]],\[Ellipsis]}] gives the hierarchy matrix for the sectors, i.e., the matrix which contains 1s on (\!\(\*
StyleBox[\"i\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"k\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) place if \!\(\*
StyleBox[\"k\", \"TI\"]\)-th sector is a subsector of \!\(\*
StyleBox[\"i\", \"TI\"]\)-th sector.\n  Option \"MappedSectors \[Rule] True|False:True\" determines whether to account for symmetries.";


Options[SectorHierarchy]={MappedSectors->True};SectorHierarchy[jsecs:{js[_,(0|1)...]...},OptionsPattern[]]:=Module[{jsubsecs,hie},
LiteRedMonitor[
jsubsecs=jSubsectors[#,MappedSectors->OptionValue[MappedSectors],Depth->Infinity]&/@jsecs
,"Evaluating subsectors..."];
LiteRedMonitor[
hie=Outer[Boole[MemberQ[#1,#2]]&,jsubsecs,jsecs,1]
,"Constructing matrix..."];
hie
]


SectorHierarchy[jjs:{___j},opts:OptionsPattern[]]:=SectorHierarchy[jSector/@jjs,opts]


SectorLayer::usage="SectorLayer[js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\[Ellipsis]],\!\(\*
StyleBox[\"depth\", \"TI\"]\)] gives the integrals of the sector with overall declination of indices from those of corner point not more than \!\(\*
StyleBox[\"depth\", \"TI\"]\).\n SectorLayer[js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\[Ellipsis]],{\!\(\*
StyleBox[\"depth\", \"TI\"]\)}] gives the integrals with declination equal to \!\(\*
StyleBox[\"depth\", \"TI\"]\).\nSectorLayer[js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\[Ellipsis]],{\!\(\*
StyleBox[\"from\", \"TI\"]\),\!\(\*
StyleBox[\"to\", \"TI\"]\)}] gives the integrals with declination from \!\(\*
StyleBox[\"from\", \"TI\"]\) to \!\(\*
StyleBox[\"to\", \"TI\"]\).";


SectorLayer[js[nm_,n:(0|1)..],{depth_Integer?NonNegative}]:=j[nm]@@@(({n}+#)&/@layer[{n},depth])


SectorLayer[js[nm_,n:(0|1)..],depth_Integer?NonNegative]:=j[nm]@@@(({n}+#)&/@Join@@(layer[{n},#]&/@Range[0,depth]))
SectorLayer[js[nm_,n:(0|1)..],{from_Integer?NonNegative,to_Integer?NonNegative}]:=j[nm]@@@(({n}+#)&/@Join@@(layer[{n},#]&/@Range[from,to]))


GenerateIBP::usage="GenerateIBP[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] generates IBP and LI identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
IBP::usage="IBP[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the IBP (integration-by-part) identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
LI::usage="LI[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the LI(Lorentz invariance) identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
IBPLI::usage="IBPLI[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the IBP&LI identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";


GenerateIBP[nm_]:=Module[{ds=LFDistribute[Ds@nm,sp],dim=Length[Ds@nm],lms=LMs@nm,ems=EMs@nm,le=Length@EMs@nm,qms,dp,sh,ibps,lis,slot},
CurrentState[nm,GenerateIBP]=False;
If[!ValueQ[Ds@nm],Message[NewDsBasis::notb];Return[$Failed]];qms=Join[lms,ems];dp=Table[Unique["n"],{dim}];
sh=Thread[dp->dp+PowerShifts[nm]];
ibps=Outer[Function[{qm,lm},Collectj[Expand[(j[nm,##1]&)@@dp (Boole[qm===lm]MetricTensor[]-Plus@@MapIndexed[Function[{den,ind},dp[[First[ind]]] (j[nm,##1]&@@IntegerDigits[2^(dim-First[ind]),2,dim])*Plus@@(2^Boole[#1===lm] sp[qm,#1] Coefficient[den,sp[lm,#1]]&)/@qms/. Toj[nm]],ds])],Factor[#/.sh]&]],qms,lms];lis=Plus@@MapIndexed[(#1/.{j[nm,x__]:>(ibps[[Range[-Length@ems,-1],First@#2]]/.Thread[dp->dp+{x}])})&,Expand[(j[nm,##]&@@ConstantArray[0,{dim}])Outer[sp,lms,ems]/.Toj[nm]]];lis=Collectj[(lis[[##]]&@@Reverse[#])-(lis[[##]]&@@#),Factor[#/.sh]&]&/@Subsets[Range[Length@ems],{2}];
IBP[nm]^=Function[Evaluate@Flatten[ibps]]/.Thread[dp->Table[slot[i],{i,dim}]]/.slot->Slot;
LI[nm]^=Function[Evaluate@lis]/.Thread[dp->Table[slot[i],{i,dim}]]/.slot->Slot;
Remove/@dp;LiteRedPrint["Identities are generated.\n    IBP[" <> # <>"] \[LongDash] integration-by-part identities,\n    LI[" <> # <>"] \[LongDash] Lorentz invariance identities."] &@ToString[nm];
CurrentState[nm,GenerateIBP]=True;
]


IBP[nm_,inds__]:=IBP[nm][inds];
LI[nm_,inds__]:=LI[nm][inds];


IBPLI[nm_]/;ValueQ[IBP[nm]]&&ValueQ[LI[nm]]:=Function@@{Join[First@IBP@nm,First@LI@nm]};
IBPLI[nm_,inds__]:=IBPLI[nm][inds];


SetAttributes[SmallCircle,{Flat,OneIdentity}];
SetLinearIn[FreeQ[#,LiteRed`A|LiteRed`B]&,SmallCircle,All];
Module[{a,b},
SmallCircle[a___,1,b___]:=SmallCircle[a,b]
];
LFRules=Union[LFRules,{sc_SmallCircle/;Length[sc]<2:>Times@@sc}];


ToAB::usage="ToAB[\!\(\*
StyleBox[\"expr\", \"TI\"]\),j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]]] gives the \!\(\*
StyleBox[\"AB\", \"TI\"]\)-form of \!\(\*
StyleBox[\"expr\", \"TI\"]\).\nToAB[\*
StyleBox[\(\!\(\*
StyleBox[\"expr_\", \"TI\"]\)Function\)],\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is a shortcut for ToAB[\!\(\*
StyleBox[\"expr\", \"TI\"]\)[n1,n2,\[Ellipsis]],j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]]].\nToAB threads through lists in \!\(\*
StyleBox[\"expr\", \"TI\"]\).";
A::usage=B::usage="A and B are reserved names for the corresponding operators. They appear in the output of ToAB, see ?ToAB.";
AtoLeft::usage="AtoLeft[expr] pull all A operators to the left";


FromAB::usage="FromAB[\!\(\*
StyleBox[\"expr\", \"TI\"]\),\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the Function-form of \!\(\*
StyleBox[\"expr\", \"TI\"]\).\nFromAB[\*
StyleBox[\(\!\(\*
StyleBox[\"expr_\", \"TI\"]\)Function\)],j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]]] is a shortcut for FromAB[\!\(\*
StyleBox[\"expr\", \"TI\"]\),\!\(\*
StyleBox[\"basis\", \"TI\"]\)][n1,n2,\[Ellipsis]].\nFromAB threads through lists in \!\(\*
StyleBox[\"expr\", \"TI\"]\).";
FromTildeAB::usage="FromTildeAB[\!\(\*
StyleBox[\"expr\", \"TI\"]\),\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is a faster version of FromAB[InverseTildeConjugate[\!\(\*
StyleBox[\"expr\", \"TI\"]\),\!\(\*
StyleBox[\"basis\", \"TI\"]\)],\!\(\*
StyleBox[\"basis\", \"TI\"]\)].";


Protect[A,B];


Module[{jj},
ToAB[expr_Function,nm_]:=ToAB[expr[##],j[nm,##]]&@@Table[Unique["n"],{Length@Ds[nm]}];
ToAB[expr_List,jj_j]:=ToAB[#,jj]&/@expr;
ToAB[expr_,j[nm_,indices__]]:=toab[expr/.j[nm,inds__]:>jj[inds],jj,{indices}];
ToAB[expr_,jj_,indices_List]:=toab[expr,jj,indices];
];


AtoLeft[expr_]:=Collect[expr/.{HoldPattern[SmallCircle[ex:Subscript[(A|B), _]...]]:>atoleft[ex]},_SmallCircle];


FromAB[expr_,j[nm_,indices__]]:=FromAB[expr,nm][indices];
FromAB[expr_List,nm_]:=Function@@{First[FromAB[#,nm]]&/@expr};
FromAB[expr_,nm_]:=Module[{dots,form,n=Length@Ds[nm],slots},
slots=Table[Unique[],{n}];
form=Plus@@(#1(ablisttoexpr[#2,j[nm,##]&,slots])&@@@ablistform[expr]);
Function@@({form}/.Thread[slots->Slot/@Range[n]])
]


FromTildeAB[expr_,nm_]:=Module[{a,b,n=Length@Ds[nm],form,slots,t},
slots=Table[Unique[],{n}];
form=ablistform[expr];
t=Count[#2,Subscript[A, _]]-Count[#2,Subscript[B, _]]&@@@form;
b=Max[t];
a=(Length@LMs@nm+1)*MetricTensor[]/2-Plus@@slots-b;
form=Plus@@(Pochhammer[a,b-#1]#2(ablisttoexpr[#3,j[nm,##]&,slots])&@@@Prepend@@@Transpose[{form,t}]);
Function@@({form}/.Thread[slots->Slot/@Range[n]])
]


ablistform[expr_]:=Module[{form,dots,x,sc},
form=expr/.op:Subscript[(A|B), _]:>SmallCircle[op]/.SmallCircle->sc;
dots=DeleteDuplicates@Cases[{form},_sc,\[Infinity]];
form=Flatten[{#/.Thread[#2->0],Coefficient[#,#2]}&[form,dots]];
Transpose[{form,Prepend[List@@@dots,{}]}]
]


toab[recurr_,f_,ns_]:=Module[{ABs,As,Bs,rec,fs,nshifts,form,qrf,qr},
(*Insert foolproof later*)
ABs=Array[Subscript[AB, #]&,Length@ns];
As=Array[Subscript[A, #]&,Length@ns];
Bs=Array[Subscript[B, #]&,Length@ns];
rec=Collect[recurr,_f];(*to account for possible cancellations*)
fs=List@@@DeleteDuplicates@Cases[{rec},f@@(ns+_.),\[Infinity]];
nshifts=Max/@Transpose[(#-ns)&/@fs];(*indices shifts*)
(*Insert foolproof later*)
form=Plus@@((#2/.Thread[ns->ABs-nshifts])*Times@@(Bs^(ns+nshifts-First[Pick[fs,#1,1]]))&@@@CoefficientRules[rec,f@@@fs]);
(*Now we have to factor Bs from the left.*)
qrf[p_,i_]:={Factor[(p-(p/.Subscript[B, i]->0)/.Subscript[AB, i]->Subscript[AB, i]+1)/Subscript[B, i]+Subscript[A, i]*((p/.Subscript[B, i]->0)-(p/.Subscript[B, i]->0/.Subscript[AB, i]->1))/(Subscript[AB, i]-1)],Factor[(p/.Subscript[B, i]->0/.Subscript[AB, i]->1)]};
Do[(*Divide by B if possible*)
While[MatchQ[qr=qrf[form,i],{_,0}],form=First@qr],
{i,Length@Bs}];
Plus@@((#2*SmallCircle@@DeleteCases[Flatten@MapIndexed[MapThread[ConstantArray,{{Subscript[A, First[#2]],SmallCircle[Subscript[A, First[#2]],Subscript[B, First[#2]]],Subscript[B, First[#2]]},#1}]&,Partition[#1,3],1],1])&@@@CoefficientRules[form,Flatten@Transpose@{As,ABs,Bs}])/.sc_SmallCircle/;Length[sc]<2:>Times@@sc
]


atoleft[ex__]:=Module[{inds,Apos,Bnum,rule,form,As,Bs},
inds=DeleteDuplicates[{ex}[[All,2]]];
As=Subscript[A, #]&/@inds;Bs=Subscript[B, #]&/@inds;
Apos=ConstantArray[{},Length@inds];Bnum=ConstantArray[0,Length@inds];
rule=Flatten[MapIndexed[{Subscript[A, #]:>AppendTo[Apos[[First@#2]],Bnum[[First@#2]]],Subscript[B, #]:>++Bnum[[First@#2]]}&,inds]];
Replace[{ex},rule,{1}];
form=Times@@Table[Sum[Plus@@(Times@@(Range[0,i-1]-#)&/@Subsets[Apos[[n]],{i}])*Times@@Join[ConstantArray[As[[n]],Length@Apos[[n]]-i],ConstantArray[Bs[[n]],Bnum[[n]]-i]],{i,0,Min[Length@Apos[[n]],Bnum[[n]]]}],{n,Length@Apos}];
Plus@@((#2*Sort[SmallCircle@@DeleteCases[Flatten@MapIndexed[MapThread[ConstantArray,{{As[[First@#2]],Bs[[First@#2]]},#1}]&,Partition[#1,2],1],1]])&@@@CoefficientRules[form,Flatten@Transpose@{As,Bs}])/.sc_SmallCircle/;Length[sc]<2:>Times@@sc
]


ablisttoexpr[{ex___},jj_,indices_]:=Module[{sh,arg,rule,n=Length@indices},
sh=ConstantArray[{},n];arg=ConstantArray[0,n];
Replace[{ex},{Subscript[A, i_]:>AppendTo[sh[[i]],arg[[i]]++],Subscript[B, i_]:>--arg[[i]]},{1}];
Times@@Times@@@(indices+#1)(jj[##]&@@(#2+indices))&@@{sh,arg}
]


TildeConjugate::usage="TildeConjugate[\!\(\*
StyleBox[\"ABoperator\", \"TI\"]\),\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives \[CapitalGamma][(L+1)d/2-\[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)-b]\[SmallCircle]\!\(\*
StyleBox[\"ABoperator\", \"TI\"]\)\[SmallCircle](\[CapitalGamma][(L+1)d/2-\[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)]\!\(\*SuperscriptBox[\()\), \(-1\)]\), where L is loop number of \!\(\*
StyleBox[\"basis\", \"TI\"]\), \*
StyleBox[\(\[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)\)]\!\(\*
StyleBox[\" \", \"TI\"]\)is the sum over all Ds of the \!\(\*
StyleBox[\"basis\", \"TI\"]\), and b is maximal integer number, for which the result is polynomial in \!\(\*
StyleBox[\"A\", \"TI\"]\) and \!\(\*
StyleBox[\"B\", \"TI\"]\).";


TildeConjugate[expr_List,nm_]:=TildeConjugate[#,nm]&/@expr;
TildeConjugate[expr_,nm_]:=Module[{a,b,t,ph},
t={Subtract@@#1,#2}&@@@CoefficientRules[LFDistribute[expr/.{o:Subscript[A, _]:>a o,o:Subscript[B, _]:>b o},SmallCircle],{a,b}];
b=Min[First/@t];a=(Length@LMs@nm+1)*MetricTensor[]/2-Sum[SmallCircle[Subscript[A, i],Subscript[B, i]],{i,Length@Ds@nm}];
ph[o_,k_Integer?NonNegative]:=SmallCircle@@(o-1+Range[k]);
LFDistribute[Plus@@(SmallCircle[#2,ph[a,#1-b]]&@@@t),SmallCircle]
]


InverseTildeConjugate::usage="TildeConjugate[\!\(\*
StyleBox[\"ABoperator\", \"TI\"]\),\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives (\[CapitalGamma][(L+1)d/2-\[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)-b]\!\(\*SuperscriptBox[\()\), \(-1\)]\)\[SmallCircle]\!\(\*
StyleBox[\"ABoperator\", \"TI\"]\)\[SmallCircle](\[CapitalGamma][(L+1)d/2-\[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)]), where L is loop number of \!\(\*
StyleBox[\"basis\", \"TI\"]\), \[CapitalSigma]\!\(\*
StyleBox[\"AB\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)is the sum over all Ds of the \!\(\*
StyleBox[\"basis\", \"TI\"]\), and b is minimal integer number, for which the result is polynomial in \!\(\*
StyleBox[\"A\", \"TI\"]\) and \!\(\*
StyleBox[\"B\", \"TI\"]\).\nNote that InverseTildeConjugate is not literally inverse of TildeConjugate, but that, multiplied from the left by inversible operator.";


InverseTildeConjugate[expr_List,nm_]:=InverseTildeConjugate[#,nm]&/@expr;
InverseTildeConjugate[expr_,nm_]:=Module[{a,b,t,ph},
t={Subtract@@#1,#2}&@@@CoefficientRules[LFDistribute[expr/.{o:Subscript[A, _]:>a o,o:Subscript[B, _]:>b o},SmallCircle],{a,b}];
b=Max[First/@t];a=(Length@LMs@nm+1)*MetricTensor[]/2-Sum[SmallCircle[Subscript[A, i],Subscript[B, i]],{i,Length@Ds@nm}];
ph[o_,k_Integer?NonNegative]:=SmallCircle@@(o-1+Range[k]);
LFDistribute[Plus@@(SmallCircle[#2,ph[a+#1-b,b-#1]]&@@@t),SmallCircle]
]


ABIBP::usage="ABIBP[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the AB-form of the IBP identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
ABLI::usage="ABLI[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the AB-form of the LI identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
ABIBPLI::usage="ABIBPLI[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the AB-form of the IBP&LI identities of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";


ABIBP[nm_]/;ValueQ[IBP@nm]:=(ABIBP[nm]^=ToAB[IBP@nm,nm]);
ABLI[nm_]/;ValueQ[LI@nm]:=(ABLI[nm]^=ToAB[LI@nm,nm]);
ABIBPLI[nm_]/;ValueQ[ABIBP@nm]&&ValueQ[ABLI@nm]:=Join[ABIBP@nm,ABLI@nm];


SubstituteAlways::usage="SubstituteAlways\[Rule]True is an option for Solvej[\!\(\*
StyleBox[\"equation\", \"TI\"]\),\!\(\*
StyleBox[\"database\", \"TI\"]\)] which forces exhaustive substitutions.";
SimplifyAlways::usage="SimplifyAlways\[Rule]True|False is an option for Solvej[\!\(\*
StyleBox[\"equation\", \"TI\"]\),\[Ellipsis]] which determines whether a singe terms  should be simplified.";
SimplifyFunction::usage="SimplifyFunction\[Rule]Function[\[Ellipsis]] is an option for Solvej[\!\(\*
StyleBox[\"equation\", \"TI\"]\),\[Ellipsis]] which determines the function to be used for the simplification of the terms.";
CheckZeroAlways::usage="CheckZeroAlways\[Rule]True|False is an option for Solvej[\!\(\*
StyleBox[\"equation\", \"TI\"]\),\[Ellipsis]] which determines whether a singe leading term  should be simplified.";
CheckZeroFunction::usage="CheckZeroFunction\[Rule]Function[\[Ellipsis]] is an option for Solvej[\!\(\*
StyleBox[\"equation\", \"TI\"]\),\[Ellipsis]] which determines the function to be used for the simplification of a leading term.";



Solvej::usage="Solvej[\!\(\*
StyleBox[\"eq\", \"TI\"]\)] solves equation \!\(\*
StyleBox[\"eq\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\) with respect to the most complex j[\[Ellipsis]],\n\
Solvej[\!\(\*
StyleBox[\"eq\", \"TI\"]\),\!\(\*
StyleBox[\"database\", \"TI\"]\)] first applies rules \!\(\*
StyleBox[\"database\", \"TI\"]\) to \!\(\*
StyleBox[\"eq\", \"TI\"]\) and then solves it with respect to the most complex j[\[Ellipsis]]. The new rule is appended to \!\(\*
StyleBox[\"database\", \"TI\"]\).\n\
Valid options include:\n\
    SimplifyAlways\[Rule]True|False:True determines whether singe terms should be simplified,\n\
    SimplifyFunction\[Rule]Function[\[Ellipsis]]:Factor1 function used for the simplification,\n\
    CheckZeroAlways\[Rule]True|False:True determines whether a singe leading term  should be simplified,\n\
    CheckZeroFunction\[Rule]Function[\[Ellipsis]]:Factor1 function used for the simplification of a leading term,\n\
    SubstituteAlways\[Rule]True|False:False determines whether a new rule should be applied to database.";
Solvej::freeterm="Free term detected: `1`";
Solvej::nosol="Equation `1`==0 has no solutions.";


SetAttributes[Solvej,{HoldRest}];
Options[Solvej]={SubstituteAlways->False,SimplifyAlways->True,SimplifyFunction->Factor1,CheckZeroAlways->True,CheckZeroFunction->Factor1};


Solvej[eq_,OptionsPattern[]]:=Module[{
sf,czf,sa,cza,czf1,sf1,
fterm,lst,j1,j2,c,fterm1},
{sf,czf,sa,cza}={OptionValue[SimplifyFunction],OptionValue[CheckZeroFunction],OptionValue[SimplifyAlways],OptionValue[CheckZeroAlways]};
czf1=If[cza,("czf"[Plus@@#]&),(If[Length@#>1,"czf"[Plus@@#],Plus@@#]&)]/.{"czf"->czf};sf1=If[sa,("sf"[Plus@@#]&),(If[Length@#>1,"sf"[Plus@@#],Plus@@#]&)]/.{"sf"->sf};
{fterm,lst}=Reap[csow[eq/.Times->times,1],_,{#1,#2}&]/.times->Times;
fterm=sf[fterm];
While[True,
If[lst==={},If[fterm=!=0,Message[Solvej::nosol,fterm]];Return[False->False]];
lst=MapAt[(c=czf1[#])&,RotateLeft[lst,HighjIndex[First/@lst]],{-1,-1}];
 If[c===0,lst=Most@lst,Break[]];
];
j1=First@Last@lst;
If[fterm=!=0,Message[Solvej::freeterm,fterm]];
(*Modified 01.12.2016*)
j1:>Evaluate[-(c)^(-1)*(Plus@@Times@@@({#1,sf1[#2]}&@@@Most[lst])+fterm)](*/Modified 01.12.2016*)];


Solvej[eq_,db_,opts:OptionsPattern[]]:=
Module[{
j1,j2,c,lst,fterm,fterm1,l1,sr,f,jdb,rule,
sf,czf,sa,cza,
czf1,sf1
},
{sf,czf,sa,cza}={OptionValue[SimplifyFunction],OptionValue[CheckZeroFunction],OptionValue[SimplifyAlways],OptionValue[CheckZeroAlways]};
czf1=If[cza,("czf"[Plus@@#]&),(If[Length@#>1,"czf"[Plus@@#],Plus@@#]&)]/.{"czf"->czf};
sf1=If[sa,("sf"[Plus@@#]&),(If[Length@#>1,"sf"[Plus@@#],Plus@@#]&)]/.{"sf"->sf};
(*Global`deb1="dispatch";*)
jdb=Dispatch[db];
(*Global`deb1="";*)
If[OptionValue[SubstituteAlways],
rule=Solvej[eq//.jdb,opts];
If[rule===$Failed,Return[False]];
sr=(#1:>(f:=(f=Identity;Collectj[#,SimplifyAlways->sa,SimplifyFunction->sf])&;#2))&@@rule;f=Identity;
db=Prepend[(r=#/.sr;f[r])&/@db,rule];True,
(*SubstituteAlways=False*)
(*j1:=First@Last@lst;*)
{fterm,lst}=Reap[csow[eq/.Times->times,1],_,{#1,#2}&]/.times->Times;fterm=sf[fterm];
While[True,
If[lst==={},If[fterm=!=0,Message[Solvej::nosol,fterm]];Return[False]];
lst=MapAt[(c=czf1[#])&,RotateLeft[lst,HighjIndex[First/@lst]],{-1,-1}];
 If[c===0,lst=Most@lst;Continue[]];
j1=First@Last@lst;
If[j1===(j2=Replace[j1,jdb]),Break[]];
{fterm1,lst}=Reap[Sow@@@Reverse/@Most[lst/.Times->times];csow[j2/.Times->times,c],_,{#1,Flatten@#2}&]/.times->Times;fterm=sf[fterm+fterm1];
];
If[fterm=!=0,Message[Solvej::freeterm,fterm]];
PrependTo[db,(*Modified 01.12.2016*)j1:>Evaluate[(Plus@@(-(c)^(-1)*Times@@@({#1,sf1[#2]}&@@@Most[lst]))-(c)^(-1)*fterm)](*/Modified 01.12.2016*)];
True
]
]


LiteRed`SolvejTag;


SolvejTag::usage="SolvejTag[\!\(\*
StyleBox[\"eq\", \"TI\"]\),\!\(\*
StyleBox[\"tag\", \"TI\"]\),\!\(\*
StyleBox[\"database\", \"TI\"]\)] first applies rules \!\(\*
StyleBox[\"database\", \"TI\"]\) to \!\(\*
StyleBox[\"eq\", \"TI\"]\) and then solves it with respect to the most complex j[\[Ellipsis]]. The new rule is appended to \!\(\*
StyleBox[\"database\", \"TI\"]\). All entries in the database are tagged, i.e. are pairs j[\[Ellipsis]]\[RuleDelayed]{\!\(\*
StyleBox[\"simpler\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)\!\(\*
StyleBox[\"integrals\", \"TI\"]\),{\!\(\*
StyleBox[\"tag1\", \"TI\"]\),\!\(\*
StyleBox[\"tag2\", \"TI\"]\),\[Ellipsis]}}.\n\
Valid options include:\n\
    SimplifyAlways\[Rule]True|False:True determines whether singe terms should be simplified,\n\
    SimplifyFunction\[Rule]Function[\[Ellipsis]]:Factor1 function used for the simplification,\n\
    CheckZeroAlways\[Rule]True|False:True determines whether a singe leading term  should be simplified,\n\
    CheckZeroFunction\[Rule]Function[\[Ellipsis]]:Factor1 function used for the simplification of a leading term,\n\
    SubstituteAlways\[Rule]True|False:False determines whether a new rule should be applied to database.";
SolvejTag::freeterm="Free term detected: `1`";
SolvejTag::nosol="Equation `1`==0 has no solutions.";


SetAttributes[SolvejTag,{HoldRest}];
Options[SolvejTag]={SimplifyAlways->True,SimplifyFunction->Factor1,CheckZeroAlways->True,CheckZeroFunction->Factor1};


SolvejTag[eq_,tag_,db_,opts:OptionsPattern[]]:=
Module[{
j1,j2,c,lst,fterm,fterm1,l1,sr,f,jdb,rule,
sf,czf,sa,cza,czf1,sf1,
tags={tag},tgs
},
{sf,czf,sa,cza}={OptionValue[SimplifyFunction],OptionValue[CheckZeroFunction],OptionValue[SimplifyAlways],OptionValue[CheckZeroAlways]};
czf1=If[cza,("czf"[Plus@@#]&),(If[Length@#>1,"czf"[Plus@@#],Plus@@#]&)]/.{"czf"->czf};sf1=If[sa,("sf"[Plus@@#]&),(If[Length@#>1,"sf"[Plus@@#],Plus@@#]&)]/.{"sf"->sf};
jdb=Dispatch[db];
{fterm,lst}=Reap[csow[eq/.Times->times,1],_,{#1,#2}&]/.times->Times;
fterm=sf[fterm];
While[True,
If[lst==={},If[fterm=!=0,Message[SolvejTag::nosol,fterm]];Return[False]];
lst=MapAt[(c=czf1[#])&,RotateLeft[lst,HighjIndex[First/@lst]],{-1,-1}];
 If[c===0,lst=Most@lst;Continue[]];
j1=First@Last@lst;
{j2,tgs}=Replace[Replace[j1,jdb],j1->{j1,{}}];
tags=DeleteDuplicates@Join[tgs,tags];(*adding tags*)
If[j1===j2,Break[]];
{fterm1,lst}=Reap[Sow@@@Reverse/@Most[lst/.Times->times];csow[j2/.Times->times,c],_,{#1,Flatten@#2}&]/.times->Times;fterm=sf[fterm+fterm1];
];
If[fterm=!=0,Message[Solvej::freeterm,fterm]];
PrependTo[db,(*Modified 01.12.2016*)j1:>Evaluate[{(Plus@@(-(c)^(-1)*Times@@@({#1,sf1[#2]}&@@@Most[lst]))-(c)^(-1)*fterm),tags}](*/Modified 01.12.2016*)];True
]


SolvejSector::usage="SolvejSector[\!\(\*
StyleBox[\"sector\", \"TI\"]\):js[\[Ellipsis]]] tries to find symbolic rules for the reduction of the integrals in the \!\(\*
StyleBox[\"sector\", \"TI\"]\).\nOptions:\n\
    NamingFunction\[Rule]Function[\[Ellipsis]]|Automatic:Automatic, see ?NamingFunction;\n\
    Depth\[Rule]_Integer:2, the Depth of the heuristic search. If the search did not succeeded in reducing the sector to a finite number of integrals, search depth is increased automatically;\n\
    NMIs\[Rule]n:0, expected number of master integrals. If the number of the integrals left is less or equal to n, the program terminates assuming those integrals are masters, which may save some time.\n\
    Apply\[Rule]True|False:True determines whether to apply found rule at the last stage.\n\
    SR\[Rule]False|True:True determines whether the symmetry relations should be used on the last step;\n\
    DiskSave\[Rule]True|False|\!\(\*
StyleBox[\"directory\", \"TI\"]\):False determines whether to save the found rules on the disk.";
SolvejSector::leak="Discrepancy detected. Reduction is not full: `1`.";
NMIs::usage="NMIs\[Rule]n is an option for SolvejSector, which determines the minimal number of masters in the sector.";
RRs::usage="RRs\[Rule]{IBP,LI} is an option for SolvejSector which determines which recurrence relations to use. Note that symmetry relations are automatically used for numeric indices.";


Options[SolvejSector]={NamingFunction->Automatic,
Depth->2(*\:043c\:0438\:043d\:0438\:043c\:0430\:043b\:044c\:043d\:0430\:044f \:0433\:043b\:0443\:0431\:0438\:043d\:0430 \:043f\:043e\:0438\:0441\:043a\:0430*),
MaxDepth->\[Infinity](*\:041c\:0430\:043a\:0441\:0438\:043c\:0430\:043b\:044c\:043d\:0430\:044f \:0433\:043b\:0443\:0431\:0438\:043d\:0430 \:043f\:043e\:0438\:0441\:043a\:0430*),
RRs->Automatic,(*\:041a\:0430\:043a\:0438\:0435 \:0440\:0435\:043a\:0443\:0440\:0440\:0435\:043d\:0442\:043d\:044b\:0435 \:0441\:043e\:043e\:0442\:043d\:043e\:0448\:0435\:043d\:0438\:044f \:0438\:0441\:043f\:043e\:043b\:044c\:0437\:043e\:0432\:0430\:0442\:044c? Automatic \:0438\:043b\:0438 \:0444\:0443\:043d\:043a\:0446\:0438\:044f*)
SR->True,(*\:0418\:0441\:043f\:043e\:043b\:044c\:0437\:043e\:0432\:0430\:0442\:044c \:0441\:043e\:043e\:0442\:043d\:043e\:0448\:0435\:043d\:0438\:044f \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0438?*)
NMIs->-1(*\:041e\:0436\:0438\:0434\:0430\:0435\:043c\:043e\:0435 \:0447\:0438\:0441\:043b\:043e \:043c\:0430\:0441\:0442\:0435\:0440-\:0438\:043d\:0442\:0435\:0433\:0440\:0430\:043b\:043e\:0432*),
DiskSave->True(*\:0421\:043e\:0445\:0440\:0430\:043d\:044f\:0442\:044c \:043d\:0430\:0439\:0434\:0435\:043d\:043d\:044b\:0435 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:043d\:0430 \:0434\:0438\:0441\:043a\:0435?*),
DiskRecover->False(*\:0412\:043e\:0441\:0441\:0442\:0430\:043d\:0430\:0432\:043b\:0438\:0432\:0430\:0442\:044c \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:0441 \:0434\:0438\:0441\:043a\:0430?*),
Replace->True(*\:0417\:0430\:043c\:0435\:043d\:044f\:0442\:044c \:0444\:0430\:0439\:043b \:0441 \:043f\:0440\:0430\:0432\:0438\:043b\:0430\:043c\:0438 \:043d\:0430 \:0434\:0438\:0441\:043a\:0435?*),
TimeConstrained->False,
CheckZeroFunction->Factor1,
CheckZeroAlways->True,
SimplifyFunction->Factor1,
SimplifyAlways->True,
jGraph->False,
GeneratedCell->True,
UseFermat->False
};
SolvejSector::parse="Could not parse `1`.";
SolvejSector::dim="Please, set dimension to be a symbol. Use SetDim[\[Ellipsis]]. Aborting...";


SolvejSector[nm_Symbol,opts:OptionsPattern[]]:=
Module[{res},
CurrentState[nm,SolvejSector]=False;
res=SolvejSector[UniqueSectors[nm],opts];
If[MatchQ[res,{__Integer?Positive}],CurrentState[nm,SolvejSector]=True];
res
]
SolvejSector[sects_List,opts:OptionsPattern[]]:=SolvejSector[#,opts]&/@sects


SolvejSector[jsect_js,OptionsPattern[]]:=Module[{
file=StringReplace[ToString@jsect,"js"->"jRules"],
nm=First@jsect,
corner=Rest[List@@jsect],
(*(*Deleted 01.03.2018*)List$signs,(*/Deleted 01.03.2018*)*)
indices,
(*(*Deleted 25.03.2018*)sectcond,(*/Deleted 25.03.2018*)*)constr,
nds=Length@jsect-1,
ps,
reserved=False,
indicnop=0,
indicnopToGo=0,
indicoutput={},
indicpb=0,
moni,
misFound={},
numeric,
noRules={{}},
gatherRules,
rulesFound={},
parameters,
eqs,neqs,sf,
dbase(*jRulesDB*),
ids,case,rules2,startp,
pat1,except,usefer,
ptrnrule,jRules1,jRulesF,pos,searchDepth,useSR,indicnr,fr,disksave,diskreco,onmis,tc,tcf,sjopts,whenBad,smartReduce,cf,fromRules,expandRules,found,depth,maxDepth},
CheckAbort[
(* Processing options *)
{indices,searchDepth,maxDepth,useSR,disksave,diskreco,onmis,tc,sf,usefer}={Replace[OptionValue[NamingFunction],Automatic:>$NamingFunction][nds],OptionValue@Depth,OptionValue@MaxDepth,OptionValue@SR,Replace[OptionValue@DiskSave,True:>BasisDirectory[nm]],Replace[OptionValue@DiskRecover,{Automatic|True->True,_->False}],OptionValue@NMIs,OptionValue@TimeConstrained,OptionValue@SimplifyFunction,OptionValue@UseFermat};
Declare[Evaluate@indices,Number];
ps=Replace[PowerShifts[nm],Except[0]->1,{1}];
tcf=If[Not@TrueQ@Not@tc,TimeConstrained,#&];sjopts=FilterRules[(#->OptionValue[SolvejSector,#])&/@First/@Options[SolvejSector],Options[Solvej]];
ids=Replace[Flatten@{OptionValue@RRs/.Automatic->{IBP[nm],LI[nm]}},x:IBP|LI:>x[nm],{1}];
ids=Join@@(Through[ids@@indices]);
(*/ Processing options *)
(*Recovering from disk*)
constr=MapThread[Replace[#1,{1->#2>=1,0->#2<=0}]&,{corner,indices}];
(*(*Deleted 25.03.2018*)sectcond=Inner[#2[#1]&,indices,(corner/.{1\[Rule](GreaterEqual[#,1]&),0\[Rule](LessEqual[#,0]&)}),And];(*/Deleted 25.03.2018*)*)ptrnrule=Inner[#1->Pattern[#1,_]?#2&,indices,(corner/.{1->Positive,0->NonPositive}),List];
(*(*Deleted 13.12.2016*)sectp=js[nm,##]&@@Replace[Transpose[{PowerShifts[nm],corner}],{{0,x_}\[RuleDelayed]x,_\[RuleDelayed]0|1},{1}](*/Deleted 13.12.2016*)*)
If[Not@TrueQ@Not@disksave&&diskreco&&FileExistsQ[disksave<>"/"<>file],jRulesF=Get[disksave<>"/"<>file];If[jRulesF==="reserved",LiteRedPrint["The sector ",jsect," is likely being solved by another kernel. Execute SolvejSector["<>ToString[jsect]<>",DiskRecover\[Rule]True] later to update MIs["<>ToString[nm]<>"]."];Return[Indeterminate],misFound=j[nm,##]&@@indices/.#&/@{ToRules[LogicalExpand@Reduce[Not[Or@@jRulesF[[All,1,2]]]&&And@@constr(*(*Deleted 25.03.2018*)sectcond(*/Deleted 25.03.2018*)*),Integers]]};If[!FreeQ[misFound,Alternatives@@indices],Message[SolvejSector::leak,misFound]]];
If[disksave===BasisDirectory[nm],ToExpression[ToString[nm]<>"/:"<>file<>":=Get[BasisDirectory["<>ToString[nm]<>"]<>\"/"<>file<>"\"]"],ToExpression[ToString[nm]<>"/:"<>file<>":=Get[\""<>disksave<>"/"<>file<>"\"]"]];LiteRedPrint["Sector ",jsect," is recovered from file"];,
(**)
onmis=Replace[onmis,{Automatic:>If[Contexts["Mint`"]=!={},If[IntegerQ[#],#,0]&@Symbol["Mint`CountMIs"][jsect,Symmetric->useSR],0],f_Function:>f@@jsect}];
tcf[LiteRedPrint["Sector ",jsect];If[Not[TrueQ@Not@disksave||FileExistsQ[disksave<>"/"<>file]],If[!DirectoryQ[disksave],CreateDirectory[disksave];Message[DiskSave::dir,disksave]];Put["reserved",disksave<>"/"<>file];reserved=True];(*ptrnrule\[LongDash]\:0437\:0430\:043c\:0435\:043d\:0430 indices \:043d\:0430 \:043f\:0430\:0442\:0442\:0435\:0440\:043d\:044b*)
gatherRules[x_]:=Flatten[SortBy[Sort[#,(Last@#1)>(Last@#2)&]&/@Gather[{#,j[nm,##]&@@indices/.#}&/@x,MatchQ[Expand[List@@Last@#1-List@@Last@#2],{__Integer}]&(*Gather contiguous*)],{
Length@First@First@#,(*# of fixed parameters*)
Count[Last@First@#,_Integer],(*# of numeric indices*)
Flatten@Position[Take[jComplexity[Last@First@#],-nds],Except[_Integer],{1}]
(*position of symbolic indices*)
}&][[All,All,1]],1];
(*\:0413\:043e\:0442\:043e\:0432\:0438\:043c\:0441\:044f \:043a \:0440\:0435\:0448\:0435\:043d\:0438\:044e \:0443\:0440\:0430\:0432\:043d\:0435\:043d\:0438\:0439 \:0432 \:0434\:0430\:043d\:043d\:043e\:043c \:0441\:0435\:043a\:0442\:043e\:0440\:0435*)
jSector[nm]=jsect;jRulesF={};
parameters=Complement[Variables[Last@Reap[Collect[ids,_j,Sow]]],indices];
If[TrueQ[OptionValue[jGraph]],AppendTo[indicoutput,LiteRedPrintTemporary[GraphPlot[jGraph[jsect],ImageSize->Tiny]]]];
AppendTo[indicoutput,LiteRedPrintTemporary["Parameters "<>ToString[parameters]<>" are assumed to be independent."]];
If[onmis>=0,AppendTo[indicoutput,LiteRedPrintTemporary["Expecting "<>ToString[onmis]<>" masters."]]];
ids=Function@@{sharpen[ids]/.MapIndexed[#->Slot@@#2&,indices]};
(*whenBad*)whenBad[expr_]:=Module[{jl=Cases[CollectjList[expr],{tt_j,_}(*Added 31.05.2016*)(*/;!jSector[tt]<jsect(*
Definitely erroneous attempt: in particular dropped terms may have zeros in the denominators*)*)(*/Added 31.05.2016*)],dconds,nconds},dconds=LogicalExpand[Or@@(And@@Thread[0==(Last/@CoefficientRules[#,parameters])(*(*Deleted 05.03.2018*)Flatten[{CoefficientList[#,parameters]}](*/Deleted 05.03.2018*)*)]&/@Union@@((First/@FactorList[#])&/@Denominator/@Last/@jl))];nconds={#2,smartReduce[Or@@Thread[Pick[Rest[List@@#1],Rest[List@@jsect],0]>=1]]}&@@@jl;If[MemberQ[nconds,{_,True}],Return[True]];nconds=Or@@Flatten@Cases[nconds,{b_,a:Except[False]}:>Cases[Replace[{a},Or->Sequence,{2},Heads->True],x_/;0=!=Expand[Numerator[b]/.ToRules[x]]]];(*LogicalExpand@*)smartReduce[LogicalExpand[dconds||nconds]]];(*/whenBad*)
(*smartReduce*)
smartReduce[expr_]:=Module[{exprl=Replace[{expr},Or->Sequence,{2},Heads->True],exprl1,t,v,l},
exprl1=(t=Replace[{#},And->Sequence,{2},Heads->True];t=And@@(Function[l,cf[LogicalExpand@TimeConstrained[(*\[LeftArrow]added 25.12.2012*)Reduce[#,l[[1,2]],Integers],300,#]&[And@@l[[All,1]]&&(And@@Select[(*(*Deleted 25.03.2018*)sectcond(*/Deleted 25.03.2018*)*)constr,MemberQ[l[[1,2]],First@#]&])]]]/@GatherBy[Transpose[{t,FixedPoint[Function[l,Union@@Cases[l,x_/;{}!=Intersection[#,x]]&/@l],Cases[indices,n_/;Not[FreeQ[#,n]]]&/@t]}],Last]))&/@exprl;
Or@@exprl1];cf[x_Or]:=cf/@x;cf[x_]:=Module[{Cs=Union@Cases[{x},_C,\[Infinity]](*\:0441\:0433\:0435\:043d\:0435\:0440\:0438\:0440\:043e\:0432\:0430\:043d\:043d\:044b\:0435 Reduce \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*),l=Replace[{x},And->Sequence,{2},Heads->True],c,dens=Alternatives@@Pick[indices,corner,1],nums=Alternatives@@Pick[indices,corner,0]},If[MatchQ[x,True|False],Return[x]];l=Replace[l,(*\:0417\:0430\:043c\:0435\:043d\:044f\:0435\:043c \:043d\:0430 \:043a\:0430\:043d\:043e\:043d\:0438\:0447\:0435\:0441\:043a\:0443\:044e \:0444\:043e\:0440\:043c\:0443*)HoldPattern[y_Alternatives\[Element]Integers]:>Sequence@@((#\[Element]Integers)&/@List@@y),{1}];If[Cs=!={},(*\:0415\:0441\:0442\:044c \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*)(*\:041f\:0440\:043e\:0432\:0435\:0440\:044f\:0435\:043c,\:0447\:0442\:043e Reduce \:0441\:0433\:0435\:043d\:0435\:0440\:0438\:043b \:0442\:043e\:043b\:044c\:043a\:043e \:0446\:0435\:043b\:044b\:0435 \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*)If[And@@(MemberQ[l,HoldPattern[#\[Element]Integers]]&/@Cs),l=DeleteCases[l,Alternatives@@Cs\[Element]Integers],Return[True]];c=Cases[l,(y_>=#)|(y_<=#)|(#<=y_)|(#>=y_)]&/@Cs;If[Not[And@@(Length[#]===1&/@c)],Return[True]];c=Flatten@c;l=Complement[l,c];c=(*not clear*)Cases[l,t:((z:#+1)==(y:dens)|(y:dens)==(z:#+1)|(z:-#)==(y:nums)|(y:nums)==(z:-#)):>{y,t}]&/@MapThread[Replace[#1,{y_>=#2|#2<=y_:>Expand[y-#2],y_<=#2|#2>=y_:>Expand[#2-y]}]&,{c,Cs}];If[MemberQ[c,{}],Return[True]];c=Last@Last@SortBy[#,Position[indices,First@#1,1]&]&/@c;l=Complement[l,c];c=ExpandAll[Flatten[Solve[c,Cs]]],c={}];(*remove obvious restrictions*)l=DeleteCases[l,Alternatives@@indices\[Element]Integers|dens>=1|1<=dens|nums<=0|0>=nums];(*only equalities allowed*)If[!MatchQ[l,{(Alternatives@@indices==_|_==Alternatives@@indices)...}],Return[True]];l=ExpandAll[Replace[l,(y_==(z:Alternatives@@indices))|((z:Alternatives@@indices)==y_):>z==(y/.c),{1}]];And@@l];(*/smartReduce*)(*fromRules*)fromRules[x_]:=Or@@And@@@(x/.Rule->Equal);(*/fromRules*)(*expandRules*)expandRules[x_]:=(Pick[#1,Table[!MemberQ[Delete[#2,i]/.#1[[i]],True],{i,Length[#1]}]]&[#,Apply[And,#/.Rule->Equal,{1}]])&[Union[Sort/@x]];(*/expandRules*)(* ********************************************************************************************************)
noRules={{}};
jRulesF={};
indicnr=Length[jRulesF];
(*LOOP OVER noRules*)
If[$LiteRedMonitor,moni=PrintTemporary[TableForm[{Overlay[{ProgressIndicator[Dynamic[indicpb],{0,nds+1/2}],Dynamic[ToString[indicnop]<>"\[Rule]"<>ToString[indicnopToGo]]},Alignment->Center],Dynamic[ToString[indicnr]<>" point: "<>ToString[startp]]}]]];
While[
noRules=!={},
(*Consider first case*)
case=First@noRules;(*case will be a list*)
noRules=Rest@noRules;
startp=indices/.case;(*startp will be a list*)
indicpb=Length@case;(*proof this*)
numeric=FreeQ[startp,Alternatives@@indices];
found=False;
If[!numeric||Length[misFound]+Length[noRules]>=onmis,(* check if the case falls into the more general *)If[(fr=Select[rulesFound,TrueQ[First[#]/.case]&&Not[TrueQ[Simplify[Last[#]/.case]]]&,1])=!={},(* better sorting desired *)noRules=gatherRules[expandRules[{ToRules@smartReduce[LogicalExpand[fromRules[noRules]||fromRules[{case}]&&fr[[1,2]]]]}]];Continue[]];
indicnr++;indicnop=0;
except=Alternatives[];
pat1=(j[nm,##]&@@(Pattern[#,Blank[]]&/@indices))/;Evaluate[fromRules[{case}]];
pos=Flatten[Position[indices,Alternatives@@Complement[indices,First/@case],1]];
(*dbase={0\[Rule]0};*)
If[usefer,finitdb,initdb][dbase,jsect,Join[Variables[startp],parameters]];

depth=0;
While[depth<=searchDepth,
(*Construct equations*)
eqs=(*(*Deleted 02.03.2018*)DeleteDuplicates@DeleteCases[(*/Deleted 02.03.2018*)*)Flatten[(If[useSR&&numeric,Join[ids@@#,SR[nm]@@#]/.ZerojRule[nm],ids@@#])&/@(preparepoints[jsect,startp,depth])](*(*Deleted 02.03.2018*),0](*/Deleted 02.03.2018*)*);
(*/Construct equations*)
indicnopToGo=indicnop+Length[eqs];
If[usefer,fsubmiteqs,submiteqs][eqs,dbase,jsect,startp];
While[0!=(neqs=If[usefer,fsolveeqs,solveeqs][Except[except,pat1],dbase,fr,indicnop](*neqs=solveeqs[eqs,pat1,indicnop,dbase,jRules1]*)),
LiteRedMonitor[
(*PrintTemporary["displacement: ",Factor[Rest[List@@First[jRules1]]-startp]];*)
jRules1=(#/.MapThread[#1->Expand[2#1-#2]&,{indices[[pos]],Rest[List@@First[#]][[pos]]}])&[fr];
(*Patternize the left sides of the rules and form a list of rules for the integrals to consider later*)
{jRules1,{{rules2}}}=Reap[(*Modified 01.12.2016*)
(j[nm,##]&@@indices/.ptrnrule)/;Evaluate[fromRules[{case}]&&Not[Sow[whenBad[#[[2]]]]]]:>Evaluate[If[Head[#[[2]]]===List,{Collectj[#[[2,1]],sf],#[[2,2]]},Collectj[#[[2]],sf]]](*\[LongLeftArrow] this should also work if the second element is a pair*)(*/Modified 01.12.2016*)&@jRules1];

,"Constructing rule...",1];
If[rules2=!=True,(*Found the rule!*)
AppendTo[rulesFound,{fromRules[{case}],rules2}];
(*TODO: better sorting*)noRules=gatherRules[expandRules[{ToRules@smartReduce[LogicalExpand[fromRules[noRules]||fromRules[{case}]&&rules2]]}]];AppendTo[jRulesF,jRules1];found=True;
If[usefer,fcleandb,cleandb][dbase];
(*Modified 01.03.2018*)(*depth=searchDepth+1;*)Break[](*/Modified 01.03.2018*),
PutAppend[jRules1,BasisDirectory[nm]<>StringReplace[ToString[jsect],"js["->"/jBadRules["]];
LiteRedPrint[Style["Was not able to construct applicability condition. Offending rule is saved in "<>StringReplace[ToString[jsect],"js["->"jBadRules["],Tiny],"\n",Style["Excluding ",Tiny],Style[fr[[1]],Tiny]];
except=except|fr[[1]];
Continue[]
]
];
If[found,Break[]];
If[++depth>searchDepth&&depth<=maxDepth&&!numeric,searchDepth=depth;AppendTo[indicoutput,LiteRedPrintTemporary["Increasing search depth to "<>ToString[searchDepth]]]]
];
];
If[!found,
AppendTo[indicoutput,LiteRedPrintTemporary["Found master integral "<>ToString[startp]]];AppendTo[misFound,j[nm,##]&@@startp];
]
];
If[$LiteRedMonitor,NotebookDelete[moni]];
,tc,If[!numeric,
If[reserved,DeleteFile[disksave<>"/"<>file]];Return[$Failed],
misFound=j[nm,##]&@@indices/.#&/@{ToRules[LogicalExpand@Reduce[Not[Or@@jRulesF[[All,1,2]]]&&And@@constr,Integers]]};If[!FreeQ[misFound,Alternatives@@indices],Message[SolvejSector::leak,misFound]]]];
If[TrueQ[Not[disksave]],(#1/:jRules[##]=jRulesF),If[!DirectoryQ[disksave],CreateDirectory[disksave];Message[DiskSave::dir,disksave]];If[!FileExistsQ[disksave<>"/"<>file]||OptionValue[Replace],If[!reserved&&FileExistsQ[disksave<>"/"<>file],Message[DiskSave::overwrite,disksave<>"/"<>file]];
Put[Unevaluated[Last[{#1,#2}]],#3]&[jsOrder@@jsect,jRulesF,disksave<>"/"<>file];
If[disksave===BasisDirectory[nm],ToExpression[ToString[nm]<>"/:"<>file<>":=Get[BasisDirectory["<>ToString[nm]<>"]<>\"/"<>file<>"\"]"],ToExpression[ToString[nm]<>"/:"<>file<>":=Get[\""<>disksave<>"/"<>file<>"\"]"]]]]&@@jsect;fr=Reduce[Not[Or@@(And@@Thread[indices==Rest[List@@#]]&/@misFound)||Or@@jRulesF[[All,1,2]]]&&And@@constr,Integers];If[Not[TrueQ[Not[fr]]],Message[SolvejSector::leak,j[nm,##]&@@indices/.{ToRules[LogicalExpand@fr]}]];];MIs[nm]^=jVars[{DeleteCases[MIs[nm],_?(jSector[#]===jsect&)],misFound},Sort->jSector];
LiteRedPrint["    "<>ToString["jRules"@@jsect]<>" \[LongDash] reduction rules for the sector.\n    MIs["<>ToString[nm]<>"] \[LongDash] list of master integrals appended with "<>ToString[Length@misFound]<>" integrals"<>If[misFound==={},"."," ("<>StringTrim[ToString[misFound]," "|"{"|"}"]<>")."]];NotebookDelete/@indicoutput;
Switch[OptionValue[GeneratedCell],
Close,
SelectionMove[EvaluationCell[],All,Cell];
SelectionMove[EvaluationNotebook[],Next,CellGroup];
FrontEndTokenExecute["OpenCloseGroup"],
False,
SelectionMove[EvaluationCell[],All,Cell];
SelectionMove[EvaluationNotebook[],Next,CellGroup];
If[GeneratedCell/.Options[NotebookSelection[EvaluationNotebook[]],GeneratedCell],
FrontEndTokenExecute["Clear"]]
];
If[Not@TrueQ@Not@BasisDirectory[nm],Quiet[DiskSave[nm,Save->"Basis"]]];Length@misFound,(*Cleaning up*)If[reserved,DeleteFile[disksave<>"/"<>file]];Abort[]]]


SolvejSector::nots="The first argument of SolvejSector should be js[\[Ellipsis]]. Received instead:\n`1`";


SolvejSector[s_,OptionsPattern[]]:=(Message[SolvejSector::nots,s];$Failed)


SetAttributes[initdb,HoldFirst]
initdb[dbase_,sector_:Automatic,vars_:{}]:=Module[{db=Unique["db"]},dbase={ToString@db,{}};Evaluate[db]={0->0}];


SetAttributes[finitdb,HoldFirst]
finitdb[dbase_,jsec_,vars_]:=Module[{dbname,str,vs,v,jjs0={},om=jsOrder@@jsec},
vs={v,vars};
str=Fermatica`Private`var2str[Array[v,{Length@vars}]]<>"\n\n"<>ReadString[$LiteRedHomeDirectory<>"FermatCode/sol"];
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
dbname=Fermatica`Private`uniquefile["db"];
OpenWrite[dbname];
WriteString[dbname,str];
Close[dbname];
dbase={dbname,vs,om,jjs0}];


SetAttributes[submiteqs,HoldRest]
submiteqs[eqs_,dbase_,sector_:Automatic,startp_:Automatic]:=dbase[[2]]=eqs;


SetAttributes[fsubmiteqs,HoldRest];
fsubmiteqs[eqs_,dbase_,sector_,startp_]:=Module[{dbname,vs,om,jjs0,jjs,smat,remap,str},
{dbname,vs,om,jjs0}=dbase;
str=StringReplace[ReadString[dbname],"&x;"->""];
If[StringContainsQ[str,"Array eqs["],Print["Found unsolved eqs."];Return[$Failed]];
jjs=DeleteDuplicates@Join[jjs0,Cases[eqs,_j,All]];
remap=Select[jjs,jSector[#]===sector&];
jjs=Join[SortBy[remap,(-om.(Rest[List@@#]-startp))&],Complement[jjs,remap]];
smat=SparseArray[Replace[ArrayRules[CoefficientArrays[eqs,jjs][[2]]]/.MapIndexed[#->First[vs]@@#2&,Last[vs]],{}->{{1,1}->0}]];
remap=SparseArray[Replace[MapIndexed[{1,First[#2]}->Position[jjs,#,{1},1][[1,1]]&,jjs0],{}->{{1,1}->0}]];
jjs0=jjs;
str=str<>Fermatica`Private`smat2str[remap,"remap"]<>"\n\n\n"<>StringReplace[Fermatica`Private`smat2str[smat,"eqs"],(ToString[First[vs]]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
OpenWrite[dbname];
WriteString[dbname,str];
Close[dbname];
dbase[[-1]]=jjs;
];


SetAttributes[solveeqs,HoldRest];
solveeqs[pat_,dbase_,found_,indic_]:=Module[{i,n=0,eqs,dbname,solve},
{dbname,eqs}=dbase;
solve=ToExpression["Solvej[#,"<>dbname<>"]&"];
Do[indic++;
(*Solve equations*)
solve[eqs[[i]]];
found=First[ToExpression[dbname]];
If[MatchQ[First@found,pat],
n=1;
dbase={dbname,Drop[eqs,i]};
Break[]],{i,Length@eqs}];n];


SetAttributes[fsolveeqs,HoldRest];
fsolveeqs[pat_,dbase_,found_,indic_]:=Module[{dbname,vs,om,jjs,str,wanted,rpos},
{dbname,vs,om,jjs}=dbase;
str=StringReplace[ReadString[dbname],"&x;"->""];
If[StringContainsQ[str,"Array wanted["],Print["Found [wanted] array."];Return[$Failed]];
If[!StringContainsQ[str,"Array eqs["],Print["Nothing to solve."];Return[$Failed]];
wanted=SparseArray[Thread[Position[{jjs},pat,{2}]->1],{1,Length@jjs}];
str=str<>"\n\n\n"<>Fermatica`Private`smat2str[wanted,"wanted"]<>"\n\n\nFetch;";
Fermatica`FermatSession[str,indic,If[StringMatchQ[#2,"* eqs solved."],#1+ToExpression[StringDrop[#2,-12]],#1]&,Out->dbname,DeleteFile->False];
str=ReadString[dbname];
rpos=Fermatica`Private`str2scl[str,"rpos"];
If[rpos>0,
found={jjs[[#1[[2]]]],#2}&@@@Most[ArrayRules[Fermatica`Private`str2smat[str,"rule",{"v"~~(n:DigitCharacter..):>(ToString[First@vs]<>"[")<>n<>"]"}]]/.MapIndexed[First[vs]@@#2->#&,Last[vs]]];
found=found[[1,1]]->-(Plus@@Times@@@Rest[found]/found[[1,2]]),
found=0->0
];
rpos
];


SetAttributes[cleandb,HoldAll];
cleandb[dbase_]:=dbase=.


SetAttributes[fcleandb,HoldAll];
fcleandb[dbase_]:=(DeleteFile[First@dbase];dbase=.);


preparepoints[jsector_js,startp_List,depth_]:=Module[{
nm=First@jsector,
corner=Rest[List@@jsector],
points,jso=jsOrder@@jsector,
l=Length[jsector]-1,
signs,
dnpos,dnpow
},
signs=(1-2IntegerDigits[#,2,l])&/@Range[0,2^l-1];
dnpos=Flatten[Position[startp,_Integer,{1}]];
dnpow=startp[[dnpos]];
points=Rest[List@@#]&/@Sort[j[nm]@@(startp+#)&/@Select[diamond[l,depth]
,UnitStep[#[[dnpos]]+dnpow-1/2]===corner[[dnpos]]&]
,(*{Abs[#[[1]]],#}&@*)(*(jso.#)&*)Less];
(*points=startp+#&/@SortBy[Select[diamond[l,depth]
,UnitStep[#[[dnpos]]+dnpow-1/2]===corner[[dnpos]]&]
,(*{Abs[#[[1]]],#}&@*)(jso.#)&];*)
points
]


LiteRed`SolvejSectorTag;


SolvejSectorTag::usage="SolvejSectorTag[\!\(\*
StyleBox[\"sector\", \"TI\"]\):js[\[Ellipsis]]] tries to find symbolic rules for the reduction of the integrals in the \!\(\*
StyleBox[\"sector\", \"TI\"]\).\n\
Options:\n\
    NamingFunction\[Rule]Function[\[Ellipsis]]|Automatic:Automatic, see ?NamingFunction;\n\
    Depth\[Rule]_Integer:2, the Depth of the heuristic search. If the search did not succeeded in reducing the sector to a finite number of integrals, search depth is incereased automatically;\n\
    NMIs\[Rule]n:0, expected number of master integrals. If the number of the integrals left is less or equal to n, the program terminates assuming those integrals are masters, which may save some time.\n\
    Apply\[Rule]True|False:True determines whether to apply found rule at the last stage.\n\
    MIs\[Rule]{\[Ellipsis]}:{}, expected masters in the sector.\n\ 
    SR\[Rule]False|True:True determines whether the symmetry relations should be used on the last step;\n\
    DiskSave\[Rule]True|False|\!\(\*
StyleBox[\"directory\", \"TI\"]\):False determines whether to save the found rules on the disk.";


SolvejSectorTag::leak="Discrepancy detected. Reduction is not full: `1`.";


Options[SolvejSectorTag]={NamingFunction->Automatic,
Depth->2(*\:0433\:043b\:0443\:0431\:0438\:043d\:0430 \:043f\:043e\:0438\:0441\:043a\:0430*),
MaxDepth->\[Infinity],
SR->True(*\:0438\:0441\:043f\:043e\:043b\:044c\:0437\:043e\:0432\:0430\:0442\:044c \:0441\:043e\:043e\:0442\:043d\:043e\:0448\:0435\:043d\:0438\:044f \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0438?*),
NMIs->-1,
MIs->{},
RRs->Automatic,
DiskSave->True(*\:0421\:043e\:0445\:0440\:0430\:043d\:044f\:0442\:044c \:043d\:0430\:0439\:0434\:0435\:043d\:043d\:044b\:0435 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:043d\:0430 \:0434\:0438\:0441\:043a\:0435?*),
DiskRecover->False,
Replace->True,
TimeConstrained->False,
CheckZeroFunction->Factor1,
CheckZeroAlways->True,
SimplifyFunction->Factor1,
SimplifyAlways->True,
Apply->True,
Rule->{},
jGraph->False
};
SolvejSectorTag::parse="Could not parse `1`.";
SolvejSectorTag::dim="Please, set dimension to be a symbol. Use SetDim[\[Ellipsis]]. Aborting...";


SolvejSectorTag[Symbol$basis_Symbol,opts:OptionsPattern[]]:=
Module[{res},
CurrentState[Symbol$basis,SolvejSectorTag]=False;
res=SolvejSectorTag[UniqueSectors[Symbol$basis],opts];
If[MatchQ[res,{__Integer?Positive}],CurrentState[Symbol$basis,SolvejSectorTag]=True];
res
]
SolvejSectorTag[sects_List,opts:OptionsPattern[]]:=SolvejSectorTag[#,opts]&/@sects


SolvejSectorTag[js$sector_js,OptionsPattern[]]:=Module[{(*debug=PrintTemporary["debug mode"] ,*)List$corner=List@@Rest@js$sector,sectp,Integer$NDs=Length@js$sector-1,Bool$reserved=False,List$indices,And$indicesInSector,indication$numberOfPoints=0,indication$numberOfPointsToGo=0,List$signs,indication$outputToDelete={},List$misFound={},Symbol$basis=First@js$sector,Bool$numericIndices,String$jRulesFilename=ToString[HoldForm[jRules[##]]&@@js$sector],List$noRulesYet={{}},Function$orderRules,List$rulesFound={},List$parameters,d=MetricTensor[],Function$identities,rules1,rules2,startp,pat1,ptrnrule,jRules1,jRulesF,jRulesDB,pos,searchDepth,useSR,recover,continue,mir,nr,fr,tcnd,ds,dr,onmis,orrs,tc,tcf,sjopts,whenBad,smartReduce,smartReduce1,eqr,cf,fromRules,expandRules,found,depth,maxDepth,subs,ui,i,used,jrdb,fermat},
(*Print[Contexts["Mint`"],Contexts["LiteRed`"]];*)
CheckAbort[
(* Processing options *)
{List$indices,searchDepth,maxDepth,useSR,ds,dr,onmis,tc,orrs,subs}={Replace[OptionValue[NamingFunction],Automatic:>$NamingFunction][Integer$NDs],OptionValue@Depth,OptionValue@MaxDepth,OptionValue@SR,Replace[OptionValue@DiskSave,True:>BasisDirectory[Symbol$basis]],Replace[OptionValue@DiskRecover,{Automatic|True->True,_->False}],OptionValue@NMIs,OptionValue@TimeConstrained,OptionValue@RRs,OptionValue@Rule};
fermat=!FreeQ[{OptionValue[SimplifyFunction],OptionValue[CheckZeroFunction]},Global`FEval];
Declare[Evaluate@List$indices,Number];(*List$indices\[LongDash]\:043f\:0435\:0440\:0435\:043c\:0435\:043d\:043d\:044b\:0435 \:0434\:043b\:044f \:0438\:043d\:0434\:0435\:043a\:0441\:043e\:0432*)tcf=If[Not@TrueQ@Not@tc,TimeConstrained,#&];sjopts=FilterRules[(#->OptionValue[SolvejSectorTag,#])&/@First/@Options[SolvejSectorTag],Options[SolvejTag]];
orrs=Replace[Flatten@{orrs/.Automatic->{IBP[Symbol$basis],LI[Symbol$basis]}},x:IBP|LI:>x[Symbol$basis],{1}];
(*/ Processing options *)
(*Recovering from disk*)
And$indicesInSector=Inner[#2[#1]&,List$indices,(List$corner/.{1->(GreaterEqual[#,1]&),0->(LessEqual[#,0]&)}),And];ptrnrule=Inner[#1->Pattern[#1,_]?#2&,List$indices,(List$corner/.{1->Positive,0->NonPositive}),List];
(*Added 31.05.2016*)sectp=js[Symbol$basis,##]&@@Replace[Transpose[{PowerShifts[Symbol$basis],List$corner}],{{0,x_}:>x,_:>0|1},{1}](*/Added 31.05.2016*);
If[Not@TrueQ@Not@ds&&dr&&FileExistsQ[ds<>"/"<>String$jRulesFilename],jRulesF=Get[ds<>"/"<>String$jRulesFilename];If[jRulesF==="reserved",LiteRedPrint["The sector ",js$sector," is likely being solved by another kernel. Execute SolvejSectorTag["<>ToString[js$sector]<>",DiskRecover\[Rule]True] later to update MIs["<>ToString[Symbol$basis]<>"]."];Return[Indeterminate],List$misFound=j[Symbol$basis,##]&@@List$indices/.#&/@{ToRules[LogicalExpand@Reduce[Not[Or@@jRulesF[[All,1,2]]]&&And$indicesInSector,Integers]]};If[!FreeQ[List$misFound,Alternatives@@List$indices],Message[SolvejSectorTag::leak,List$misFound]]];If[ds===BasisDirectory[Symbol$basis],ToExpression[ToString[Symbol$basis]<>"/:"<>String$jRulesFilename<>":=Get[BasisDirectory["<>ToString[Symbol$basis]<>"]<>\"/"<>String$jRulesFilename<>"\"]"],ToExpression[ToString[Symbol$basis]<>"/:"<>String$jRulesFilename<>":=Get[\""<>ds<>"/"<>String$jRulesFilename<>"\"]"]];LiteRedPrint["Sector ",js$sector," is recovered from file"];,
(**)
onmis=Replace[onmis,{Automatic:>If[Contexts["Mint`"]=!={},If[IntegerQ[#],#,0]&@Symbol["Mint`CountMIs"][js$sector,Symmetric->useSR],0]}];
tcf[LiteRedPrint["Sector ",js$sector];If[Not[TrueQ@Not@ds||FileExistsQ[ds<>"/"<>String$jRulesFilename]],If[!DirectoryQ[ds],CreateDirectory[ds];Message[DiskSave::dir,ds]];Put["reserved",ds<>"/"<>String$jRulesFilename];Bool$reserved=True];(*ptrnrule\[LongDash]\:0437\:0430\:043c\:0435\:043d\:0430 List$indices \:043d\:0430 \:043f\:0430\:0442\:0442\:0435\:0440\:043d\:044b*)
Function$orderRules[x_]:=First/@Flatten[Sort[#,(Last@#1)>(Last@#2)&]&/@SortBy[Gather[{#,j[Symbol$basis,##]&@@List$indices/.#}&/@x(*\:0421\:0430\:043c\:0438 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:0438 \:0438\:043d\:0434\:0435\:043a\:0441\:044b \:043f\:043e\:0441\:043b\:0435 \:0438\:0445 \:043f\:0440\:0438\:043c\:0435\:043d\:0435\:043d\:0438\:044f*),MatchQ[Expand[List@@Last@#1-List@@Last@#2],{__Integer}]&(*\:0421\:043e\:0431\:0438\:0440\:0430\:0435\:043c \:0432 \:0433\:0440\:0443\:043f\:043f\:044b \:0440\:043e\:0434\:0441\:0442\:0432\:0435\:043d\:043d\:044b\:0445*)],{
Length@First@First@#,(*# of fixed parameters*)
Count[Last@First@#,_Integer],(*# of numeric indices*)
Sort@Flatten@Position[Take[jComplexity[Last@First@#],-Integer$NDs],Except[_Integer],{1}]
(*position of symbolic indices*)
}&],1];
(*\:0413\:043e\:0442\:043e\:0432\:0438\:043c\:0441\:044f \:043a \:0440\:0435\:0448\:0435\:043d\:0438\:044e \:0443\:0440\:0430\:0432\:043d\:0435\:043d\:0438\:0439 \:0432 \:0434\:0430\:043d\:043d\:043e\:043c \:0441\:0435\:043a\:0442\:043e\:0440\:0435*)
jSector[Symbol$basis]=js$sector;jRulesF={};
(*Modified 16.03.2015*)
Function$identities=Join@@(Through[orrs@@List$indices]);(*/Modified*)
List$parameters=Complement[Variables[Last@Reap[Collect[Function$identities,_j,Sow]]],List$indices];
If[TrueQ[OptionValue[jGraph]],AppendTo[indication$outputToDelete,LiteRedPrintTemporary[GraphPlot[jGraph[js$sector],ImageSize->Tiny]]]];
AppendTo[indication$outputToDelete,LiteRedPrintTemporary["Parameters "<>ToString[List$parameters]<>" are assumed to be independent."]];
If[onmis>=0,AppendTo[indication$outputToDelete,LiteRedPrintTemporary["Expecting "<>ToString[onmis]<>" masters."]]];
Function$identities=Function@@{sharpen[Function$identities]/.MapIndexed[#->Slot@@#2&,List$indices]};List$signs=(1-2IntegerDigits[#,2,Integer$NDs])&/@Range[0,2^Integer$NDs-1];
(*whenBad*)whenBad[expr_]:=Module[{jl=Cases[CollectjList[expr],{tt_j,_}(*Added 31.05.2016*)(*/;!jSector[tt]<js$sector(*
Definitely erroneous attempt: in particular dropped terms may have zeros in the denominators*)*)(*/Added 31.05.2016*)],dconds,nconds},dconds=LogicalExpand[Or@@(And@@Thread[0==Flatten[{CoefficientList[#,List$parameters]}]]&/@Union@@((First/@FactorList[#])&/@Denominator/@Last/@jl))];nconds={#2,smartReduce[Or@@Thread[Pick[List@@#1,js$sector,0]>=1]]}&@@@jl;If[MemberQ[nconds,{_,True}],Return[True]];nconds=Or@@Flatten@Cases[nconds,{b_,a:Except[False]}:>Cases[Replace[{a},Or->Sequence,{2},Heads->True],x_/;0=!=Expand[Numerator[b]/.ToRules[x]]]];(*LogicalExpand@*)smartReduce[LogicalExpand[dconds||nconds]]];(*/whenBad*)(*smartReduce*)smartReduce[expr_]:=Module[{exprl=Replace[{expr},Or->Sequence,{2},Heads->True],t,v,l},
Or@@((t=Replace[{#},And->Sequence,{2},Heads->True];t=And@@((*Added 18.10.2016*)(*(*Deleted 18.10.2016*)Function[{cnd,vs},cf[LogicalExpand@TimeConstrained[(*\[LeftArrow]added 25.12.2012*)Reduce[#,vs,Integers],300,#]&[cnd&&Select[And$indicesInSector,MemberQ[vs,First@#]&]]]]&@@@(v=Cases[List$indices,n_/;Not[FreeQ[#,n]]]&/@t;{And@@Pick[t,#],Union@@Pick[v,#]}&/@disjointFlags[v])(*/Deleted 18.10.2016*)*)(*/Added 18.10.2016*)Function[l,cf[LogicalExpand@TimeConstrained[(*\[LeftArrow]added 25.12.2012*)Reduce[#,l[[1,2]],Integers],300,#]&[And@@l[[All,1]]&&Select[And$indicesInSector,MemberQ[l[[1,2]],First@#]&]]]]/@GatherBy[Transpose[{t,FixedPoint[Function[l,Union@@Cases[l,x_/;{}!=Intersection[#,x]]&/@l],Cases[List$indices,n_/;Not[FreeQ[#,n]]]&/@t]}],Last]))&/@exprl)];cf[x_Or]:=cf/@x;cf[x_]:=Module[{Cs=Union@Cases[{x},_C,\[Infinity]](*\:0441\:0433\:0435\:043d\:0435\:0440\:0438\:0440\:043e\:0432\:0430\:043d\:043d\:044b\:0435 Reduce \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*),l=Replace[{x},And->Sequence,{2},Heads->True],c,dens=Alternatives@@Pick[List$indices,List$corner,1],nums=Alternatives@@Pick[List$indices,List$corner,0]},If[MatchQ[x,True|False],Return[x]];l=Replace[l,(*\:0417\:0430\:043c\:0435\:043d\:044f\:0435\:043c \:043d\:0430 \:043a\:0430\:043d\:043e\:043d\:0438\:0447\:0435\:0441\:043a\:0443\:044e \:0444\:043e\:0440\:043c\:0443*)HoldPattern[y_Alternatives\[Element]Integers]:>Sequence@@((#\[Element]Integers)&/@List@@y),{1}];If[Cs=!={},(*\:0415\:0441\:0442\:044c \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*)(*\:041f\:0440\:043e\:0432\:0435\:0440\:044f\:0435\:043c,\:0447\:0442\:043e Reduce \:0441\:0433\:0435\:043d\:0435\:0440\:0438\:043b \:0442\:043e\:043b\:044c\:043a\:043e \:0446\:0435\:043b\:044b\:0435 \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*)If[And@@(MemberQ[l,HoldPattern[#\[Element]Integers]]&/@Cs),l=DeleteCases[l,Alternatives@@Cs\[Element]Integers],(*Message[SolvejSectorTag::parse,eqr];*)Return[True]];c=Cases[l,(y_>=#)|(y_<=#)|(#<=y_)|(#>=y_)]&/@Cs;If[Not[And@@(Length[#]===1&/@c)],(*Message[SolvejSectorTag::parse,eqr];*)Return[True]];c=Flatten@c;l=Complement[l,c];c=(*\:0417\:0434\:0435\:0441\:044c \:043d\:0435 \:0441\:043e\:0432\:0441\:0435\:043c \:043f\:043e\:043d\:044f\:043b*)Cases[l,t:((z:#+1)==(y:dens)|(y:dens)==(z:#+1)|(z:-#)==(y:nums)|(y:nums)==(z:-#)):>{y,t}]&/@MapThread[Replace[#1,{y_>=#2|#2<=y_:>Expand[y-#2],y_<=#2|#2>=y_:>Expand[#2-y]}]&,{c,Cs}];If[MemberQ[c,{}],(*Message[SolvejSectorTag::parse,eqr];*)Return[True]];c=Last@Last@SortBy[#,Position[List$indices,First@#1,1]&]&/@c;l=Complement[l,c];c=ExpandAll[Flatten[Solve[c,Cs]]],c={}];(*\:041e\:0447\:0435\:0432\:0438\:0434\:043d\:044b\:0435 \:043e\:0433\:0440\:0430\:043d\:0438\:0447\:0435\:043d\:0438\:044f \:043d\:0430 \:0438\:043d\:0434\:0435\:043a\:0441\:044b \:0441\:0440\:0430\:0437\:0443 \:0443\:0434\:0430\:043b\:044f\:0435\:043c*)l=DeleteCases[l,Alternatives@@List$indices\[Element]Integers|dens>=1|1<=dens|nums<=0|0>=nums];(*\:0414\:043e\:043b\:0436\:043d\:044b \:043e\:0441\:0442\:0430\:0442\:044c\:0441\:044f \:0442\:043e\:043b\:044c\:043a\:043e \:0440\:0430\:0432\:0435\:043d\:0441\:0442\:0432\:0430*)If[!MatchQ[l,{(Alternatives@@List$indices==_|_==Alternatives@@List$indices)...}],(*Message[SolvejSectorTag::parse,eqr];*)Return[True]];l=ExpandAll[Replace[l,(y_==(z:Alternatives@@List$indices))|((z:Alternatives@@List$indices)==y_):>z==(y/.c),{1}]];And@@l];(*/smartReduce*)(*fromRules*)fromRules[x_]:=Or@@And@@@(x/.Rule->Equal);(*/fromRules*)(*expandRules*)expandRules[x_]:=(Pick[#1,Table[!MemberQ[Delete[#2,i]/.#1[[i]],True],{i,Length[#1]}]]&[#,Apply[And,#/.Rule->Equal,{1}]])&[Union[Sort/@x]];(*/expandRules*)
(* ********************************************************************************************************)(*First,solve identities in general case*)(*debugt=AbsoluteTime[];*)jRulesDB={};
If[fermat,(LiteRedPrintTemporary["Fermat initialized with "<>#];Global`FInit["",#])&[StringJoin@Riffle[ToString/@Join[List$parameters,List$indices],","]]];
Solvej[indication$numberOfPoints++;#(*/.subs,Length@AppendTo[used,#]*),jRulesDB,Evaluate[Sequence@@sjopts]]&/@(Function$identities@@List$indices);(*Shift indices to cannonical form in the l.h.s.*)jRulesDB=(#/.MapThread[#1->Expand[2#1-#2]&,{List$indices,Rest[List@@First[#]]}])&/@jRulesDB;(*Patternize the left sides of the rules and form a list of rules for the integrals to consider later*){jRulesF,rules1}=Reap[(*Modified 01.12.2016*)(#[[1]]/.ptrnrule)/;"condition":>Evaluate[#[[2]]](*/Modified 01.12.2016*)/."condition"->Not[Sow[whenBad[#[[2]]]]]&/@jRulesDB];(*Print["Time:",AbsoluteTime[]-debugt];*)(*Just for safety:do not expect empty list*)If[rules1==={},Print["Abnormality: rules have not been sown. Aborting...",Abort[]]];(*\:0417\:0434\:0435\:0441\:044c \:0432 \:0431\:0443\:0434\:0443\:0449\:0435\:043c \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0443 \:043d\:0443\:0436\:043d\:043e \:0443\:0442\:043e\:0447\:043d\:0438\:0442\:044c*)(*List$noRulesYet=Sort[{ToRules[smartReduce[LogicalExpand[And@@First@rules1]]]},Function$orderRules];(*Now we enter the main loop*)*)List$noRulesYet=Function$orderRules[{ToRules[smartReduce[LogicalExpand[And@@First@rules1]]]}];jRulesF=DeleteCases[jRulesF,(*Modified 01.12.2016*)HoldPattern[x_Condition:>_](*/Modified 01.12.2016*)/;Last[x]===False];(*Remove rules that never work*)nr=Length[jRulesF];(*Print[jRulesF];****debug****)
(*LOOP OVER List$noRulesYet*)
LiteRedMonitor[While[
List$noRulesYet=!={},
(*Consider first case*)
used={};
rules1=First@List$noRulesYet;List$noRulesYet=Rest@List$noRulesYet;
startp=List$indices/.rules1;
Bool$numericIndices=FreeQ[startp,Alternatives@@List$indices];
found=False;
If[fermat,(LiteRedPrintTemporary["Fermat initialized with "<>#];Global`FInit["",#])&[StringJoin@Riffle[ToString/@Join[List$parameters,Variables[startp]],","]]];
(*If[Bool$numericIndices,Print[Length[List$misFound]+Length[List$noRulesYet]];Print[onmis]];*)
If[!Bool$numericIndices||Length[List$misFound]+Length[List$noRulesYet]>=onmis,(*\:0418\:043d\:043e\:0433\:0434\:0430 \:0431\:043e\:043b\:0435\:0435 \:0441\:043f\:0435\:0446\:0438\:0444\:0438\:0447\:0435\:0441\:043a\:0438\:0435 \:0441\:043b\:0443\:0447\:0430\:0438 \:043f\:043e\:043f\:0430\:0434\:0430\:044e\:0442 \:0432 \:0443\:0436\:0435 \:0440\:0435\:0448\:0435\:043d\:043d\:044b\:0435*)If[(fr=Select[List$rulesFound,TrueQ[First[#]/.rules1]&&Not[TrueQ[Simplify[Last[#]/.rules1]]]&,1])=!={},(*\:0417\:0434\:0435\:0441\:044c \:0432 \:0431\:0443\:0434\:0443\:0449\:0435\:043c \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0443 \:043d\:0443\:0436\:043d\:043e \:0443\:0442\:043e\:0447\:043d\:0438\:0442\:044c*)List$noRulesYet=Function$orderRules[expandRules[{ToRules@smartReduce[LogicalExpand[fromRules[List$noRulesYet]||fromRules[{rules1}]&&fr[[1,2]]]]}]];Continue[]];nr++;pat1=(j[Symbol$basis,##]&@@(Pattern[#,Blank[]]&/@List$indices))/;"condition"/."condition"->fromRules[{rules1}];pos=Flatten[
Position[List$indices,Alternatives@@Complement[List$indices,First/@rules1],1]];jRulesDB={};
(*(*Deleted 04.12.2016*)(*Added 18.07.2016*)If[Bool$numericIndices,jRulesDB=jRulesF,(*/Added 18.07.2016*)jRulesDB={}(*Added 18.07.2016*)];(*/Added 18.07.2016*)(*/Deleted 04.12.2016*)*)
depth=0;
While[depth<=searchDepth,
(indication$numberOfPoints++;If[SolvejTag[#/.subs,Length@AppendTo[used,#],jRulesDB,Evaluate[Sequence@@sjopts]],
jRules1=First[jRulesDB];
If[(Bool$numericIndices&&First@jRules1<j[Symbol$basis,##]&@@startp)||TrueQ[jSector@First@jRules1<jSector@j[Symbol$basis,##]&@@startp],
None;(*jRulesDB=Rest[jRulesDB];*)(*Collect garbage when doing Laporta*)
,
(*added 23.06.2014*)
If[MatchQ[First@jRules1,pat1],
If[subs==={},
(*Remove stupid tags*)
jRules1=jRules1[[1]]:>Evaluate[jRules1[[2,1]]]
,
(*Rerunning for symbolic indices*)
jrdb={};
ui=jRules1[[2,2]];
(*LiteRedPrintTemporary["Solving "<>ToString[ui]<>" out of "<>ToString[Length@used]<>" equations for symbolic invariants"];*)
LiteRedMonitor[i=0;Solvej[i++;#,jrdb,Evaluate[Sequence@@sjopts]]&/@used[[ui]],Overlay[{ProgressIndicator[i,{0,Length@ui}],ToString[i]<>"\[Rule]"<>ToString[Length@ui]<>"("<>ToString[Length@used]<>")"}]];
If[jrdb[[1,1]]===jRules1[[1]],jRules1=First[jrdb],LiteRedPrint[jrdb[[1,1]],"\[NotEqual]",jRules1[[1]],"\nPerhaps, bad choice of the 'Rule' option"];Abort[]]
];
jRules1=(#/.MapThread[#1->Expand[2#1-#2]&,{List$indices[[pos]],Rest[List@@First[#]][[pos]]}])&[jRules1];(*Patternize the left sides of the rules and form a list of rules for the integrals to consider later*)
{jRules1,rules2}=Reap[(*Modified 01.12.2016*)(j[Symbol$basis,##]&@@List$indices/.ptrnrule)/;"condition":>Evaluate[#[[2]](*{Collectj[#[[2,1]],OptionValue[SimplifyFunction]],#[[2,2]]}*)](*/Modified 01.12.2016*)/."condition"->fromRules[{rules1}]&&Not[Sow[whenBad[#[[2]](*#[[2,1]]*)]]]&@jRules1];
(*Just for safety:do not expect empty list*)
If[rules2==={},Print["Abnormality: rules have not been sown. Aborting...",Abort[]]];
{{rules2}}=rules2;
If[rules2=!=True,(*Found the rule!*)
AppendTo[List$rulesFound,{fromRules[{rules1}],rules2}];
(*\:0417\:0434\:0435\:0441\:044c \:0432 \:0431\:0443\:0434\:0443\:0449\:0435\:043c \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0443 \:043d\:0443\:0436\:043d\:043e \:0443\:0442\:043e\:0447\:043d\:0438\:0442\:044c*)List$noRulesYet=Function$orderRules[expandRules[{ToRules@smartReduce[LogicalExpand[fromRules[List$noRulesYet]||fromRules[{rules1}]&&rules2]]}]];AppendTo[jRulesF,jRules1];found=True;
Break[]];]];
]&/@(DeleteDuplicates@If[useSR&&Bool$numericIndices,DeleteCases[Join[Function$identities@@#,SR[Symbol$basis]@@#]/.ZerojRule[Symbol$basis],0],Function$identities@@#(*(*Deleted 21.11.2016*)(*In rare cases results in wrong nullification*)/.ZerojRule[Symbol$basis](*/Deleted 21.11.2016*)*)]))&/@((indication$numberOfPointsToGo=indication$numberOfPoints+Length[#];#)&@((*\:0421\:043f\:0438\:0441\:043e\:043a \:0442\:043e\:0447\:0435\:043a \:0434\:043b\:044f \:043f\:043e\:0438\:0441\:043a\:0430*)(*\:0423\:0431\:043e\:0433\:0430\:044f \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0430,\:043f\:043e\:0442\:043e\:043c \:043f\:0435\:0440\:0435\:043f\:0438\:0441\:0430\:0442\:044c*)Sort[Cases[startp+#&/@Union@@Outer[Times,List$signs,layer[List$corner,depth,depth],1],x_/;(MatchQ[jSector[j[Symbol$basis,##]&@@x],sectp])],Which[(*(tcnd=(Plus@@Abs[#1-startp]-Plus@@Abs[#2-startp]))\[NotEqual]0,tcnd<0,*)(tcnd=(Abs[Plus@@((2List$corner-1)(#1-startp))]-Abs[Plus@@((2List$corner-1)(#2-startp))]))!=0,tcnd<0,True,(j[Symbol$basis,##]&@@(#1))<=(j[Symbol$basis,##]&@@(#2))]&]));
If[++depth>searchDepth&&depth<=maxDepth&&!Bool$numericIndices,searchDepth=depth;AppendTo[indication$outputToDelete,LiteRedPrintTemporary["Increasing search depth to "<>ToString[searchDepth]]]]
];(************************************************************************************************************************************)(*];*)
];
If[!found,
AppendTo[indication$outputToDelete,LiteRedPrintTemporary["Found master integral "<>ToString[startp]]];AppendTo[List$misFound,j[Symbol$basis,##]&@@startp]]
],TableForm[{Overlay[{ProgressIndicator[Count[List$indices,x_/;FreeQ[startp,x]],{0,Length@List$indices+1/2}],ToString[indication$numberOfPoints]<>"\[Rule]"<>ToString[indication$numberOfPointsToGo]},Alignment->Center],ToString[nr]<>" point: "<>ToString[startp]}]],tc,If[!Bool$numericIndices,(*If[Bool$reserved,DeleteFile[ds<>"/"<>String$jRulesFilename]];*)Return[$Failed],List$misFound=j[Symbol$basis,##]&@@List$indices/.#&/@{ToRules[LogicalExpand@Reduce[Not[Or@@jRulesF[[All,1,2]]]&&And$indicesInSector,Integers]]};If[!FreeQ[List$misFound,Alternatives@@List$indices],Message[SolvejSectorTag::leak,List$misFound]]]];If[TrueQ[Not[ds]],(#1/:jRules[##]=jRulesF),If[!DirectoryQ[ds],CreateDirectory[ds];Message[DiskSave::dir,ds]];If[!FileExistsQ[ds<>"/"<>String$jRulesFilename]||OptionValue[Replace],If[!Bool$reserved&&FileExistsQ[ds<>"/"<>String$jRulesFilename],Message[DiskSave::overwrite,ds<>"/"<>String$jRulesFilename]];
(*ui=MapIndexed[#1\[Rule]First@#2&,Union@@jRulesF[[All,2,2]]];
Put[{ui,used[[First/@ui]]},ds<>"/Used"<>StringDrop[String$jRulesFilename,6]];*)
Put[Unevaluated[Last[{#1,#2}]],#3]&[jsOrder@@js$sector,jRulesF,ds<>"/"<>String$jRulesFilename];
If[ds===BasisDirectory[Symbol$basis],
ToExpression[ToString[Symbol$basis]<>"/:"<>String$jRulesFilename<>":=Get[BasisDirectory["<>ToString[Symbol$basis]<>"]<>\"/"<>String$jRulesFilename<>"\"]"];
ToExpression[ToString[Symbol$basis]<>"/:Used"<>StringDrop[String$jRulesFilename,6]<>":=Get[BasisDirectory["<>ToString[Symbol$basis]<>"]<>\"/Used"<>StringDrop[String$jRulesFilename,6]<>"\"]"];
,
ToExpression[ToString[Symbol$basis]<>"/:"<>String$jRulesFilename<>":=Get[\""<>ds<>"/"<>String$jRulesFilename<>"\"]"];
ToExpression[ToString[Symbol$basis]<>"/:Used"<>StringDrop[String$jRulesFilename,6]<>":=Get[\""<>ds<>"/Used"<>StringDrop[String$jRulesFilename,6]<>"\"]"];
];
]]&@@js$sector;fr=Reduce[Not[Or@@(And@@Thread[List$indices==Rest[List@@#]]&/@List$misFound)||Or@@jRulesF[[All,1,2]]]&&And$indicesInSector,Integers];If[Not[TrueQ[Not[fr]]],Message[SolvejSectorTag::leak,j[Symbol$basis,##]&@@List$indices/.{ToRules[LogicalExpand@fr]}]];];MIs[Symbol$basis]^=jVars[{DeleteCases[MIs[Symbol$basis],_?(jSector[#]===js$sector&)],List$misFound},Sort->jSector];(*LiteRedPrint["    Master integrals found: "<>If[List$misFound==={},"none",StringTrim[ToString[List$misFound]," "|"{"|"}"]]<>".\n\    "<>ToString["jRules"@@js$sector]<>" \[LongDash] reduction rules for the sector.\n\    MIs["<>ToString[Symbol$basis]<>"] \[LongDash] updated list of the masters."]*)
LiteRedPrint["    "<>ToString["jRules"@@js$sector]<>" \[LongDash] reduction rules for the sector.\n    MIs["<>ToString[Symbol$basis]<>"] \[LongDash] list of master integrals appended with "<>ToString[Length@List$misFound]<>" integrals"<>If[List$misFound==={},"."," ("<>StringTrim[ToString[List$misFound]," "|"{"|"}"]<>")."]];NotebookDelete/@indication$outputToDelete;If[Not@TrueQ@Not@BasisDirectory[Symbol$basis],Quiet[DiskSave[Symbol$basis,Save->"Basis"]]];Length@List$misFound,(*Cleaning up*)If[Bool$reserved,DeleteFile[ds<>"/"<>String$jRulesFilename]];Abort[]]]


SolvejSectorTag::nots="The first argument of SolvejSectorTag should be js[\[Ellipsis]]. Received instead:\n`1`";


SolvejSectorTag[sect_,OptionsPattern[]]:=(Message[SolvejSectorTag::nots,sect];$Failed)


Bloodhound::usage="Bloodhound[\!\(\*
StyleBox[\"equations\", \"TI\"]\),j[\[Ellipsis]]] tries to find the reduction rule for j[\[Ellipsis]] following from \!\(\*
StyleBox[\"equations\", \"TI\"]\). It implements a fast directed search.";


Options[Bloodhound]={SimplifyFunction->Factor1,SimplifyAlways->False,Monitor->Automatic};


Bloodhound[eqs_List,j1_j,opts:OptionsPattern[]]:=Module[{jj=j1,ids=eqs,stack={},t,i,eq,j0,eq0,m,sf=OptionValue@SimplifyFunction,sa=OptionValue@SimplifyAlways,res,rule,
li=Length@eqs,ls=0,stage=""},
m=If[TrueQ[OptionValue@Monitor/.{Automatic->$LiteRedMonitor}],Monitor,#1&];
m[
While[True,
Assert[jj=!={}];
stage="selecting...";
{ids,t}=SplitCases[ids,{_?(FreeQ[#,jj]&)}];
t=DeleteCases[t,0];
If[t==={},res=False->False;Break[]];
i=LowjIndex[Highj/@t];
eq=t[[i]];
rule=jj->(-eq/.jj->0)/Coefficient[eq,jj];
stage="eliminating...";
ids=Join[ids,Collectj[#/.rule,SimplifyFunction->sf,SimplifyAlways->sa]&/@Delete[t,i]];
li=Length@ids;
Assert[FreeQ[ids,jj]];
stage="checking...";
If[Highj[eq]===jj,
j0=jj;
While[jj===j0,
If[stack==={},res=Solvej[eq,SimplifyFunction->sf,SimplifyAlways->sa];Break[]];
{stack,{j0,eq0}}={Most@stack,Last@stack};ls--;
rule=jj->(-eq/.jj->0)/Coefficient[eq,jj];
eq=Collectj[eq0/.rule,Factor1,SimplifyAlways->sa];jj=Highj@eq;
Assert[jj=!={}];
];If[ValueQ[res],Break[]];
AppendTo[stack,{j0,eq}];ls++;,
AppendTo[stack,{jj,eq}];ls++;
jj=Highj[eq]
]
],
TableForm[{Overlay[{ProgressIndicator[ls,{0,li+ls}],Row[{ls,"/",li+ls}]},Alignment->Center],jj,stage}]
];
res
]


(* ::Code::Initialization:: *)
BloodhoundSearch::usage="BloodhoundSearch[j[[...]] reduces the integral using Bloodhound procedure";
Options[BloodhoundSearch]={Depth->0,SR->True};


BloodhoundSearch[jj_j,OptionsPattern[]]:=Module[{dim=Length@jj-1,zeroLayer,shifts,currentPoint,nm=First@jj,layerPoints,searchDepthOption=OptionValue[Depth],useSROption=OptionValue[SR],sect=jSector[jj],layer},
zeroLayer=-Permutations[PadLeft[{1},dim]];
shifts=Join[-zeroLayer,zeroLayer];
zeroLayer=ConstantArray[0,dim];
currentPoint=Rest[List@@jj];
layerPoints=Cases[currentPoint+#&/@DeleteDuplicates[Join@@NestList[Flatten[Outer[Plus,#,shifts,1],1]&,zeroLayer,searchDepthOption]],x_/;(jSector[j[nm,##]&@@x]===sect)];
layer=Flatten[{IBPLI[nm]@@@layerPoints,{},If[useSROption,SR[nm]@@@layerPoints,{}]}](*Select[Flatten[{IBPLI[nm]@@@layerPoints,{},If[useSROption,SR[nm]@@@layerPoints,{}]}],Highj@#\[GreaterEqual]jj&]*);
Bloodhound[layer,jj]
]


AnalyzeSectors::usage="AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] forms the lists of sectors:\n\
    ZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of zero sectors,\n\
    NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of nonzero sectors,\n\
    SimpleSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of simplest nonzero sectors, i.e. nonzero sectors with all subsectors being zero,\n\
    BasisSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of nonzero sectors with at least one zero immediate subsectors.\n\
AnalyzeSectors also generates the rule ZerojRule[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] which nullifies all zero integrals.\n\
AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"pattern\", \"TI\"]\)] analyzes only  sectors js[\!\(\*
StyleBox[\"basis\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"dens\", \"TI\"]\)] such that {\!\(\*
StyleBox[\"dens\", \"TI\"]\)} matches \!\(\*
StyleBox[\"pattern\", \"TI\"]\). \
This is useful if there are additional numerators in the diagram. E.g., if the first index of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) corresponds to the numerator, use AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\),{0,__}]. This will speed up the analysis.";
ZeroSectors::usage="ZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of zero sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).\n\
Note, that this list is formed by AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"pattern\", \"TI\"]\)] procedure. If \!\(\*
StyleBox[\"pattern\", \"TI\"]\) is issued, only those zero sectors which match \!\(\*
StyleBox[\"pattern\", \"TI\"]\) are listed.\n\
See also ?ZerojRule and ?AnalyzeSectors.";
NonZeroSectors::usage="NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of nonzero sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).\n\
Note, that this list is formed by AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"pattern\", \"TI\"]\)] procedure. If \!\(\*
StyleBox[\"pattern\", \"TI\"]\) is issued, only those zero sectors which match \!\(\*
StyleBox[\"pattern\", \"TI\"]\) are listed.\n\
See also ?ZerojRule and ?AnalyzeSectors.";
BasisSectors::usage="BasisSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of basis sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).\n\
	The sector from this set has at least one zero immediate subsector.";
SimpleSectors::usage="SimpleSectors[basis] is the list of the simplest nonzero sectors of the basis.\n\
	For each sector in this list all its subsectors are zero.";
ZerojRule::usage="ZerojRule[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the rule which nullifies all zero integrals.";
CutDs::usage="CutDs\[Rule]{1,0,\[Ellipsis]} is an option for AnalyzeSectors[nb,\[Ellipsis]], which determines, that denominators of the sector js[nb,1,0,\[Ellipsis]] are cut and thus all sectors without any of those denominators are zero.\nCutDs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a flag list of the cut denominators of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";


(*for backward compatibility *)
CutDs[nm_]:=ConstantArray[0,Length@Ds@nm]


AnalyzeSectors::noibp="No IBP relations found. Forgot to generate ones with GenerateIBP[`1`]?";


Options[AnalyzeSectors]={CutDs->Automatic,FeynParUF->True};


AnalyzeSectors[nm_,opts:OptionsPattern[]]:=AnalyzeSectors[nm,SectorsPattern[nm],opts];
AnalyzeSectors[nm_,patt_,OptionsPattern[]]:=Module[{nds=Length@Ds@nm,nloops=Length@LMs@nm,nsects,nsects1,sectors,zsectors,nzsectors={},ssectors={},bsectors={},dbase,s1,st,cds,ps,chzf,str,u,g,x,xs},
CurrentState[nm,AnalyzeSectors]=False;
If[!CurrentState[nm,GenerateIBP],Message[NewDsBasis::notb];Return[$Failed]];
cds=OptionValue[CutDs]/.{None->ConstantArray[0,nds],Automatic:>CutDs[nm]};
ps=Replace[PowerShifts[nm],{Except[0]->1},{1}];
If[OptionValue[FeynParUF],
{u,g,xs}=FeynParUF[js[nm,##]&@@ConstantArray[1,nds],NamingFunction->(Table[Unique[],{#}]&),Function->False];
g=Function[t,Append[# D[t,#]&/@xs,t]]/@MonomialList[u+g,xs];
chzf=MatrixRank[g/.Thread[xs->#]]<=Count[#,1]&;
str="Using Feynman parametrization..."
,
If[!ValueQ[IBP@nm],Message[AnalyzeSectors::noibp,nm];Return[$Failed]];
chzf=((dbase={};Solvej[#,dbase,CheckZeroFunction->Factor1,SimplifyFunction->Factor1,SubstituteAlways->False]&/@IBP[nm]@@#;
Collectj[j[nm,##]&@@#//.dbase,Factor1])===0)&;
str="Solving IBPs in the corner points..."
];
nloops=Length@LMs@nm;
sectors=Cases[(IntegerDigits[#1,2,nds]&)/@Range[0,2^nds-1],patt];
nsects=Length@sectors;
LiteRedMonitor[(*Modified 02.07.2019*)(*st=(Plus@@BitOr[ps,#]<nloops)&/@sectors;
zsectors=Pick[sectors,st];sectors=Pick[sectors,st,False];*)
(*Previously used assumption that the sectors with the number of denominators less than a number of loops.
It fails for non-standard denominators, in particularly, coming from Feynman parametrization of two and more propagators*)
zsectors={};(*/Modified 02.07.2019*)
While[sectors=!={},(*While the list has not been depleted*)(*Take the point in the middle of the list*)s1=sectors[[Ceiling[Length@sectors/2]]];
If[(cds=!=(cds*s1))||chzf@BitOr[ps,s1],(*then move the sector and all its subsectors from sectors to zsectors*)
st=jsectge[s1-#]&/@sectors;
zsectors=Join[zsectors,Pick[sectors,st]];
sectors=Pick[sectors,st,False],(*Otherwise,move the sector and all its supersectors from sectors to nzsectors*)
st=jsectle[s1-#]&/@sectors;
nzsectors=Join[nzsectors,Pick[sectors,st]];
sectors=Pick[sectors,st,False]]],TableForm[{str,ProgressIndicator[Length@sectors,{nsects,0}]}]];
(*Now form the list of basis sectors*)sectors=Sort[nzsectors,Which[Plus@@#1>Plus@@#2,False,Plus@@#1<Plus@@#2,True,True,OrderedQ[{#1,#2}]]&];
nsects1=Length@sectors;
LiteRedMonitor[While[sectors=!={},s1=First@sectors;
sectors=Rest@sectors;
st=Select[bsectors,jsectge[s1-#]&];
If[st=!={},If[s1=!=BitOr@@st,
AppendTo[bsectors,s1]],
AppendTo[bsectors,s1];AppendTo[ssectors,s1]]],TableForm[{"Forming SimpleSectors&BasisSectors...",ProgressIndicator[Length@sectors,{nsects1,0}]}]];
zsectors=js[nm,##]&@@@zsectors;
nzsectors=js[nm,##]&@@@nzsectors;
ssectors=js[nm,##]&@@@ssectors;
bsectors=js[nm,##]&@@@bsectors;
If[SectorsPattern[nm]=!=patt,
SectorsPattern[nm]^=patt;
LiteRedPrint["Updated SectorsPattern["<>#<>"] \[LongDash] pattern for all relevant sectors of the basis "<>#<>"."]&[ToString[nm]]
];
ZeroSectors[nm]^=SortBy[zsectors,{Count[#,1],#}&];
NonZeroSectors[nm]^=SortBy[nzsectors,{Count[#,1],#}&];
sectors={};
While[zsectors=!={},(AppendTo[sectors,#];
zsectors=DeleteCases[zsectors,x_/;x<=#])&[Last[zsectors]]];
SimpleSectors[nm]^=SortBy[ssectors,{Count[#,1],#}&];
BasisSectors[nm]^=SortBy[bsectors,{Count[#,1],#}&];(*17.06.2014*)
If[CutDs[nm]=!=cds,
CutDs[nm]^=cds;
LiteRedPrint["Updated CutDs["<>#<>"] \[LongDash] cut denominators of the basis "<>#<>"."]&[ToString[nm]]
];
(*/17.06.2014*)
ZerojRule[nm]^=jjj:j[#,__]:>0/;Module[{jjs=Rest[List@@jSector@jjj]},(Or@@(BitOr[jjs,#]===#&/@#2))]&[nm,Rest/@List@@@sectors];
CurrentState[nm,AnalyzeSectors]=True;
LiteRedPrint["Found "<>#2<>"("<>#3<>") zero(nonzero) sectors out of "<>#4<>".\n    ZeroSectors["<>#<>"] \[LongDash] zero sectors,\n    NonZeroSectors["<>#<>"] \[LongDash] nonzero sectors,\n    SimpleSectors["<>#<>"] \[LongDash] simple sectors (no nonzero subsectors),\n    BasisSectors["<>#<>"] \[LongDash] basis sectors (at least one immediate subsector is zero),\n    ZerojRule["<>#<>"] \[LongDash] a rule to nullify all zero j["<>#<>"\[Ellipsis]],\n    CutDs["<>#<>"] \[LongDash] a flag list of cut denominators (1=cut)."]&[ToString[nm],ToString@Length@ZeroSectors[nm],ToString@Length@NonZeroSectors[nm],ToString@nsects];
If[Not@TrueQ@Not@BasisDirectory[nm],Quiet[DiskSave[nm,Save->"Basis"]]];
]


ZeroSectorQ::usage="ZeroSectorQ[js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,\[Ellipsis]]] gives True if js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,\[Ellipsis]] is in ZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)]";
NonZeroSectorQ::usage="NonZeroSectorQ[js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,\[Ellipsis]]] gives True if js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,\[Ellipsis]] is in NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)]";
MappedSectorQ::usage="MappedSectorQ[js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,\[Ellipsis]]] gives True if js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,\[Ellipsis]] is in MappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)]";
UniqueSectorQ::usage="UniqueSectorQ[js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,\[Ellipsis]]] gives True if js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),0,1,\[Ellipsis]] is in UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)]";


ZeroSectorQ[x:js[nm_,__]]:=MemberQ[ZeroSectors[nm],x];
NonZeroSectorQ[x:js[nm_,__]]:=MemberQ[NonZeroSectors[nm],x];
MappedSectorQ[x:js[nm_,__]]:=MemberQ[MappedSectors[nm],x];
UniqueSectorQ[x:js[nm_,__]]:=MemberQ[UniqueSectors[nm],x];


FindShifts::usage="FindShifts[js[\!\(\*
StyleBox[\"nm1\", \"TI\"]\),\!\(\*
StyleBox[\"1\", \"TI\"]\)\!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)],js[\!\(\*
StyleBox[\"nm2\", \"TI\"]\),\!\(\*
StyleBox[\"1\", \"TI\"]\)\!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)]] finds shifts from sector js[\!\(\*
StyleBox[\"nm1\", \"TI\"]\),\!\(\*
StyleBox[\"1\", \"TI\"]\)\!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)] to sector js[\!\(\*
StyleBox[\"nm2\", \"TI\"]\),\!\(\*
StyleBox[\"1\", \"TI\"]\)\!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)].\nOptions:\n   EMs\[Rule]True|False:True determines whether to use replacements of external momenta,\n    All\[Rule]True|False:True determines whether to return all substitutions or only one.";
FindShifts::ps="External momenta sets should be the same. Got:\n`1` and `2`";
FindShifts::csym1="Continuous symmetries detected, probably, caused by EMs\[Rule]True option.";
FindShifts::csym2="Continuous symmetries detected. The sector is zero?";
Options[FindShifts]={
EMs->True(*external momenta change*),
All->True(*All mappings or only one.*)
};


FindShifts[jsx:js[nmx_,nsx__],jsy:js[nmy_,nsy__],OptionsPattern[]]:=Module[
{nds,
fpx,fpy,
sigx,sigy,
permx,permy,
lhs,rhs,t,i,k,
lsx,lsy,psx,psy,qsy,ppairs,
cs,lc,pc,
lsmxn,psmxn,
lsxn,psxn,
eqs,sols,sol,all=OptionValue[All],
erules,cont=False
},
nds=Count[{nsx},1];
(*First, check whether the number of denominators is the same*)
If[nds!=Count[{nsy},1],Return[{}]];

(*signatures&permutations*)
{sigx,permx}=jsSignaturePermutations[jsx];
{sigy,permy}=jsSignaturePermutations[jsy];
(*/ signatures&permutations*)

If[sigx=!=sigy,Return[{}]];

(*From here, there should be a mapping!*)
(*Get loop and external momenta*)
lsx=LMs@nmx;lsy=LMs@nmy;
psx=EMs@nmx;psy=EMs@nmx;

(*just in case: check the number of loops*)
If[Length@lsx=!=Length@lsy,Message[FindShifts::err,"different number of loops! Aborting..."];Abort[]];
(*/just in case: check the number of loops*)
(*/Get loop and external momenta*)


If[Sort[psx]===Sort[psy],
(*Parameters for the shift*)
qsy=Join[lsy,psy];
cs=Array[lc,Length@lsx*Length@qsy];
lsmxn=Partition[cs,Length@qsy];
lsxn=lsmxn.qsy;(*new loop momenta*)
Declare[Evaluate@cs,Number];

(*Now external momenta*)
erules=Replace[OptionValue[EMs],
{
Automatic|True|All:>(
psmxn=Table[Unique["p"],{Length@psy},{Length@psy}];(*matrix*)
Declare[Evaluate[Flatten@psmxn],Number];
psxn=psmxn.psy;(*new momenta*)
ppairs=Replace[Subsets[psx,{1,2}],{x_}:>{x,x},{1}];eqs=Reap[Collect[LFDistribute[sp@@@(ppairs/.Thread[psx->psxn]),sp]-(sp@@@ppairs),Variables[{MetricTensor[],sp@@@ppairs}],Sow]][[-1,1]];Quiet[Check[Sort[Thread[psx->psxn]/.Solve[0==GroebnerBasis[eqs,Flatten@psmxn],Flatten@psmxn]],Message[FindShifts::ems1,All];{{}},Solve::svars]]
),
False|None->{{}},
e_:>(
ppairs=Replace[Subsets[psx,{1,2}],{x_}:>{x,x},{1}];
If[TrueQ[MatchQ[Union@@(ExpandAll[LFDistribute[sp@@@(ppairs/.#),sp]-(sp@@@ppairs)]&/@e),{0}]],e,Message[FindShifts::ems1,e];{{}}])
}];
psxn=psx/.erules;(*new external momenta*)
(*/Parameters for the shift*)

(*Find list of possible permutations*)
(*Global`permx=permx;Global`permy=permy;*)
(*Global`permy1=permy;*)
permy=First@permy;permy=Sort[LiteRed`Private`ipermute[permy,#]&/@permx];
(*permy=Union@@Outer[Last@*Transpose@*Sort@*Thread@*List,permx,permy,1];*)
(*Construct and solve equations*)
sols={};
Catch[
lhs=Outer[Coefficient,Expand[LFDistribute[t Ds[jsy],sp]/.Thread[SPs[nmx]->SPs[nmx]/t]],Append[SPs[nmx],t]];
Do[
rhs=Outer[Coefficient,Expand[LFDistribute[t(Ds[jsx]/.Thread[psx->psxn[[i]]]/.Thread[lsx->lsxn]),sp]/.Thread[SPs[nmx]->SPs[nmx]/t]],Append[SPs[nmx],t]];
Do[
(*cycle over all substitutions of external momenta and over FP-selected permutations of denominators.*)
eqs=Flatten[lhs[[permy[[k]]]]-rhs];
eqs=GroebnerBasis[eqs,cs];
sol=Quiet[Check[Join[lsxn,psxn[[i]](*psmn.psy*)]/.#&/@Solve[eqs==0,cs],cont=True;Throw[True](*continuous symmetries detected*),{Solve::svars}]];
sols=Join[sols,sol];
If[!all&&sols=!={},Throw[True]];
,{k,Length@permy}];
,{i,Length@psxn}]
];
(*/Construct and solve equations*)

If[sols==={}&&cont,If[TrueQ[erules],Message[FindShifts::csym1];Return[{}],Message[FindShifts::csym2];Return[{}]]];
sols=Union@sols;
Return[Thread[Join[lsx,psx]->Expand[#]]&/@sols]
,(*External momenta are different, not yet implemented*)
Message[FindShifts::ps,psx,psy];Return[{}]
];
$Failed
]


FindSymmetries::usage="FindSymmetries[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] finds the symmetries of the sectors of \!\(\*
StyleBox[\"basis\", \"TI\"]\). It generates the following objects:\n    UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of unique sectors,\n    MappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of sectors, equivalent to some unique sectors,\n    jRules[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] for each sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in MappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of rules mapping integrals to some unique sector,\n    jSymmetries[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)\!\(\*
StyleBox[\":\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)\!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"1\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"..\", \"TI\"]\)] for each sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of rules mapping unique sector onto itself,\n    SR[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns__\", \"TI\"]\)] for any integral j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in one of the UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of symmetry relations for the specific integral.\nEach j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in one of the  MappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] can be mapped onto one of the UniqueSectors[basis] (and subsectors) using j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)]/.(jRules@@jSector[j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)]]).\n\nNote that FindSymmetries[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] requires running AnalyzeSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] beforehand and considers only sectors in NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)], generated by AnalyzeSectors.";
UniqueSectors::usage="UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of unique sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\), i.e., those sectors in NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] onto which all other sectors NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] can be mapped (those are gathered in MappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)]).";
MappedSectors::usage="MappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) which can be mapped onto the UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)].";
jRules::usage="jRules[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] gives the reduction rule(s) for a given sector.";
jSymmetries::usage="jSymmetries[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] gives the list of rules mapping unique sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] onto itself.";
SR::usage="SR[\!\(\*
StyleBox[\"basis\", \"TI\"]\)][\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)] gives the list of symmetry relations for the integral j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)].";
SectorsMappings::usage="SectorsMappings[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the list of mappings of all sectors from MappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] to UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)].";


SectorsMappings[jjs_js]:=SectorsMappings@@jjs;


Options[FindSymmetries]={NamingFunction->Automatic,
EMs->True,(*jsOrderingFunction\[Rule]Identity,jSymMatrices\[Rule]False,*)ExtUniqueSectors->True};


FindSymmetries::noss="No sectors found. Forgot to analyze sectors with AnalyzeSectors[`1`]?";
FindSymmetries::noshift="Warning: FP-equivalent sectors `1` are not shift-equivalent. Some symmetries are lost.";
FindSymmetries::opt="Something wrong in option `1`. Ignoring it.";
FindSymmetries::ems="Option EMs\[Rule]True probably resulted in continuous symmetries. Try to replace it with EMs\[Rule]False. Aborting...";


debugFindSymmetries1=0;debugFindSymmetries2=0;


FindSymmetries[nm_,OptionsPattern[]]:=Module[
{ps,shiftcompQ,ss,nzs,nzs0,euso,
x,xs,xs1,y,fp,inds,
ds=Ds@nm,nds=NDs@nm,lms=LMs@nm,ems=EMs@nm,
cds=Append[CutDs@nm,0],
m,gle,rule,egle,erule,emsn,oems,
dd,params,dmatr,matr,xeqs={},m2rule,
us,ujs,es,jsec,s,subs,t,l,sol,i},
CurrentState[nm,FindSymmetries]=False;
If[!ValueQ[Ds@nm]||!ValueQ[LMs@nm],Message[NewDsBasis::notb];Return[$Failed]];
If[!ValueQ[SimpleSectors@nm],Message[FindSymmetries::noss,nm];Return[$Failed]];
If[!ValueQ[NonZeroSectors@nm],Message[FindSymmetries::noss,nm];Return[$Failed]];
euso=OptionValue[ExtUniqueSectors];
ps=Replace[PowerShifts[nm],Except[0]->1,{1}];
(*Added 18.10.2018*)shiftcompQ=Function[ps0,If[MatchQ[ps0,{0..}],True&,MatchQ[Factor[Pick[#.ps0-ps0,ps0,Except[0]]],{0...}]&]][Append[PowerShifts[nm],0]];(*/Added 18.10.2018*)
If[euso&&ValueQ[ExtUniqueSectors[nm]],
nzs0=nzs=SortBy[ExtUniqueSectors@nm,{Count[#,1],#}&[Rest[List@@#]]&],
nzs0=nzs=SortBy[NonZeroSectors@nm,{Count[#,1],#}&[Rest[List@@#]]&]
];
(**)
xs=Array[x,nds];
LiteRedPrintTemporary["Constructing Feynman parametrization..."];
fp=Plus@@Most@FeynParUF[nm,NamingFunction->(xs&),Function->False];
LiteRedPrintTemporary["Using Feynman parametrization to determine equivalent simple sectors..."];
ss=SortBy[SimpleSectors@nm,{Count[#,1],#}&[Rest[List@@#]]&];t=Length@ss;
LiteRedMonitor[i=0;
(*Modified 18.10.2018*)ss=Append[
xs1=Pick[xs,BitOr[Rest@(List@@#),ps],1]; polyNF[fp/.Thread[Complement[xs,xs1]->0],xs1]/.x->Identity,i++;#
]&/@ss(*/Modified 18.10.2018*),
ProgressIndicator[i,{0,t}]
];
ss=SortBy[#,Last]&/@Map[Rest,GatherBy[ss,First],{2}];
gle=Array[m,{Length@lms,Length@lms+Length@ems}];
rule=Thread[lms->gle.Join[lms,ems]];
Declare[Evaluate@(gle=Flatten@gle),Number];
oems=Replace[OptionValue[EMs],{
False->{{}},
True:>(egle=Array[m,{Length@ems,Length@ems},Length@lms+1];
erule=Thread[ems->egle.ems];t=ems/.erule;
Declare[Evaluate@(egle=Flatten@egle),Number];gle=Join[gle,egle];
xeqs=DeleteCases[sp@@@Subsets[ems,2]-LFDistribute[sp@@@Subsets[t,2]],0];(*this string uses that sp[a]\[Rule]sp[a,a]*)
If[xeqs=!={},
xeqs=GroebnerBasis[Reap[Collect[Numerator@Factor[xeqs],Select[Variables[{MetricTensor[],sp@@@Subsets[ems,{2}],LFDistribute@Ds@nm}],FreeQ[#,Alternatives@@lms]&],Sow]][[-1,-1]],egle]];
(*rules for external momenta*){erule}),
t:{__List}:>(
(*check consistency*)
If[Complement[Join@@t[[All,All,1]],ems]=!={}||!FreeQ[t,Alternatives@@LMs@nm]||DeleteDuplicates@Flatten[Factor[LFDistribute[sp@@@Subsets[ems,2]-sp@@@Subsets[ems/.#,2]]&/@t]]=!={0},
Message[FindSymmetries::opt,EMs->t];{{}},
t]),
__:>(Message[FindSymmetries::opt,EMs->t];{{}})
}];
dmatr=Append[Outer[Coefficient,Toj[nm,Ds@nm/.rule/.#],Toj[nm,Append[Ds@nm,1]]],PadLeft[{1},nds+1]]&/@oems;(*now this is a list of matrices,each corresponds to the external symmetry*)
LiteRedPrintTemporary["Constructing shifts for simple sectors..."];
(*\:041b\:044e\:0431\:043e\:0439 \:043d\:0435\:043d\:0443\:043b\:0435\:0432\:043e\:0439 \:0441\:0435\:043a\:0442\:043e\:0440 \:043d\:0430 \:044d\:0442\:043e\:043c \:044d\:0442\:0430\:043f\:0435 \:0434\:043e\:043b\:0436\:0435\:043d \:0441\:043e\:0434\:0435\:0440\:0436\:0430\:0442\:044c \:0432\:0441\:0435 \:0440\:0430\:0437\:0440\:0435\:0437\:0430\:043d\:043d\:044b\:0435. \:041f\:043e\:044d\:0442\:043e\:043c\:0443 \:0434\:043e\:0441\:0442\:0430\:0442\:043e\:0447\:043d\:043e \:043f\:0440\:043e\:0441\:043b\:0435\:0434\:0438\:0442\:044c \:0447\:0442\:043e\:0431\:044b SimpleSectors
\:043e\:0442\:043e\:0431\:0440\:0430\:0436\:0430\:043b\:0438\:0441\:044c \:043f\:0440\:0430\:0432\:0438\:043b\:044c\:043d\:043e (\:0442.\:0435., \:0440\:0430\:0437\:0440\:0435\:0437\:0430\:043d\:043d\:044b\:0435 \:0432 \:0440\:0430\:0437\:0440\:0435\:0437\:0430\:043d\:043d\:044b\:0435)*)
LiteRedMonitor[i=0;(*Quiet[*)ss=SortBy[Flatten[(s={};
Function[{top,ujs},i++;jsec=ujs;
Catch[
Do[
Outer[(sol=Check[Solve[0==GroebnerBasis[Flatten@{#1[[#2]]-s[[k,1]],xeqs},gle],gle],Message[FindSymmetries::ems];Abort[],{Solve::svars}];
Function[sr(*solution rules*),matr=#1/.sr;
If[Factor[cds*matr.cds]===cds(*Added 18.10.2018*)&&shiftcompQ[matr](*/Added 18.10.2018*),
s[[k,2]]=Append[s[[k,2]],ujs];s[[k,4]]=Append[s[[k,4]],matr];Throw[Null]]]/@sol)&,dmatr,top,1],
{k,Length@s}];(*********15.10.2013*************************)
(*No mapping onto so far unique*)
t=RotateRight[PadLeft[{1},nds+1],#]&/@First@top;
AppendTo[s,{t,{ujs},DeleteDuplicates[Flatten[Outer[Function[{m,tp},
Select[m/.#&/@Solve[0==GroebnerBasis[Flatten@{m[[tp]]-t,xeqs},gle],gle],Factor[cds*#.cds]===cds&&shiftcompQ[#]&]],dmatr,top,1],2]](*self shifts*),
{(*a place for shift from other topologies*)}}]
]
]@@@#;(******************************************)
(*issue a warning if FP equivalent sectors are not shift equivalent*)
 If[Length@s>1,Message[FindSymmetries::noshift,s[[All,2,1]]]];
 Rest/@s
)&/@ss,1],(-Count[First@First@#,1])&](*,{Solve::svars}]*),
TableForm[{{ProgressIndicator[i,{0,#}]},{jsec}}]
]&[Plus@@Length/@ss];(*Return[ss];*)
LiteRedPrintTemporary["    Found "<>ToString[Length@ss]<>" unique simple sectors with degeneracies "<>ToString[StringTake[ToString@(Length/@First/@ss),{2,-2}]]<>" respectively."];
(*At this point the only result is ss, which has the form {{{js[\[Ellipsis]],\[Ellipsis]},{ss1,\[Ellipsis]},{s1,\[Ellipsis]}},\[Ellipsis]} number of denominators is decreasing*)
(*STOPPED REFACTORING HERE*)
LiteRedPrintTemporary["Constructing shifts for all nonzero sectors..."];
LiteRedMonitor[
While[nzs=!={},
ujs=First@nzs;
{i} = Position[First /@ ss, x_?(#<=ujs &), {2}, 1];
(*\:041e\:0431\:044f\:0437\:0430\:043d\:0430 \:0431\:044b\:0442\:044c \:0445\:043e\:0442\:044f \:0431\:044b \:043e\:0434\:043d\:0430 \:043f\:043e\:0434\:0442\:043e\:043f\:043e\:043b\:043e\:0433\:0438\:044f*)
{subs,us,es}=ss[[First@i]];
t=Last@i;If[t>1,us=es[[t-1]].#&/@us];
s=Factor@Join[us,Flatten[Outer[Dot,us,Inverse/@es,1],1]];(*\:0421\:043f\:0438\:0441\:043e\:043a \:0432\:0441\:0435\:0445 \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0439 \:043f\:043e\:0434\:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
us={};es={};
s=DeleteDuplicates@s;
Scan[(t=Pick[Most@#,List@@Rest@ujs,1];
If[MatchQ[t,{{0...,1,0...}..}],
(*\:0421\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:044f \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
t=Most[Plus@@t];
If[t===List@@Rest@ujs,
AppendTo[us,#](*\:0441\:043e\:0431\:0441\:0442\:0432\:0435\:043d\:043d\:0430\:044f \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:044f \:0441\:0435\:043a\:0442\:043e\:0440\:0430*),
AppendTo[es,{js[nm,##]&@@t,#}](*\:043d\:0435\:0441\:043e\:0431\:0441\:0442\:0432\:0435\:043d\:043d\:0430\:044f \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:044f \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
]
])&,s];
es=SortBy[es,-Count[Last@#,{0...,1,0...}]&];
(*\:0422\:0435\:043f\:0435\:0440\:044c \:0443\:0434\:0430\:043b\:044f\:0435\:043c \:0438\:0437 es \:043b\:0438\:0448\:043d\:0438\:0435 \:0441\:0434\:0432\:0438\:0433\:0438, \:043e\:0434\:043d\:043e\:0432\:0440\:0435\:043c\:0435\:043d\:043d\:043e \:0444\:043e\:0440\:043c\:0438\:0440\:0443\:044f \:0441\:0435\:043a\:0442\:043e\:0440\:0430 \:0433\:0440\:0443\:043f\:043f\:044b*)
s={ujs};
es=DeleteCases[(
If[MemberQ[nzs,#1]&&!MemberQ[s,#1],
(*\:0442\:0430\:043a\:043e\:0433\:043e \:0441\:0435\:043a\:0442\:043e\:0440\:0430 \:0435\:0449\:0435 \:043d\:0435\:0442 \:0432 \:0433\:0440\:0443\:043f\:043f\:0435*)
AppendTo[s,#1];Inverse@#2
,
Null
]
)&@@@es,Null];
nzs=DeleteCases[nzs,Alternatives@@s];
If[MemberQ[subs,ujs],
ss[[First@i]]={s,us,es},
PrependTo[ss,{s,us,es}]
]
],
TableForm[{{ProgressIndicator[#-Length@nzs,{0,#}]},{ujs}}]
]&[Length@nzs];
LiteRedPrintTemporary["    Found "<>ToString[Length@ss]<>" unique sectors with degeneracies "<>ToString[StringTake[ToString@(Length/@First/@ss),{2,-2}]]<>" respectively."];
LiteRedPrintTemporary["Forming rules..."];
inds=Replace[OptionValue[NamingFunction],Automatic:>$NamingFunction][nds];
(********************************************************************************)
m2rule=Function[{ujs,m},(j[nm,##]&@@(If[#1==1,"pt"["p"[#2,Blank[]],Positive],"pt"["p"[#2,Blank[]],NonPositive]]&@@@Transpose[{List@@Rest@ujs,inds}])/.{"pt"->PatternTest,"p"->Pattern}):>Expand[#]&[Times@@(Toj[nm,Most[m].Append[Ds@nm,(*\:0415\:0434\:0438\:043d\:0438\:0446\:0430*)j[nm,Sequence@@ConstantArray[0,nds]]]]^-inds)]
];
LiteRedMonitor[
i=0;Scan[
(i++;jsec=ujs=#[[1,1]];(*\:0443\:043d\:0438\:043a\:0430\:043b\:044c\:043d\:044b\:0439 \:0441\:0435\:043a\:0442\:043e\:0440*)
If[MemberQ[nzs0,ujs],
us=#[[2]];(*\:0441\:043e\:0431\:0441\:0442\:0432\:0435\:043d\:043d\:044b\:0435 \:0441\:0434\:0432\:0438\:0433\:0438*)
(*\:0424\:043e\:0440\:043c\:0438\:0440\:0443\:0435\:043c \:0441\:043e\:0431\:0441\:0442\:0432\:0435\:043d\:043d\:044b\:0435 \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0438*)
nm/:jSymmetries[Sequence@@ujs]=Replace[({m2rule[ujs,#]}&/@us),{}->{{}}]
];
(*\:0424\:043e\:0440\:043c\:0438\:0440\:0443\:0435\:043c \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0438 \:0434\:043b\:044f \:044d\:043a\:0432\:0438\:0432\:0430\:043b\:0435\:043d\:0442\:043d\:044b\:0445 \:0441\:0435\:043a\:0442\:043e\:0440\:043e\:0432*)
(jsec=ujs\[LeftArrow]#1;nm/:jRules[Sequence@@#1]={m2rule[##]})&@@@Cases[(*added 14.10.2013*)Transpose[{Rest@First@#,Last@#}],{_?(MemberQ[nzs0,#]&),_}];
)&,
ss]
,
TableForm[{{ProgressIndicator[i,{0,#}]},{jsec}}]
]&[Plus@@Length/@ss];
UniqueSectors[nm]^=SortBy[Intersection[ss[[All,1,1]],nzs0],{Count[#,1],#}&];
MappedSectors[nm]^=SortBy[Intersection[Join@@Rest/@ss[[All,1]],nzs0],{Count[#,1],#}&];
SectorsMappings[nm]^=Flatten[Thread[Rest[#]->First[#]]&@@@ss];
nm/:SectorsMappings[nm,ns:(0|1)..]:=Cases[SectorsMappings[nm],HoldPattern[js[nm,ns]->_]];
CurrentState[nm,FindSymmetries]=False;
LiteRedPrint["Found "<>ToString[Length@MappedSectors@nm]<>" mapped sectors and "<>ToString[Length@UniqueSectors@nm]<>" unique sectors.\n    UniqueSectors["<>ToString[nm]<>"] \[LongDash] unique sectors.\n    MappedSectors["<>ToString[nm]<>"] \[LongDash] mapped sectors.\n    SR["<>ToString[nm]<>"][\[Ellipsis]] \[LongDash] symmetry relations for j["<>ToString[nm]<>",\[Ellipsis]] from UniqueSectors["<>ToString[nm]<>"].\n    jSymmetries["<>ToString[nm]<>",\[Ellipsis]] \[LongDash] symmetry rules for the sector js["<>ToString[nm]<>",\[Ellipsis]] in UniqueSectors["<>ToString[nm]<>"].\n    jRules["<>ToString[nm]<>",\[Ellipsis]] \[LongDash] reduction rules for j["<>ToString[nm]<>",\[Ellipsis]] from MappedSectors["<>ToString[nm]<>"].\n    SectorsMappings["<>ToString[nm]<>"] gives the list of mappings of all sectors from MappedSectors["<>ToString[nm]<>"] to UniqueSectors["<>ToString[nm]<>"]."];
If[Not@TrueQ@Not@BasisDirectory[nm],Quiet[DiskSave[nm,Save->"Basis"]]];
Length@MappedSectors@nm
]


FindExtSymmetries::usage="FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\)] finds the mappings of the sectors of \!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\) to unique sectors of \!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\). It generates the following objects:\n    ExtUniqueSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] \[LongDash] the list of sectors which can not be mapped,\n    ExtMappedSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] \[LongDash] the list of sectors, equivalent to some unique sectors of \!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\),\n    jExtRules[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] for each sector js[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in ExtMappedSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] \[LongDash] the list of rules mapping integrals to some unique sector of \!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\).\nNote that FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\)] requires running AnalyzeSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] and FindSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\)] beforehand. If afterwards FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(3\)]\)] is called, it tries to map only those sectors which are in ExtUniqueSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] and modifies correspondingly the lists ExtUniqueSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)] and  ExtMappedSectors[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\)].\nFindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(k\)]\)] is a shortcut for FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(k\)]\)];FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(k - 1\)]\)];FindExtSymmetries[\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"basis\", \"TI\"], \(2\)]\)] \[LongDash] mind the order.";
ExtUniqueSectors::usage="ExtUniqueSectors[basis] is the list of unique sectors of the basis, i.e., those sectors in NonZeroSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] which can not be mapped onto other bases.";
ExtMappedSectors::usage="ExtMappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) which can be mapped onto sectors of some other bases.";
jExtRules::usage="jExtRules[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] gives the reduction rule(s) for a given sector, which map it onto the sector of another basis.";
ExtSectorsMappings::usage="ExtSectorsMappings[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives the list of mappings of all sectors from ExtMappedSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] to unique sectors of other bases.";


Options[FindExtSymmetries]={NamingFunction->Automatic,EMs->False};
FindExtSymmetries::basisorder="The bases names are not properly ordered.";
FindExtSymmetries::nosectors="Run `2`[`1`] first. Aborting...";
FindExtSymmetries::opt="Something wrong in option `1`. Ignoring it.";
FindExtSymmetries[b1_Symbol,b2_Symbol,bs__Symbol,opts:OptionsPattern[]]:=Total[FindExtSymmetries[b1,#1,opts]&/@Reverse[{b2,bs}]];
(*FindExtSymmetries[bs:(_,_,__),opts:OptionsPattern[]]:=FindExtSymmetries[#1,#2,opts]&@@@Reverse[Subsets[{bs},{2}]];*)
FindExtSymmetries[b1_Symbol,b2_Symbol,OptionsPattern[]]:=Module[
{nzs1,us2,l,i,k,pt,
xs,x,fp,pnf,t,jsm,
dmatr,matr,cs,
lms1=LMs[b1],
lms2=LMs[b2],
ems1=EMs[b1],
ems2=EMs[b2],
ds1=Ds[b1],
ds2=Ds[b2],
cds1=CutDs[b1],
cds2=Append[CutDs[b2],0],
sol,m2rule,
inds,ems,empd={}
},
If[OrderedQ[{b1,b2}],Message[FindExtSymmetries::basisorder]];
pt=LiteRedPrintTemporary["Forming signatures for unique sectors..."];
xs=Array[x,{Length@Ds[b2]}];
fp=Plus@@Most@FeynParUF[b2,NamingFunction->(xs&),Function->False];
us2=UniqueSectors[b2];l=Length@us2;
Assert[Head[us2]===List];
If[Head[us2]===UniqueSectors,Message[FindExtSymmetries::nosectors,"FindSymmetries",b2];Abort[]];
NotebookDelete[pt];
i=0;LiteRedMonitor[
us2=(*Modified 13.08.2019*)Replace[Function[js2,i++;
jsm=js2;{js2,#1,#2[[All,All,1]]}&@@LiteRed`Private`polyNF[fp/.Thread[Pick[xs,List@@Rest@js2,0]->0],Pick[xs,List@@Rest@js2,1]]]/@us2,{js1_,sgn_,prm_List}:>(Sequence@@({js1,sgn,#}&/@prm)),{1}](*/Modified 13.08.2019*),
TableForm[{"Forming signatures for unique sectors",ProgressIndicator[i,{0,l}],jsm
}]];
(* sgn2 \[LongDash] \:0441\:043f\:0438\:0441\:043e\:043a \:0441 \:044d\:043b\:0435\:043c\:0435\:043d\:0442\:0430\:043c\:0438 {js[\[Ellipsis]],signature_List,inds_List} *)
(*\:0414\:043b\:044f \:043a\:0430\:0436\:0434\:043e\:0433\:043e \:043d\:0435\:043d\:0443\:043b\:0435\:0432\:043e\:0433\:043e \:0441\:0435\:043a\:0442\:043e\:0440\:0430 \:043f\:0435\:0440\:0432\:043e\:0433\:043e \:0431\:0430\:0437\:0438\:0441\:0430 \:0438\:0449\:0435\:043c \:043f\:043e\:0434\:0445\:043e\:0434\:044f\:0449\:0438\:0439 \:0441\:0435\:043a\:0442\:043e\:0440 \:0432\:0442\:043e\:0440\:043e\:0433\:043e, \:0438 \:0435\:0441\:043b\:0438 \:043e\:043d \:043d\:0430\:0439\:0434\:0435\:043d, \:0438\:0449\:0435\:043c \:043c\:044d\:043f\:043f\:0438\:043d\:0433*)
pt=LiteRedPrintTemporary["Searching for mappings..."];
fp=Plus@@Most@FeynParUF[b1,NamingFunction->(xs&),Function->False];
If[!ValueQ[ExtUniqueSectors[b1]],ExtUniqueSectors[b1]^=NonZeroSectors[b1]];
nzs1=ExtUniqueSectors[b1];l=Length@nzs1;
If[Head[nzs1]===NonZeroSectors,Message[FindExtSymmetries::nosectors,"FindSymmetries",b1];Abort[]];
(*\:043a\:043e\:043d\:0441\:0442\:0440\:0443\:0438\:0440\:0443\:0435\:043c \:043c\:0430\:0442\:0440\:0438\:0446\:0443 \:0437\:0430\:043c\:0435\:043d\:044b \:0437\:043d\:0430\:043c\:0435\:043d\:0430\:0442\:0435\:043b\:0435\:0439*)
(*\:041f\:0440\:0435\:0434\:043f\:043e\:043b\:0430\:0433\:0430\:0435\:043c, \:0447\:0442\:043e \:0447\:0438\:0441\:043b\:043e \:043f\:0435\:0442\:043b\:0435\:0432\:044b\:0445 \:0438\:043c\:043f\:0443\:043b\:044c\:0441\:043e\:0432 \:0441\:043e\:0432\:043f\:0430\:0434\:0430\:0435\:0442 \:0438 \:0447\:0442\:043e \:0441\:043e\:0432\:043f\:0430\:0434\:0430\:044e\:0442 \:0432\:0441\:0435 \:0432\:043d\:0435\:0448\:043d\:0438\:0435 \:0438\:043c\:043f\:0443\:043b\:044c\:0441\:044b*)
(**)
ems=Replace[OptionValue[EMs],{
False:>{{}},
t:{__List}:>((*\:0417\:0434\:0435\:0441\:044c \:0434\:0435\:043b\:0430\:0435\:043c \:043f\:0440\:043e\:0432\:0435\:0440\:043a\:0443*)
If[Complement[Join@@t[[All,All,1]],ems1]=!={}||!FreeQ[t,Alternatives@@Union[lms1,lms2]]||DeleteDuplicates@Flatten[Factor[LFDistribute[sp@@@Subsets[ems1,2]-sp@@@Subsets[ems1/.#,2]]&/@t]]=!={0},
Message[FindExtSymmetries::opt,EMs->t];{{}},t]),
t_:>(Message[FindExtSymmetries::opt,EMs->t];{{}})
}];
(**)
cs=Array[Unique["c"],{Length@lms2,Length@lms2+Length@ems2}];Declare[Evaluate@Flatten@cs,Number];(*(*\:0422\:0430\:043a \:0431\:044b\:043b\:043e \:0431\:0435\:0437 ems*)dmatr=Outer[Coefficient,Toj[b2,ds1/.Thread[lms1\[Rule](cs.Join[lms2,ems2])]],Toj[b2,Append[ds2,1]]];*)
dmatr=Outer[Coefficient,Toj[b2,ds1/.Thread[lms1->(cs.Join[lms2,ems2])]/.#],Toj[b2,Append[ds2,1]]]&/@ems;
(*ds1\[Rule]dmatr.Append[ds2,1]*)
(*/*)
NotebookDelete[pt];
i=0;LiteRedMonitor[
Function[sec,
i++;jsm=sec;
(**)
pnf={#1,#2[[1,All,1]]}&@@polyNF[fp/.Thread[Pick[xs,List@@Rest@sec,0]->0],Pick[xs,List@@Rest@sec,1]];
(*after 17.06.2014*)
Catch[
(jsm=sec->First@#;
Do[
sol=Solve[0==GroebnerBasis[Flatten[dmatr[[k,Last@pnf]]-(PadRight[PadLeft[{1},#],Length@ds2+1]&/@Last@#)],Flatten[cs]],Flatten[cs]];
Function[sr,
inds=Replace[OptionValue[NamingFunction],Automatic:>$NamingFunction][Length@ds1];
matr=dmatr[[k]]/.sr;
If[(****)Factor[cds1*(matr.cds2)]===cds1,
b1/:jExtRules[Sequence@@sec]=(j[b1,##]&@@(If[#1==1,"pt"["p"[#2,Blank[]],Positive],"pt"["p"[#2,Blank[]],NonPositive]]&@@@Transpose[{List@@Rest@sec,inds}])/.{"pt"->PatternTest,"p"->Pattern})(*/lhs*):>Expand[#]&[Times@@(Toj[b2,matr.Append[Ds@b2,(*\:0415\:0434\:0438\:043d\:0438\:0446\:0430*)j[b2,Sequence@@ConstantArray[0,Length@ds1]]]]^-inds)];
AppendTo[empd,sec->First@#];
Throw[Null]]]/@sol
,{k,Length@dmatr}])&/@Cases[us2,{_,First@pnf,_}]
](*/after 17.06.2014*)
]/@nzs1,
TableForm[{"Searching for mappings",
ProgressIndicator[i,{0,l}],
jsm}]
];
If[!ValueQ[ExtMappedSectors[b1]],ExtMappedSectors[b1]^={}];
ExtMappedSectors[b1]^=SortBy[Join[ExtMappedSectors[b1],First/@empd],{Count[#,1],#}&];
If[!ValueQ[ExtSectorsMappings[b1]],ExtSectorsMappings[b1]^={}];
ExtSectorsMappings[b1]^=SortBy[Join[ExtSectorsMappings[b1],empd],{Count[#[[1]],1],#}&];
b1/:ExtSectorsMappings[b1,ns:(0|1)..]:=Cases[ExtSectorsMappings[b1],HoldPattern[js[b1,ns]->_]];
ExtUniqueSectors[b1]^=SortBy[Complement[ExtUniqueSectors[b1],First/@empd],{Count[#,1],#}&];
LiteRedPrint["Found "<>ToString[Length@empd]<>" mapped sectors.\n    ExtUniqueSectors["<>ToString[b1]<>"] \[LongDash] new sectors of the basis.\n\    ExtMappedSectors["<>ToString[b1]<>"] \[LongDash] a list of mapped sectors.\n    jExtRules["<>ToString[b1]<>",\[Ellipsis]] \[LongDash] reduction rules for j["<>ToString[b1]<>",\[Ellipsis]] from ExtMappedSectors["<>ToString[b1]<>"].\n\    ExtSectorsMappings["<>ToString[b1]<>"] \[LongDash] gives the list of mappings of all sectors from ExtMappedSectors["<>ToString[b1]<>"] to unique sectors of other bases."];
Length@empd(*Return number of mapped sectors*)
]


Options[IdentifyMIs]={IBPReduce->True,Save->False};
IdentifyMIs::usage="IdentifyMIs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] uses Feynman parametrization approach to find possible mapings between masters.\nOptions:\n    IBPReduce\[Rule]True|False:True determines whether to perform ibp reduction after mapping (since the result of the mapping is not necessarily a master)\n    Save\[Rule]True|False:False determines whether to exclude mapped master integrals from MIs[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] and to append found rules to jRules of the corresponding sector (which means they will be used in IBPReduce).";
IdentifyMIs::norules="Somehow, no rules found for the sector `1`. Skipping it.";


IdentifyMIs[nm_,OptionsPattern[]]:=Module[{jr,ibp,g,x,t,t1,p,ps,xs,mis,a,nds=Length@Ds@nm,inds,res,jsec},
{jr,ibp}={TrueQ@OptionValue@Save,TrueQ@OptionValue@IBPReduce};
{g,t,xs}=FeynParUF[nm,NamingFunction->(Array[x,{#}]&),Function->False];g=g+t/.(#->a # &/@Pick[xs,CutDs[nm],1]);
If[!ValueQ[MIs[nm]],(*message*)Return[$Failed]];
mis=Select[GatherBy[{polyNF[g/.Thread[Pick[xs,Rest[List@@#[[1,1]]],0]->0],Pick[xs,Rest[List@@#[[1,1]]],1]]/.x->(#&),Last/@#}&/@GatherBy[SortBy[{jSector@#,#}&/@MIs[nm],First],First],#[[1,1]]&],Length@#>1&];
If[mis=={},Return[{}]];
mis=MapAt[#[[-1,1]]&,mis,{All,All,1}];
res=Flatten[Function[list,p=list[[1,1]];inds=Table[Unique["n"],{Length@p}];
(**)
t=ConstantArray[0,nds];t[[p]]=inds;
(t1=ConstantArray[0,nds];t1[[#[[1]]]]=Pattern[#,Blank[]]&/@inds;Thread[#[[2]]->(FromDShifts/@(ToDShifts/@#[[2]]/.(j[nm,##]&@@t1:>j[nm,##]&@@t)))]
)&/@Rest[list]
 ]/@mis,1];
(*additional processing*)
If[ibp,
res[[All,All,2]]=IBPReduce[res[[All,All,2]]]];
If[jr,
(*Add appropriate rules, try to follow standards*)
(*Maybe I should use AddjRule here*)
(jsec=jSector[#[[1,1]]];t=jRules@@jsec;
If[Head[t]===List&&t=!={},
t1=t[[1,1,1]];
t=Join[t,((t1/;#)&[And@@Thread[Rest[List@@t1][[All,1,1]]==Rest[List@@#1]]]:>#2)&@@@#];
t1=Select[UpValues[nm],Function[sec,(#[[1]]===HoldPattern[sec]&)][jsec]/.js->jRules,1][[1]];
If[t1[[2,0]]===Get,
Put[t,t1[[2,1]]];
,
(#1/:jRules[##]=t)&@@jsec
];
LiteRedPrint["Appended "<>ToString[Length@#]<>" rules to "<>StringReplace[ToString[jsec],"js"->"jRules"]<>"."],
Message[IdentifyMIs::norules,jsec]
];
)&/@res;
t=Flatten[res[[All,All,1]]];
MIs[nm]^=jVars[Complement[MIs[nm],t],Sort->jSector];
Print["Removed "<>ToString[t]<>" from MIs["<>ToString[nm]<>"]."]
];
Flatten@res
]


AddjRule::usage="AddjRule[j[basis,0,2,\[Ellipsis]]->\[Ellipsis]] adds rule to the appropriate jRules[basis,0,1,\[Ellipsis]] list and removes j[basis,0,2,\[Ellipsis]] from MIs[basis].";
AddjRule::norules="No rules for `1` found. Doing nothing...";
AddjRule::exists="Rule for `1` already exists. Doing nothing...";
Options[AddjRule]={NamingFunction->Automatic};
SetAttributes[AddjRule,{Listable}];
AddjRule[jj:j[nm_,inds__Integer]->rhs_,OptionsPattern[]]:=Module[
{nf,jsec=jSector@jj,nmdefs=UpValues[nm],jrules,holdjRules,ivars,newjRules,prstr},
jrules=(Hold@@{jsec})/.js->jRules;
holdjRules=Position[First/@nmdefs,Verbatim@@{HoldPattern@@jrules},1];
If[holdjRules==={},
Message[AddjRule::norules,jsec];Return[$Failed]
];
(*Check that there is no rule for jj*)
If[Not[SameQ[jj,jj/.First@jrules]],
Message[AddjRule::exists,jj];Return[$Failed]
];
holdjRules=MapAt[Hold,nmdefs[[holdjRules[[1,1]]]],2][[-1]];
nf=OptionValue[NamingFunction]/.Automatic->$NamingFunction;
ivars=nf[Length@Ds@nm];
(*Construct rule*)
newjRules=Flatten@{holdjRules[[1]],Condition@@{j[nm,##]&@@MapThread[PatternTest[Pattern[#1,Blank[]],Evaluate[#2/.{1-> Positive, 0 -> NonPositive}]]&,{ivars,Rest[List@@jsec]}],
And@@Thread[ivars=={inds}]}->rhs};
(*Modify jRules and MIs*)
Switch[
holdjRules[[1,0]],
Get,Put[newjRules,holdjRules[[1,1]]],
_,TagSet@@Prepend[Append[jrules,newjRules],nm]
];
prstr="Appended rule to "<>ToString[HoldForm@@jrules]<>"].";
If[MemberQ[MIs[nm],jj],
MIs[nm]^=DeleteCases[MIs[nm],jj];
prstr=prstr<>"\nRemoved "<>ToString[jj]<>" from MIs["<>ToString[nm]<>"]"
];
LiteRed`Private`LiteRedPrint[prstr]
];


RefreshMIs::usage="RefreshMIs[js[basis,0,1,\[Ellipsis]]] updates list of masters for a given sector.\nRefreshMIs[basis] updates list of masters for UniquesSectors[basis].";


RefreshMIs::leak:="Reduction is not full: `1`."


RefreshMIs[js[nm_,inds__]]:=Module[{jRulesF,mis,ns=Table[Unique[],{Length@{inds}}],jj},
jRulesF=jRules[nm,inds];
If[Head[jRulesF]===jRules,Message[RefreshMIs::leak,js[nm,inds]];Return[$Failed]];
jRulesF=Apply[RuleDelayed,MapAt[Hold,jRulesF,{All,1}][[All,1]],{2}][[All,1]]/.{PatternTest->(#1&)};
jj=j[nm,##]&@@ns;
mis=jj/.#&/@{ToRules[LogicalExpand@Reduce[Not[Or@@(jj/.#&/@jRulesF)]]]};
If[!FreeQ[mis,Alternatives@@ns],Message[RefreshMIs::leak,js[nm,inds]];Return[$Failed]];
MIs[nm,inds]=mis;
mis
];


RefreshMIs[nm_symbol]:=RefreshMIs/@UniqueSectors[nm];


MIsHierarchyGraph::usage="MIsHierarchyGraph[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a graph of master integrals hierarchy";


Options[MIsHierarchyGraph]={Reduce->True,j->False,Legended->True};


MIsHierarchyGraph[nm_,OptionsPattern[]]:=Module[{mis=MIs[nm],misjs,unmap=SectorsMappings[nm],gt,adm,gr,vs,vr},
misjs=DeleteDuplicates@(jSector/@mis);
unmap=(Rest/@List@@@Prepend[Cases[unmap,HoldPattern[s_->#]:>s],#])&/@misjs;
gt[set1_,set2_]:=Or@@Flatten[Outer[(#2===#1*#2&&#1=!=#2)&,set1,set2,1]];
(*unmap=Sort[unmap,Not@*gtr];*)
adm=Outer[gt,unmap,unmap,1]/.{True->1,False->0};
(*assume that adm is strongly triangular*)
If[TrueQ[OptionValue[Reduce]],
adm=adm*(1-Replace[Plus@@NestWhileList[adm.#&,adm.adm,DeleteDuplicates[Flatten@#]=!={0}&],_?Positive->1,{2}])];
gr=Rule@@@Position[adm,1,{2}];
If[TrueQ[OptionValue[j]],
misjs=(MIs[#]&/@misjs);
gr=gr/.Thread[Range[Length@misjs]->(Flatten[Position[mis,Alternatives@@#,{1}]]&/@misjs)]
];
vs=Thread[Range[Length@misjs]->misjs];
If[OptionValue[Legended],{gr,vs},gr/.vs]
]


IBPReduce::usage="IBPReduce[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] performs the reduction of the \!\(\*
StyleBox[\"expr\", \"TI\"]\) applying rules found by FindSymmetries and SolvejSector";
(*DWeight::usage="DWeight\[Rule]n  is an option for IBPReduce which determines the extra priority points for each denominator.";*)


Options[IBPReduce]={jExtRules->True,jSector->_,jRules->jRules};


IBPReduce[expr_,OptionsPattern[]]:=Module[
{extrules,
dir,i=0,res,
jplist,jplist1,jlist,jsd,nd,nd1,
jlist1,lock,
rs0,rs,nrs,f,jc,jsector=Replace[js@@#,{_?Positive->1,_?NonPositive->0},{1}]&,
jsec,lsecs,hjsec,(*hjsecn,*)
jsecpat=OptionValue[jSector],
ojRules=OptionValue[jRules],
t1,t2,jrules,jrules1,jrules2,rc,
pos,mis={},
nr=0,nr1=0,level,
lvl,
status
},
(*hjsec=Sort MaximalBy*)
Block[{jRules(*Modified 02.12.2016*),jRulesDen(*/Modified 02.12.2016*)},
jRules[__]={};(*Added 02.12.2016*)jRulesDen[__]={};(*/Added 02.12.2016*)
extrules=OptionValue[jExtRules];
(*\:0441\:043e\:0437\:0434\:0430\:0451\:043c \:0440\:0430\:0431\:043e\:0447\:0443\:044e \:0434\:0438\:0440\:0435\:043a\:0442\:043e\:0440\:0438\:044e*)
While[DirectoryQ[dir="IBPReduction"<>ToString[++i]],Continue[]];CreateDirectory[dir];(*\:0441\:043e\:0431\:0438\:0440\:0430\:0435\:043c \:0432\:0441\:0435 j, \:043e\:043f\:0440\:0435\:0434\:0435\:043b\:044f\:0435\:043c \:0441\:043b\:043e\:0436\:043d\:0435\:0439\:0448\:0438\:0439 \:0441\:0435\:043a\:0442\:043e\:0440*)
CheckAbort[
jplist={#,jsector@#}&/@DeleteDuplicates@Cases[{expr},_j,\[Infinity]];
If[jplist==={},Return[expr]];
(*\:043e\:0442 \:043a\:0430\:043a\:0438\:0445 \:0441\:0435\:043a\:0442\:043e\:0440\:043e\:0432 \:0437\:0430\:0432\:0438\:0441\:0438\:0442 expr*)
jsd={"res"->DeleteDuplicates[Last/@jplist]};
Put[{1,{"res"->expr}},dir<>"/res"];
nd=Max[Count[Last@#,1]&/@jplist];
(*\:0446\:0438\:043a\:043b \:043f\:0435\:0440\:0432\:043e\:0439 \:0441\:0442\:0430\:0434\:0438\:0438*)
LiteRedMonitor[
While[jplist=!={},
(*\:043d\:0430\:0445\:043e\:0434\:0438\:043c hjsec*)
jsec=(*(*Deleted 12.07.2016*)(*Added 12.07.2016*)Cases[(*/Added 12.07.2016*)(*/Deleted 12.07.2016*)*){Count[#,1],#}&/@DeleteDuplicates[Last/@jplist](*(*Deleted 12.07.2016*)(*Added 12.07.2016*),{_,jsecpat}](*/Added 12.07.2016*)(*/Deleted 12.07.2016*)*);
(*If[jsec==={},Break[]];*)
{nd1,hjsec}=maximal@jsec;
(*hjsecn=hjsec; \[LongDash] \:043b\:0438\:0448\:043d\:044f\:044f \:043f\:0435\:0440\:0435\:043c\:0435\:043d\:043d\:0430\:044f?*)
Which[ZeroSectorQ@hjsec,
Put[{1,{Replace[j@@hjsec,{1->(_?Positive),0->(_?NonPositive)},{1}]->0}},dir<>"/"<>ToString[hjsec]];
jplist=DeleteCases[jplist,{_,hjsec}];
,
!MatchQ[hjsec,jsecpat],
Put[{0,{}},dir<>"/"<>ToString[hjsec]];
jplist=DeleteCases[jplist,{_,hjsec}],
True,
(*\:0420\:0430\:0437\:0431\:0438\:0432\:0430\:0435\:043c \:043d\:0430 \:043f\:0430\:0441\:0441\:0438\:0432\:043d\:044b\:0439 \:0441\:043f\:0438\:0441\:043e\:043a \:0438 \:0430\:043a\:0442\:0438\:0432\:043d\:044b\:0439*)
jlist=Cases[jplist,{x_,hjsec}:>x];jplist=DeleteCases[jplist,{_,hjsec}];(*\:043c\:043e\:0436\:043d\:043e \:0438\:0441\:043f\:043e\:043b\:044c\:0437\:043e\:0432\:0430\:0442\:044c SplitCases*)
(*\:041f\:0440\:0438\:0432\:043e\:0434\:0438\:043c \:0438\:043d\:0442\:0435\:0433\:0440\:0430\:043b\:044b \:0441\:043b\:043e\:0436\:043d\:0435\:0439\:0448\:0435\:0433\:043e \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
rs0={};rs={};jplist1={};
(*\:041d\:0430 \:0432\:0441\:044f\:043a\:0438\:0439 \:0441\:043b\:0443\:0447\:0430\:0439 \:043f\:0440\:043e\:0432\:0435\:0440\:044f\:0435\:043c, \:043d\:0435\:0442 \:043b\:0438 \:0444\:0430\:0439\:043b\:0430 \:0441 \:043f\:0440\:0430\:0432\:0438\:043b\:0430\:043c\:0438*)
If[FileExistsQ[dir<>"/"<>ToString[hjsec]],
(*\:043d\:0435\:0448\:0442\:0430\:0442\:043d\:0430\:044f \:0441\:0438\:0442\:0443\:0430\:0446\:0438\:044f, \:043e\:043f\:0442\:0438\:043c\:0438\:0437\:0438\:0440\:043e\:0432\:0430\:0442\:044c \:043d\:0435 \:0431\:0443\:0434\:0435\:043c, \:043f\:0440\:043e\:0441\:0442\:043e \:0437\:0430\:043d\:043e\:0432\:043e \:043f\:0435\:0440\:0435\:043f\:043e\:043b\:0443\:0447\:0438\:043c \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:0434\:043b\:044f \:0432\:0441\:0435\:0445 \:043d\:0435\:043e\:0431\:0445\:043e\:0434\:0438\:043c\:044b\:0445*)
t1=Get[dir<>"/"<>ToString[hjsec]];
jlist=DeleteDuplicates[Join[First/@Take[Last[t1],-First[t1]],jlist]]
];
(*\:041f\:043e\:043b\:0443\:0447\:0430\:0435\:043c \:043f\:0440\:0430\:0432\:0438\:043b\:0430*)
If[!extrules||Head[jrules=jExtRules@@hjsec/.PatternTest->(#1&)]===jExtRules,
jrules=(*Modified 02.12.2016*)ojRules@@hjsec/.PatternTest->(#1&)(*/Modified 02.12.2016*)
];
t1=Length@jlist;
While[jlist=!={},
nrs=Replace[jlist,jrules,{1}];
rs0=Join[jlist,rs0];rs=Join[nrs,rs];
nr+=Length@jlist;
jlist={#,jsector@#}&/@DeleteDuplicates@Cases[{nrs}/.Dispatch[Thread[rs0->0]],_j,\[Infinity]];
(*jplist1 \:0441\:043e\:0434\:0435\:0440\:0436\:0438\:0442 \:043f\:043e\:044f\:0432\:0438\:0432\:0448\:0438\:0435\:0441\:044f \:0438\:043d\:0442\:0435\:0433\:0440\:0430\:043b\:044b \:0438\:0437 \:0434\:0440\:0443\:0433\:0438\:0445 \:0441\:0435\:043a\:0442\:043e\:0440\:043e\:0432, \:0441 \:0443\:043a\:0430\:0437\:0430\:043d\:043d\:044b\:043c\:0438 \:0441\:0435\:043a\:0442\:043e\:0440\:0430\:043c\:0438*)
jplist1=Join[jplist1,DeleteCases[jlist,{_,hjsec}]];
jlist=Cases[jlist,{x_,hjsec}:>x];(*\:043c\:043e\:0436\:043d\:043e \:0438\:0441\:043f\:043e\:043b\:044c\:0437\:043e\:0432\:0430\:0442\:044c SplitCases*)
];
t2=Thread[rs0-> rs];(*\:0441\:043f\:0438\:0441\:043e\:043a \:0434\:043e\:0431\:044b\:0442\:044b\:0445 \:043f\:0440\:0430\:0432\:0438\:043b*)
mis={mis,Cases[t2,HoldPattern[x_->x_]:>x]};(*\:043c\:0430\:0441\:0442\:0435\:0440\:0430 \:043f\:043e \:043e\:043f\:0440\:0435\:0434\:0435\:043b\:0435\:043d\:0438\:044e \:043d\:0438 \:0447\:0435\:0440\:0435\:0437 \:0447\:0442\:043e \:043d\:0435 \:0432\:044b\:0440\:0430\:0436\:0430\:044e\:0442\:0441\:044f*)
Put[{t1,t2},dir<>"/"<>ToString[hjsec]];
(*t1 \[LongDash] \:0447\:0438\:0441\:043b\:043e \:043f\:0440\:0430\:0432\:0438\:043b \:0432 \:043a\:043e\:043d\:0446\:0435 \:0441\:043f\:0438\:0441\:043a\:0430 t2, \:043b\:0435\:0432\:044b\:0435 \:0447\:0430\:0441\:0442\:0438 \:043a\:043e\:0442\:043e\:0440\:044b\:0445 \:043f\:043e\:044f\:0432\:043b\:044f\:044e\:0442\:0441\:044f \:0432 \:0432\:044b\:0440\:0430\:0436\:0435\:043d\:0438\:044f\:0445 \:0438\:0437 \:0431\:043e\:043b\:0435\:0435 \:0432\:044b\:0441\:043e\:043a\:0438\:0445 \:0441\:0435\:043a\:0442\:043e\:0440\:043e\:0432.
 \:041e\:0441\:0442\:0430\:043b\:044c\:043d\:044b\:0435 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:0432 t2 \:043f\:043e\:044f\:0432\:043b\:044f\:044e\:0442\:0441\:044f \:0442\:043e\:043b\:044c\:043a\:043e \:043f\:0440\:0438 \:043f\:0440\:0438\:0432\:0435\:0434\:0435\:043d\:0438\:0438 \:0438\:043d\:0442\:0435\:0433\:0440\:0430\:043b\:043e\:0432 \:0438\:0437 \:0434\:0430\:043d\:043d\:043e\:0433\:043e \:0441\:0435\:043a\:0442\:043e\:0440\:0430.*)
(*jsd \:0432\:0441\:0435\:0433\:0434\:0430 \:0441\:043e\:0434\:0435\:0440\:0436\:0438\:0442 \:0432\:0441\:0435 \:0437\:0430\:0432\:0438\:0441\:0438\:043c\:043e\:0441\:0442\:0438*)
t1=((*{#1,FromDigits[{##2},2]}&@@@*)DeleteDuplicates[Last/@jplist1]);
(*TODO: \:0432\:0441\:0442\:0430\:0432\:0438\:0442\:044c \:043f\:0440\:043e\:0432\:0435\:0440\:043a\:0443 \:043d\:0430 \:043c\:044d\:043f\:043f\:0438\:043d\:0433 \:043f\:0440\:043e\:0442\:0438\:0432 \:0448\:0435\:0440\:0441\:0442\:0438 \:0441 \:0432\:044b\:0432\:043e\:0434\:043e\:043c \:043f\:0440\:0435\:0434\:0443\:043f\:0440\:0435\:0436\:0434\:0435\:043d\:0438\:044f*)
AppendTo[jsd,hjsec->t1];
(*\:0434\:043e\:0431\:0430\:0432\:043b\:044f\:0435\:043c \:043f\:043e\:044f\:0432\:0438\:0432\:0448\:0438\:0435\:0441\:044f \:0438\:043d\:0442\:0435\:0433\:0440\:0430\:043b\:044b*)
jplist=DeleteDuplicates@Join[jplist,jplist1];
]
],
TableForm[{{Overlay[{ProgressIndicator[nd-nd1,{0,nd}],nr},Alignment->Center]},{hjsec}}]
];
(*\:043c\:0430\:0441\:0442\:0435\:0440\:0430*)
mis=Flatten@mis;
LiteRedPrintTemporary["MIs: ",mis];
nr1=0;
(*\:0411\:0435\:0440\:0435\:043c \:0432\:0441\:0435 \:043a\:043e\:043d\:0435\:0447\:043d\:044b\:0435 \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
LiteRedMonitor[
While[jsd=!={},
(*\:041d\:0435\:0437\:0430\:0432\:0438\:0441\:0438\:043c\:044b\:0435 \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
hjsec=Dispatch[Thread[First/@jsd->0]];
hjsec=MapThread[SameQ,{#,#/.hjsec}]&@jsd[[All,2]];
hjsec=Pick[jsd,hjsec,True];
(*hjsec \[LongDash] \:0441\:043f\:0438\:0441\:043e\:043a \:0441\:0435\:043a\:0442\:043e\:0440\:043e\:0432, \:0434\:043b\:044f \:043f\:0440\:0438\:0432\:0435\:0434\:0435\:043d\:0438\:044f \:043a\:043e\:0442\:043e\:0440\:044b\:0445 \:0443\:0436\:0435 \:0432\:0441\:0451 \:0435\:0441\:0442\:044c*)
jsd=Complement[jsd,hjsec];
(*SetSharedVariable[jsec,dir];
SetSharedFunction[j,js];
jsec={};Print[hjsec];*)
((*CriticalSection[{lock},jsec=Append[jsec,#1]]*)
jsec=#1;
{t2,jrules}=Get[dir<>"/"<>ToString[#1]];(*\:041d\:0443\:043b\:0435\:0432\:044b\:0435 \:0441\:0435\:043a\:0442\:043e\:0440\:0430 \:0437\:0434\:0435\:0441\:044c \:043f\:043e\:044f\:0432\:043b\:044f\:0442\:044c\:0441\:044f \:043d\:0435 \:0434\:043e\:043b\:0436\:043d\:044b, \:0438\:043d\:0430\:0447\:0435 \:0431\:0443\:0434\:0435\:0442 \:043e\:0448\:0438\:0431\:043a\:0430*)
t2=Append[Thread[First/@Take[jrules,-t2]->True],_j->False];
(*******************************************************)
(*status="Applying rules from "<>ToString[Length@#2]<>" lower sectors";*)
jrules=jrules/.Dispatch[Join@@((Last@Get[dir<>"/"<>ToString[#]])&/@#2)];
(*status="Finished applying from lower sectors";*)
(*******************************************************)
(*\:0420\:0430\:0437\:0431\:0438\:0435\:043d\:0438\:0435 \:043d\:0430 \:0441\:0442\:0443\:043f\:0435\:043d\:0438*)
(*status="Layering sector";*)
(*\:0443\:0434\:0430\:043b\:044f\:0435\:043c \:0442\:0440\:0438\:0432\:0438\:0430\:043b\:044c\:043d\:044b\:0435 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:0434\:043b\:044f \:043c\:0430\:0441\:0442\:0435\:0440\:043e\:0432*)
jrules={0,First@#,Cases[{Last@#},_j,\[Infinity]],#}&/@DeleteCases[jrules,HoldPattern[x_->x_]];
level[_]=0;
jrules=FixedPoint[{level[#2]=1+Max[0,level/@#3],##2}&@@@#&,jrules];
Clear[level];
jrules=Map[Last,SortBy[GatherBy[jrules,First],First[First@#]&],{2}];
(*status="Finished layering sector";*)
(*\:0420\:0430\:0441\:043f\:0443\:0442\:044b\:0432\:0430\:0435\:043c \:0441\:0435\:043a\:0442\:043e\:0440*)
jrules1={};
Scan[(
(*lvl++;*)
(*status="Substituing!";*)
t1=#/.Dispatch[jrules1];
(*status="Finished substituing!";*)
(*status="Collecting!";*)
t1=(#1->Collectj[#2,Together,SimplifyAlways->False])&@@@t1;
jrules1=Join[jrules1,t1];
nr1+=Length@t1
(*status="Finished collecting!";*)
)&,
jrules
];
(*\:041e\:0441\:0442\:0430\:0432\:043b\:044f\:0435\:043c \:0442\:043e\:043b\:044c\:043a\:043e \:043f\:0440\:0430\:0432\:0438\:043b\:0430, \:043a\:043e\:0442\:043e\:0440\:044b\:0435 \:043c\:043e\:0433\:0443\:0442 \:043f\:043e\:043d\:0430\:0434\:043e\:0431\:0438\:0442\:044c\:0441\:044f \:0434\:0430\:043b\:0435\:0435. \:0414\:043e\:0432\:043e\:043b\:044c\:043d\:043e \:0447\:0435\:0440\:0435\:0437 \:0437\:0430\:0434\:043d\:0438\:0446\:0443, \:043f\:0435\:0440\:0435\:043f\:0438\:0441\:0430\:0442\:044c.*)
jrules=First/@jrules1/.t2;
Put[{Length@#,#}&@Pick[jrules1,jrules,True],dir<>"/"<>ToString[#1]];
(*CriticalSection[{lock},jsec=DeleteCases[jsec,#1]];*))&@@@hjsec;
],
TableForm[{{Overlay[{ProgressIndicator[nr1,{0,nr}],nr1},Alignment->Center]},{jsec}}]
];
res=Collectj[Get[dir<>"/res"][[-1,1,-1]],Together,SimplifyAlways->False],
res:=Abort[]
];
DeleteDirectory[dir,DeleteContents->True];
res
]]


ToMIsRule::usage = "ToMIsRule[{j[\[Ellipsis]],j[\[Ellipsis]],...}] gives a rule to pass to new master integrals.";


Options[ToMIsRule]={UseFermat->False}


ToMIsRule[jjs___j,opts:OptionsPattern[]]:=ToMIsRule[{jjs},opts];
ToMIsRule[jjs_List,OptionsPattern[]]:=Module[{nmis=jjs,l=Length[jjs],mis,mis1,rels,matr},
rels=IBPReduce[nmis];
mis=Sort[jVars[rels],Less];
matr=Outer[Coefficient,rels,mis];
If[MatrixRank@matr<l,Return[$Failed](*dependent*)];
mis1=mis;
While[
Length@matr<Length@mis,
matr=Append[matr,Coefficient[mis,First@mis1]];
If[MatrixRank@matr<Length@matr,matr=Most[matr],AppendTo[nmis,First@mis1]];
mis1=Rest@mis1;
];
Return[Collectj[Thread[mis->If[OptionValue[UseFermat],FInverse[matr],Inverse[matr]].nmis],Factor]]
]


Factor1:=Cancel[Together[#]]&
Factor2:=((Factor[Numerator[#]]/Denominator[#])&@Together[#])&
Factor3:=((Factor[Numerator[#]]/Factor[Denominator[#]])&@Together[#])&


Collectj::usage="Collectj[\[ScriptE]\[ScriptX]\[ScriptP]\[ScriptR],\[ScriptF]] collects the \[ScriptE]\[ScriptX]\[ScriptP]\[ScriptR] with respect to j[\[Ellipsis]] applying the function \[ScriptF] to the coefficient.\n\ 
Collectj[\[ScriptE]\[ScriptX]\[ScriptP]\[ScriptR]] does the same with \[ScriptF] taken from the option \"SimplifyFunction\" of Collectj.";
Collectj::nonuniform="Non-uniform term detected: `1`";
jPattern::usage="jPattern\[Rule]\!\(\*
StyleBox[\"pattern\", \"TI\"]\) is an option for Collectj and CollectjList, which determines which structures should be treated.\n\
As of version 1.0, defaults to _j, reserved mainly for possible future needs.";


Options[Collectj]^={SimplifyFunction->Factor1,SimplifyAlways->True,jPattern->_j}


Collectj[expr_List,x___]:=Collectj[#,x]&/@expr;
Collectj[expr:(_Rule|_RuleDelayed),x___]:=MapAt[Collectj[#,x]&,expr,2];
Collectj[expr_,OptionsPattern[]]:=Module[{sf,sa,freeterm,jterms,csow,jpat},
ReleaseHold[Hold[
csow[x_Plus,y_]:=csow[#,y]&/@x;
csow[x__*y_,z_]/;FreeQ[{x},jpat]:=csow[y,x*z];
csow[x:jpat,y_]:=(Sow[y,x];0);
(*csow[times[x___,y:jpat,x1___],z_]:=csow[y,x*x1*z];
csow[x_times,z_]:=csow[#2,#1*z]&@@SplitCases[Times@@x,{_?(FreeQ[#,jpat]&)}];*)
(*csow[times[x___,y_?(!FreeQ[#,jpat]&),x1___],z_]:=csow[y,x*x1*z];*)
csow[0,y_]:=0;
csow[x__?(FreeQ[#,jpat]&)*y_,z_]:=csow[y,x*z];
(*csow[times[x___?(FreeQ[#,jpat]&),y_,x1___?(FreeQ[#,jpat]&)],z_]:=csow[y,x*x1*z];*)
csow[x_,y_]:=(x*y)]/.jpat->OptionValue[jPattern]];
{sf,sa}={OptionValue@SimplifyFunction,OptionValue@SimplifyAlways};
{freeterm,jterms}=Reap[csow[expr(*/.Times\[Rule]times*),1],_j,({#1,#2})&](*/.times\[Rule]Times*);
If[freeterm=!=0,Message[Collectj::nonuniform,freeterm]];
freeterm+Plus@@(#1*If[sa,sf[Plus@@#2],If[Length@#2==1,First@#2,sf[Plus@@#2]]]&@@@jterms)];


Collectj[expr_,f_,opts:(_Rule|_RuleDelayed)...]:=Collectj[expr,SimplifyFunction->f,opts]


CollectjList::usage="CollectjList does the same as Collectj, but returns the result in the form of list {{j[\[Ellipsis]],\!\(\*
StyleBox[\"c1\", \"TI\"]\)},{j[\[Ellipsis]],\!\(\*
StyleBox[\"c2\", \"TI\"]\)},\[Ellipsis],\!\(\*
StyleBox[\"freeterm\", \"TI\"]\)}.";
CollectjList::nonuniform="Non-uniform term detected: `1`";


Options[CollectjList]^={SimplifyFunction->Factor1,SimplifyAlways->True,jPattern->_j,Sort->False}


CollectjList[expr_List,x___]:=CollectjList[#,x]&/@expr;
CollectjList[expr_,OptionsPattern[]]:=Module[{sf,sa,sort,freeterm,jterms,csow,jpat,res},
ReleaseHold[Hold[
csow[x_Plus,y_]:=csow[#,y]&/@x;
csow[x__*y_,z_]/;FreeQ[{x},jpat]:=csow[y,x*z];
csow[x:jpat,y_]:=(Sow[y,x];0);
(*csow[times[x___,y:jpat,x1___],z_]:=csow[y,x*x1*z];
csow[x_times,z_]:=csow[#2,#1*z]&@@SplitCases[Times@@x,{_?(FreeQ[#,jpat]&)}];*)
(*csow[times[x___,y_?(!FreeQ[#,jpat]&),x1___],z_]:=csow[y,x*x1*z];*)
csow[0,y_]:=0;
csow[x__?(FreeQ[#,jpat]&)*y_,z_]:=csow[y,x*z];
(*csow[times[x___?(FreeQ[#,jpat]&),y_,x1___?(FreeQ[#,jpat]&)],z_]:=csow[y,x*x1*z];*)
csow[x_,y_]:=(x*y)]/.jpat->OptionValue[jPattern]];
{sf,sa,sort}={OptionValue@SimplifyFunction,OptionValue@SimplifyAlways,OptionValue@Sort};
{freeterm,jterms}=Reap[csow[expr(*/.Times\[Rule]times*),1],_j,({#1,#2})&](*/.times\[Rule]Times*);
res=If[freeterm=!=0,Message[CollectjList::nonuniform,freeterm];Append[#,{1,freeterm}],
#]&[DeleteCases[{#1,If[sa,sf[Plus@@#2],If[Length@#2==1,First@#2,sf[Plus@@#2]]]}&@@@jterms,{_,0}]];
If[TrueQ@sort,Sort[res,Less[First@#1,First@#2]&],res]
];


CollectjList[expr_,f_,opts:(_Rule|_RuleDelayed)...]:=CollectjList[expr,SimplifyFunction->f,opts]


AttachGraph::usage="AttachGraph[js[\[Ellipsis]],{{1\[Rule]2,\"\"},{2\[Rule]3,\"M\"},\[Ellipsis]}] attaches the graph to some sector. This attachment determines also the \
graphs of the subsectors. The number of edges should be equal or greater than the number of 1s in the topology. \
The external legs should be indicated in the end of the list as {0\[Rule]n,_}.";


AttachGraph[js[nm_,x:(0|1)..],g_List]:=Module[{},
If[Length[{x}]=!=NDs[nm],Message[AttachGraph::usage];Abort[]];
If[Count[{x},1]>Length[g],Message[AttachGraph::usage];Abort[]];
nm/:jGraph[nm]=Sort[Append[DeleteCases[jGraph[nm],js[nm,x]->_],js[nm,x]->g],First[#1]<First[#2]&];
]


jGraph::usage="jGraph[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives all graphs connected with the basis.\n\
jGraph[js[\!\(\*
StyleBox[\"basis\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)]] gives the graph corresponding to the sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)].\n\
jGraph[j[\[Ellipsis]]]  gives the graph corresponding to the integral.\n\ 
Use GraphPlot[jGraph[j[\[Ellipsis]]]] to draw a graph.";
jGraph::nograph="No graph, sorry.";
jGraph::nums="The numerator is not drawn!.";


Options[jGraph]={Number->False,Label->None};


jGraph[_Symbol]:={};


jGraph[js[nm_,x:(0|1)..],OptionsPattern[]]:=Module[{graph=None,jsect=jSector[j[nm,x]],contracted,newv,tmp,edge,i=0,lab},
lab=Replace[OptionValue[Label],{None->{},o:Except[_List]:>{o}}];
If[OptionValue[Number],AppendTo[lab,Number]];
Catch[Scan[(If[jsect<=First[#],
contracted=Reverse@Sort@Flatten@Position[DeleteCases[Rest[List@@jsect+List@@First[#]],0],1,{1}];
graph=Last[#];
If[lab=!={},
MapIndexed[(graph[[First@#2,2]]={If[MemberQ[lab,Number],First@#1,Unevaluated[Sequence[]]],graph[[First@#2,2]],If[MemberQ[lab,Dot],0,Unevaluated[Sequence[]]]})&,Position[Rest[List@@First@#],1]]
];
Throw[graph]])&,
jGraph[nm]
]];
If[graph===None,Message[jGraph::nograph];Return[]];
(*Now we contract all lines*)
Scan[(graph=Function[{e,l},{e/.(graph[[#,1]]/.(DirectedEdge|UndirectedEdge)->Rule),l}]@@@Delete[graph,#])&,contracted];
graph
]


jGraph[j[{nm_,d_},x__],opts:OptionsPattern[]]:=jGraph[j[nm,x],opts];


jGraph[j[nm_Symbol,x__],OptionsPattern[]]:=Module[{graph=None,jsect=jSector[j[nm,x]],contracted,newv,tmp,edge,i=0,lab},
lab=Replace[OptionValue[Label],{None->{},o:Except[_List]:>{o}}];
If[OptionValue[Number],AppendTo[lab,Number]];
Catch[Scan[(If[jsect<=First[#],
contracted=Reverse@Sort@Flatten@Position[DeleteCases[Rest[List@@jsect+List@@First[#]],0],1,{1}];
graph=Last[#];
If[MemberQ[lab,Number],
MapIndexed[(graph[[First@#2,2]]={First@#1,graph[[First@#2,2]]})&,Position[Rest[List@@First@#],1]]
];
Throw[graph]])&,
jGraph[nm]
]
];
If[graph===None,Message[jGraph::nograph];Return[]];
(*Now we contract all lines*)
Scan[(graph=Function[{e,l},{e/.(graph[[#,1]]/.(DirectedEdge|UndirectedEdge)->Rule),l}]@@@Delete[graph,#])&,contracted];
If[MemberQ[lab,Dot],
MapIndexed[(graph[[First@#2,2]]=If[MatchQ[graph[[First@#2,2]],_List],Append[graph[[First@#2,2]],#1-1],graph[[First@#2,2]]={graph[[First@#2,2]],#1-1}])&,DeleteCases[{x},_?NonPositive]]
,
(*Now we need to put dots*)
newv=Max[Cases[graph,_Rule,\[Infinity]]/.Rule->Sequence]+1;(*unique new vertex index*)
MapIndexed[(For[tmp=#1,tmp>1,tmp--,AppendTo[graph,graph[[First[#2]]]/.{HoldPattern[Rule[v1_,v2_]]:>(Rule[newv,v2])}];
graph[[First[#2]]]=graph[[First[#2]]]/.{HoldPattern[Rule[v1_,v2_]]:>(Rule[v1,newv++])};
])&,DeleteCases[{x},_?NonPositive]]
];
If[Cases[{x},_?Negative]!={},Message[jGraph::nums]];
graph
]


todo["jGraph: make better treatment for dots and edge numbers. Maybe even to write a dedicated procedure for printing graphs."];


FeynParUF::usage="FeynParUF[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a list {\!\(\*
StyleBox[\"U\", \"TI\"]\),\!\(\*
StyleBox[\"F\", \"TI\"]\),\!\(\*
StyleBox[\"xs\", \"TI\"]\)}, where \!\(\*
StyleBox[\"U\", \"TI\"]\) and \!\(\*
StyleBox[\"F\", \"TI\"]\) are the polynomials, entering the Feynman parametrization of the integrals in the highest sector  of the basis.\nFeynParUF[js[\[Ellipsis]]] gives \!\(\*
StyleBox[\"U\", \"TI\"]\) and \!\(\*
StyleBox[\"F\", \"TI\"]\) polynomials, entering the Feynman parametrization of the integrals in the given sector, and \!\(\*
StyleBox[\"xs\", \"TI\"]\) are the Feynman parameters.\nFeynParUF[{\!\(\*
StyleBox[\"dens\", \"TI\"]\)},{\!\(\*
StyleBox[\"lms\", \"TI\"]\)}] does the same for the integrals with denominators {\!\(\*
StyleBox[\"dens\", \"TI\"]\)} and loop momenta {\!\(\*
StyleBox[\"lms\", \"TI\"]\)}.";


Options[FeynParUF]={Function->False (*Whether to present result in the form of a pure function*),NamingFunction->(Array[Symbol["x"<>ToString[#]]&,{#}]&)};


FeynParUF::valued="Parameters should all be symbols. Meanwhile, they are `1`.\nUse NamingFunction\[Rule](Table[Unique[],{#}]&) option if you want to be guaranted from this.";


FeynParUF[dsl_List,lms_List,OptionsPattern[]]:=Module[
{xs,ds=Flatten@dsl,den,t1,t2,dt2,a},
xs=Table[Unique["x"],{Length@ds}];
(*xs=OptionValue[NamingFunction][Length@ds];*)
Declare[Evaluate@xs,Number];
den=Collect[LFDistribute[xs.ds,_sp],_sp];
t1=(D[den,#]/2/.{Derivative[0,1][sp]:>(#1&),Derivative[1,0][sp]:>(#2&)})&/@lms;
t2=(D[t1,#])&/@lms;
t1=t1/.Thread[lms->0];
dt2=Factor[Det[t2]];
If[dt2==0,Return[{0,0,xs}]];
t2=Together[(dt2*den/.Thread[lms->0])-LFDistribute@Inner[sp,t1,Together[dt2*Inverse[t2]].t1,Plus]];
If[OptionValue[Function],
Function@@{{dt2,t2}/.Thread[xs->(Slot/@Range[Length@ds])]},
If[!MatchQ[xs,{__Symbol}],
Message[FeynParUF::valued,xs];{dt2,t2,Unflatten[xs,dsl]},{dt2,t2,Unflatten[xs,dsl]}/.Thread[xs->OptionValue[NamingFunction][Length@ds]]
]
]
]


FeynParUF[js[nm_,x:(1|0)...],opts:OptionsPattern[]]:=Module[
{xs,lms=LMs@nm,dsl=Pick[Ds@nm,{x},1],fp},
xs=OptionValue[NamingFunction][Count[{x},1]];If[TrueQ@CurrentState[nm,GenerateFeynParUF],
fp=FeynParUF[nm,Function->True]@@(ReplacePart[#,Thread[Flatten[Position[#,1,{1}]]->xs]]&@{x});
If[OptionValue[Function],Function@@{fp/.Thread[xs->Array[Slot,Length@xs]]},Append[fp,xs]]
,
FeynParUF[dsl,lms,NamingFunction->(xs&),opts]]
]


FeynParUF[nm_,opts:OptionsPattern[]]:=FeynParUF[Ds[nm],LMs[nm],opts]


FeynParUF[dsl_List,lms_List,{n__},opts:OptionsPattern[]]:=Module[
{(*jsec=Rest[List@@jSector[j[nm,n]]],*)
u,f,xs,r,
d=MetricTensor[],
l=Length[lms]
},
{u,f,xs}=FeynParUF[dsl,lms,Function->False,opts];
r=u^(Plus[n]-(l+1)*d/2)/f^(Plus[n]-l*d/2);
(*Numerators correspond to differentiation*)
r=(-1)^Plus@@Last/@{##} D[r,##]&@@Cases[Transpose[{xs,-{n}}],{_,_?Positive}];
(*put to zero nonpositive*)
r=r/.Thread[Pick[xs,{n},_?NonPositive]->0];
{Gamma[Plus[n]-l*d/2]/Times@@Gamma/@Cases[{n},_?Positive]*(Times@@((#1^(#2-1))&@@@(Cases[Transpose[{xs,{n}}],{_,_?(!TrueQ[NonPositive[#]]&)}])))r,Pick[xs,Not/@TrueQ/@NonPositive/@{n}]}
]


FeynParUF[j[nm_,n__],opts:OptionsPattern[]]:=FeynParUF[Ds[nm],LMs[nm],{n},opts]


GenerateFeynParUF::usage="GenerateFeynParUF[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] generates U and F polynomials for the \!\(\*
StyleBox[\"basis\", \"TI\"]\). This is to speed up the call FeynParUF[\!\(\*
StyleBox[\"basis\", \"TI\"]\)].";


GenerateFeynParUF[nm__]:=(GenerateFeynParUF/@{nm};)


GenerateFeynParUF[nm_Symbol]:=(Function[fp,(nm/:FeynParUF[nm,OptionsPattern[]]:=If[OptionValue[Function],fp,Append[fp@@#,#]&@OptionValue[NamingFunction][Length@Ds[nm]]])][FeynParUF[Ds[nm],LMs[nm],Function->True]];CurrentState[nm,GenerateFeynParUF]=True;LiteRedPrint["Polynomials U and F for basis "<>#<>" are generated.\n    FeynParUF[" <> # <>",\!\(\*
StyleBox[\"options\", \"TI\"]\)] should work faster now."] &@ToString[nm];)


GramP::usage="GramP[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives Gram polynomial G(\!\(\*SubscriptBox[
StyleBox[\"l\", \"TI\"], \(1\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"l\", \"TI\"], \(L\)]\),\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(1\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(E\)]\)) expressed in terms of denominators."


Options[GramP]={NamingFunction->(Array[ToExpression["d"<>ToString[#]]&,{#}]&),PolyNForm->False};


GramP::valued="Parameters should all be symbols. Meanwhile, they are `1`.\nUse NamingFunction\[Rule](Table[Unique[],{#}]&) option if you want to be guaranted from this.";


GramP[jsec_js,opts:OptionsPattern[]]:=Module[{poly,ds},
{poly,ds}=GramP[First@jsec,opts];
{Factor[poly/.Thread[Pick[ds,Rest@jsec,1]->0]],Pick[ds,Rest@jsec,0]}
];
GramP[nm_,OptionsPattern[]]:=Module[
{ds,qs,res},
ds=OptionValue[NamingFunction][Length@Ds[nm]];If[!MatchQ[ds,{___Symbol}],Message[GramP::valued,ds]];Declare[Evaluate@ds,Number];qs=Join[LMs[nm],EMs[nm]];
res=Det[Outer[sp,qs,qs]]/.(*Thread[SPs[nm]\[Rule]Toj[nm,SPs[nm]]*)(Toj[nm]/.{j[nm,0...]->1,j[nm,x__]:>ds[[1+LengthWhile[{x},#===0&]]]})(*]*);If[OptionValue[PolyNForm],
{PolyNForm[res,ds],ds},
{res,ds}
]
];


GramPFunction::usage="GramPFunction[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] gives a Gram polynomial G(\!\(\*SubscriptBox[
StyleBox[\"l\", \"TI\"], \(1\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"l\", \"TI\"], \(L\)]\),\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(1\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(E\)]\)) as a a pure function  of denominators."


Options[GramPFunction]={PolyNForm->False};


GramPFunction[expr_,opts:OptionsPattern[]]:=Module[{gp,ds,function},
{gp,ds}=GramP[expr,opts,NamingFunction->(Table[Unique[],{#}]&)];
Function@@{gp/.Thread[ds->Array[Slot,Length@ds]]}
]


PolySignature::usage="PolySignature[\!\(\*
StyleBox[\"poly\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\)] gives an invariant of the polynomial which does not change at any permutation of its variables.\nThe format of the output is the same as that of CoefficientRules[\!\(\*
StyleBox[\"poly\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\)], except that it is universal for any permutation of \!\(\*
StyleBox[\"vars\", \"TI\"]\).";


PolySignature[poly_,vars_]:=First@polyNF[poly,vars];


PolySignature[polys_List,vars_]:=Module[{c,cs,poly},
cs=Array[c,{Length@polys}];
poly=Collect[cs.polys,vars,Function[a,c@@(Coefficient[a,#]&/@cs)]];
PolySignature[poly,vars]/.c->List
]


PolySignaturePermutations::usage="PolySignaturePermutations[\!\(\*
StyleBox[\"poly\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\)] gives a list {\!\(\*
StyleBox[\"signature\", \"TI\"]\),\!\(\*
StyleBox[\"permutations\", \"TI\"]\)}. See ?PolySignature for the explanation of the first element. Second element gives permutations of the variables which leave polynomial invariant."


PolySignaturePermutations[poly_,vars_]:=polyNF[poly,vars]/.Thread[vars->Range[Length@vars]];


PolySignaturePermutations[polys_List,vars_]:=Module[{c,cs,poly},
cs=Array[c,{Length@polys}];
poly=Collect[cs.polys,vars,Function[a,c@@(Coefficient[a,#]&/@cs)]];
PolySignaturePermutations[poly,vars]/.c->List
]


PolyNForm::usage="PolyNForm[\!\(\*
StyleBox[\"poly\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\)] permutes the variables to some canonical order, \
so that if two polynomials \!\(\*
StyleBox[\"poly1\", \"TI\"]\) and \!\(\*
StyleBox[\"poly2\", \"TI\"]\) are equivalent up to notations, then PolyNForm[\!\(\*
StyleBox[\"poly1\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\)]===PolyNForm[\!\(\*
StyleBox[\"poly2\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\)].\n\
PolyNForm->True is also an option for FeynParUF, which results in normal form naming of the Feynman parameters.";


PolyNForm[poly_,vars_]:=poly/.Thread[(*polyNF[poly,vars]\[LeftDoubleBracket]1,2,All,1\[RightDoubleBracket]*)polyNF[poly,vars][[-1,1]]->vars];


PolyMapToSignature::usage="PolyMapToSignature[\!\(\*
StyleBox[\"poly\", \"TI\"]\),\!\(\*
StyleBox[\"vars\", \"TI\"]\),{\!\(\*
StyleBox[\"coefs\", \"TI\"]\),{\!\(\*
StyleBox[\"ind1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"ind2\", \"TI\"]\)\[Ellipsis]},\!\(\*
StyleBox[\"b\", \"TI\"]\)}] tries to find a correspondance \!\(\*
StyleBox[\"vars\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\){\!\(\*
StyleBox[\"ind1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"ind2\", \"TI\"]\)\[Ellipsis]} for which \!\(\*
StyleBox[\"poly\", \"TI\"]\) has an invariant {\!\(\*
StyleBox[\"coefs\", \"TI\"]\),{\!\(\*
StyleBox[\"ind1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"ind2\", \"TI\"]\)\[Ellipsis]},\!\(\*
StyleBox[\"b\", \"TI\"]\)}";


PolyMapToSignature[p_,vars_,{coefs1_List,inds_List,b1_Integer}]:=If[#==={},$Failed,#[[1,2]]]&[polyMapToSig[p,vars,{coefs1,inds,b1}]];


todo["implement inverse of PolySignature"];


FactorizeFP::usage="FactorizeFP[\!\(\*
StyleBox[\"U\", \"TI\"]\),\!\(\*
StyleBox[\"F\", \"TI\"]\),\!\(\*
StyleBox[\"xs\", \"TI\"]\)] tries to find factorization of the integrals into  the integrals with fewer loops. \!\(\*
StyleBox[\"U\", \"TI\"]\) and \!\(\*
StyleBox[\"F\", \"TI\"]\) are the polynomials, entering the Feynman parametrization.\nThe result is of the form {{\!\(\*SubscriptBox[
StyleBox[\"U\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"F\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"xs\", \"TI\"], \(1\)]\)},{\!\(\*SubscriptBox[
StyleBox[\"U\", \"TI\"], \(2\)]\),\!\(\*SubscriptBox[
StyleBox[\"F\", \"TI\"], \(2\)]\),\!\(\*SubscriptBox[
StyleBox[\"xs\", \"TI\"], \(2\)]\)},\[Ellipsis]}, such that\n  1. \!\(\*SubscriptBox[
StyleBox[\"xs\", \"TI\"], \(i\)]\)\[Intersection]\!\(\*SubscriptBox[
StyleBox[\"xs\", \"TI\"], \(j\)]\)=\[EmptySet], \!\(\*UnderscriptBox[\(\[Union]\), \(i\)]\)\!\(\*SubscriptBox[
StyleBox[\"xs\", \"TI\"], \(i\)]\)=\!\(\*
StyleBox[\"xs\", \"TI\"]\),\n  2. \!\(\*
StyleBox[\"U\", \"TI\"]\)=\!\(\*UnderscriptBox[\(\[Product]\), \(i\)]\)\!\(\*SubscriptBox[
StyleBox[\"U\", \"TI\"], \(i\)]\).\n  3. \!\(\*
StyleBox[\"F\", \"TI\"]\)=\!\(\*UnderscriptBox[\(\[Sum]\*SubscriptBox[
StyleBox[\"F\", \"TI\"], \"i\"]\), \(i\)]\)\!\(\*UnderscriptBox[\(\[Product]\), \(j \[NotEqual] i\)]\)\!\(\*SubscriptBox[
StyleBox[\"U\", \"TI\"], \(i\)]\).";


FactorizeFP::form="Unexpected form of `1` polynomial. No factorization is done.";


FactorizeFP[{U_,F_,xs_}]:=FactorizeFP[U,F,xs]


FactorizeFP[U_,F_,xs_]:=Module[
{L,a,ufl=FactorList[U],c,ublist,l,ut,un,fn,ln,vars,nlist,plist={},llist={},res},
(*L \[LongDash] number of loops*)
L=Exponent[U/.Thread[xs->a xs],a];
(*check homogeneity of U*)
If[!FreeQ[Factor[(U/.Thread[xs->a xs])/a^L],a],Message[FactorizeFP::form,"U"];Return[{{U,F,xs}}]];
(*check homogeneity of F*)
If[!FreeQ[Factor[(F/.Thread[xs->a xs])/a^(L+1)],a],Message[FactorizeFP::form,"F"];Return[{{U,F,xs}}]];
(*U should be the sum of monomials with unit coefficients*)
{c,ublist}=SplitCases[Power@@@ufl,{_?(FreeQ[#,Alternatives@@xs]&)}];
c=Times@@c;
If[c=!=1||Sort[Join@@(Variables/@ublist)]=!=Sort[xs],Message[FactorizeFP::form,"U"];Return[{{U,F,xs}}]];
l=Length@ublist;
nlist=SortBy[Range[2^l-1],{Count[IntegerDigits[#,2],1],#}&];
Catch[Scan[Function[n,
ut=Times@@Pick[ublist,IntegerDigits[n,2,l],0];
vars=Variables@ut;
ln=Exponent[ut/.Thread[vars->a vars],a];
fn=Coefficient[F/.Thread[vars->a vars],a,ln];
fn=Cancel[fn/ut];
If[FreeQ[fn,Alternatives@@vars],
(*test passed*)
un=Times@@Pick[ublist,IntegerDigits[n,2,l],1];
AppendTo[llist,{un,fn,DeleteCases[xs,Alternatives@@vars]}];
AppendTo[plist,n];
res=fds[Most@plist,n,l];
If[res=!={},Throw[True]]
]
],nlist];0];
Pick[llist,plist,Alternatives@@res]
]


FactorizejSector::usage="FactorizejSector[js[\!\(\*
StyleBox[\"b\", \"TI\"]\),(0|1)\[Ellipsis]]] tries to find factorization of the integrals of the sector into the integrals with fewer loops. \nThe result is of the form {{(0|1)\[Ellipsis]},\[Ellipsis]}. Each element of this list indicates the denominators which form the lower loop integral.";


FactorizejSector[jjs_js]:=Module[{l=Flatten[Position[Rest[List@@jjs],1,{1}]],U,F,xs,xsl},
{U,F,xs}=FeynParUF[jjs];
xsl=Alternatives@@@Last/@FactorizeFP[U,F,xs];
Reverse[IntegerDigits[Plus@@(2^(Pick[l,xs,#]-1)),2,Length@jjs-1]]&/@xsl
]


LoweringDRR::usage="LoweringDRR[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]] gives a dimensional recurrence lowering the dimension of the integral. 
The result is the expression of j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]] in d+2 dimensions via the integrals in d dimensions.\n\
The loop integration measure is chosen as \!\(\*SuperscriptBox[\(d\), \(d\)]\)l/\!\(\*SuperscriptBox[\(\[Pi]\), \(d/2\)]\).";


LoweringDRR[nm_Symbol,inds__]:=Module[{lms=LMs@nm,l,ems=EMs@nm,e,v,d=MetricTensor[]},
l=Length@lms;e=Length@ems;
v=If[e==0,1,Det[Outer[sp,EMs@nm,EMs@nm]]];
2^l/(v Pochhammer[d-e-l+1,l])*Expand[j[nm,inds]*(Det[Outer[sp,Join[lms,ems],Join[lms,ems]]]/.Toj[nm])]
]


RaisingDRR::usage="RaisingDRR[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]] gives a dimensional recurrence raising the dimension of the integral. 
The result is the expression of j[\!\(\*
StyleBox[\"basis\", \"TI\"]\),n1,n2,\[Ellipsis]] in d-2 dimensions via the integrals in d dimensions.\n\
The loop integration measure is chosen as \!\(\*SuperscriptBox[\(d\), \(d\)]\)l/\!\(\*SuperscriptBox[\(\[Pi]\), \(d/2\)]\).";


RaisingDRR[nm_Symbol,inds__]:=Module[{l=Length@LMs@nm,dim=Length@Ds[nm],al,i,k,\[Beta]s,\[Beta]s1,a},
al=Array[a,{dim}];
Expand[Det[Table[(If[i==k,1,1/2]*Coefficient[#,sp[LMs[nm][[i]],LMs[nm][[k]]]]&/@LFDistribute[Ds[nm]]).al,{i,l},{k,l}]]*j[nm,inds]]
//.{a[i_]^k_.*j[nm,\[Beta]s__]:>(\[Beta]s1={\[Beta]s};\[Beta]s1[[i]]+=k;Pochhammer[{\[Beta]s}[[i]],k]j[nm,##]&@@\[Beta]s1)}
];


LowerDim::usage="LowerDim[{\!\(\*
StyleBox[\"basis\", \"TI\"]\),d},n1,n2,\[Ellipsis]] expresses j[{\!\(\*
StyleBox[\"basis\", \"TI\"]\),d},n1,n2,\[Ellipsis]] via integrals j[{\!\(\*
StyleBox[\"basis\", \"TI\"]\),d-2},\[Ellipsis]].";


LowerDim[{nm_,d_},inds__]:=Module[{lms=LMs@nm,l,ems=EMs@nm,e,v},
l=Length@lms;e=Length@ems;
v=If[e==0,1,Det[Outer[sp,EMs@nm,EMs@nm]]];
2^l/(v Pochhammer[d-e-l(*Modified*)-1(*/Modified*),l])*Expand[j[nm,inds]*(Det[Outer[sp,Join[lms,ems],Join[lms,ems]]]/.Toj[nm])]/.{j[nm,x__]:>j[{nm,d-2},x] }
]


RaiseDim::usage="RaiseDim[{\!\(\*
StyleBox[\"basis\", \"TI\"]\),d},n1,n2,\[Ellipsis]] expresses j[{\!\(\*
StyleBox[\"basis\", \"TI\"]\),d},n1,n2,\[Ellipsis]] via integrals j[{\!\(\*
StyleBox[\"basis\", \"TI\"]\),d+2},\[Ellipsis]].";


RaiseDim[{nm_,d_},inds__]:=Module[{l=Length@LMs@nm,dim=Length@Ds[nm],al,i,k,\[Beta]s,\[Beta]s1,a},
al=Array[a,{dim}];
Expand[Det[Table[(If[i==k,1,1/2]*Coefficient[#,sp[LMs[nm][[i]],LMs[nm][[k]]]]&/@LFDistribute[Ds[nm]]).al,{i,l},{k,l}]]*j[nm,inds]]
//.{a[i_]^k_.*j[nm,\[Beta]s__]:>(\[Beta]s1={\[Beta]s};\[Beta]s1[[i]]+=k;Pochhammer[{\[Beta]s}[[i]],k]j[nm,##]&@@\[Beta]s1)}/.{j[nm,x__]:>j[{nm,d+2},x] }
];


Dinv::usage="Dinv[\!\(\*
StyleBox[\"expr\", \"TI\"]\),p\[CenterDot]q] is the differentiation of \!\(\*
StyleBox[\"expr\", \"TI\"]\) with respect to p\[CenterDot]q. It assumes, that other scalar products of the external momenta are constants. \
Pay attention that p\[CenterDot]q and q\[CenterDot]p is not exactly the same in the second argument. If p\[CenterDot]q is used, the derivative of j[...] is expressed in terms of \[PartialD]/\[PartialD]p.\n\
Explicit scalar functions of p\[CenterDot]q are differentiated correctly, unless p\[CenterDot]q is evaluated to something.\nDinv[\!\(\*
StyleBox[\"expr\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the derivative of \!\(\*
StyleBox[\"expr\", \"TI\"]\) with respect to the variable \!\(\*
StyleBox[\"x\", \"TI\"]\).";


SetAttributes[Dinv,{HoldAll}];


Dinv[j1_j,sp[(p_?VecVarQ),(q_?VecVarQ)]]:=Module[{pq,em,nm,djdp(*,ps*)},
nm=First@j1;(*ps=Times@@(Ds[nm]^PowerShifts[nm]);*)
em=DeleteDuplicates[Join[{p,q},EMs@nm]];
djdp=(D[fromjps[j1],p]/.{Derivative[1,0][sp][a_,b_]:>b,Derivative[0,1][sp][a_,b_]:>a});
tojps[nm,If[p=!=q,1,1/2]*(sp[#,djdp]&/@em).Inverse[Outer[sp,em,em]].D[em,q]]
]


Dinv[expr_,sp[(p_?VecVarQ),(q_?VecVarQ)]]:=Module[{pq,em,nm,j1},
D[LFDistribute[expr,sp]/.sp[p,q]->pq,pq,NonConstants->jVars[expr]]/.
{HoldPattern[D[j1_j,pq,NonConstants->{___,j1_,___}]]:>Dinv[j1,sp[p,q]]}/.pq->sp[p,q]
]


Dinv[expr_,s_Symbol]:=Module[{ems,ps},
ems=Union@@EMs/@Union[First/@jVars[expr]];
D[expr,s,NonConstants->jVars[expr]]/.HoldPattern[D[jj_j,s,NonConstants->_]]:>(tojps[First@jj,(D[LFDistribute[fromjps[jj],sp],s]/.{})]+Plus@@(dinv[jj,sp[##]]*D[sp[##],s]&@@@Replace[Subsets[ems,{1,2}],{x_}:>{x,x},{1}]))
];


SetAttributes[dinv,{HoldAll}];


dinv[j1_j,sp[(p_?VecVarQ),(q_?VecVarQ)]]:=Module[{pq,em,nm,djdp},
nm=First@j1;
em=DeleteDuplicates[Join[{p,q},EMs@nm]];
djdp=(D[LFDistribute[fromjps[j1],sp],p]/.{Derivative[1,0][sp][a_,b_]:>b,Derivative[0,1][sp][a_,b_]:>a});
tojps[nm,If[p=!=q,1,1/2]*(sp[#,djdp]&/@em).Inverse[Outer[sp,em,em]].D[em,q]]
]


fromjps[jj_]:=Fromj[jj]/Times@@(Ds[First[jj]]^PowerShifts[First[jj]])
tojps[nm_,jj_]:=Toj[nm,Factor[Times@@(Ds[nm]^PowerShifts[nm])*jj]]


ToDShifts::usage="ToDShifts[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] gets rid of numerators in \!\(\*
StyleBox[\"expr\", \"TI\"]\) at the expense of shifts of dimension. The result is a list {d-dimensional part,(d+2)-dimensional part with the replacement d\[Rule]d-2,(d+4)-dimensional part with the replacement d\[Rule]d-4,\[Ellipsis]}.\nSuch a form allows one to make a reduction prior to 'inverse' operator FromDShifts.";
ToDShifts::list="Assuming d-shifted list.";


ToDShifts[expr_List]:=(Message[ToDShifts::list];Quiet[plusFlatten[ToDShifts/@expr]]);
ToDShifts[expr_]:=Module[{
d=MetricTensor[],
s=0,t,r
},
r=Function[{jj,c},t=MapIndexed[(#1(c/.(d->d-2*First@#2+2)))&,todshifts[jj]];s=Max[s,Length@t];t]@@@CollectjList[expr];
Collectj[Plus@@(PadRight[#,s]&/@r)]
];


todshifts[jj:j[nm_Symbol,inds__Integer]]:=Module[
{
\[Nu]=MetricTensor[]/2,
L=Length@LMs@nm,
ninds,xs,nxs,ns,
G,gradG,
Plist
},
(*first, check if there is a need for the shift*)
xs=Table[Unique["x"],{Length@Ds@nm}];
ninds=Cases[{inds},_?Negative];
If[ninds=={},Return[{jj}]];
nxs=Pick[xs,{inds},_?Negative];(*don't forget about zero indices!*)
G=Plus@@FeynParUFFunction[nm]@@xs;
gradG=D[G,#]&/@nxs;
Plist={1};
MapIndexed[(Do[Plist=Prepend[Plist*gradG[[First@#2]],0]-Append[D[Plist,nxs[[First@#2]]],0],{-#1}])&,ninds];
(*a list of A-operators, should be untilded though*)
Plist=CoefficientRules[Rest@Plist/.Thread[Pick[xs,{inds},_?NonPositive]->0],xs];
ns=Replace[{inds},{_?Negative->0},{1}];
Prepend[MapIndexed[Function[{r,k},Plus@@((#2*(Pochhammer[(\[Nu]-First@k)(L+1)-Plus[inds],First@k*(L+1)-Plus@@#1+Plus@@ninds])*(Times@@Pochhammer[ns,#1])(j[nm,##]&@@(ns+#1)))&@@@r)],Plist],0]
];


FromDShifts::usage="FromDShifts[\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[\"expr0\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"expr1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"expr2\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\[Ellipsis]}] uses LoweringDRR to combine pieces from shifted dimensions. Up to the reduction, this operation is inverse of ToDShifts.";


FromDShifts[expr_List]:=Module[{d=MetricTensor[]},
Fold[Collectj[(#/.d->d+2/.j->LoweringDRR)+#2,Factor]&,0,Reverse@expr]
]


FeynParGdG::usage="FeynParGdG[basis] gives {G,grad(G)} as a pure function";


FeynParGdG[nm_]:=(FeynParGdG[nm]^=Module[{u,f,xs},
{u,f,xs}=FeynParUF[nm,NamingFunction->(Table[Unique[],{#}]&),Function->False];
Function@@{{u+f,D[u+f,#]&/@xs}/.Thread[xs->Array[Slot,Length@xs]]}])


NumeratorsToDShifts::usage="NumeratorsToDShifts[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] gets rid of numerators in \!\(\*
StyleBox[\"expr\", \"TI\"]\) at the expense of shifts of dimension.";


NumeratorsToDShifts[expr_]:=Collectj[expr/.{jj_j:>numtodshifts@@jj}];


numtodshifts[a_,inds__Integer]:=Module[
{
nm,d,
L,
ninds,xs,nxs,ns,
G,gradG,
Plist
},
{nm,d}=Replace[a,_Symbol:>{a,MetricTensor[]}];
L=Length@LMs@nm;
(*first, check if there is a need for the shift*)
xs=Table[Unique["x"],{Length@Ds@nm}];
ninds=Cases[{inds},_?Negative];
If[ninds=={},Return[j[{nm,d},inds]]];
nxs=Pick[xs,{inds},_?Negative];(*don't forget about zero indices!*)
(*G=Plus@@FeynParUFFunction[nm]@@xs;
gradG=D[G,#]&/@nxs;*)
{G,gradG}=FeynParGdG[nm]@@xs;
gradG=Pick[gradG,{inds},_?Negative];
Plist={1};
MapIndexed[(Do[Plist=Prepend[Plist*gradG[[First@#2]],0]-Append[D[Plist,nxs[[First@#2]]],0],{-#1}])&,ninds];
(*a list of A-operators, should be untilded though*)
Plist=CoefficientRules[Rest@Plist/.Thread[Pick[xs,{inds},_?NonPositive]->0],xs];
ns=Replace[{inds},{_?Negative->0},{1}];
Plus@@MapIndexed[Function[{r,k},Plus@@((#2*(Pochhammer[(d/2)(L+1)-Plus[inds],First@k*(L+1)-Plus@@#1+Plus@@ninds])*(Times@@Pochhammer[ns,#1])(j[{nm,d+2*First@k},##]&@@(ns+#1)))&@@@r)],Plist]
];


FindSymmetriesDen::usage="FindSymmetriesDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] finds the denominators symmetries of the sectors of \!\(\*
StyleBox[\"basis\", \"TI\"]\). It generates the following objects:\n    UniqueSectorsDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of unique sectors,\n    MappedSectorsDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of sectors, equivalent to some unique sectors,\n    jRulesDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] for each sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in MappedSectorsDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of rules mapping integrals to some unique sector,\n    jSymmetriesDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)\!\(\*
StyleBox[\":\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)\!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"1\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"..\", \"TI\"]\)] for each sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] in UniqueSectorsDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] \[LongDash] the list of rules mapping unique sector onto itself,\n\nNote that FindSymmetriesDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] requires running FindSymmetries[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] beforehand and considers only sectors in UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)], generated by FindSymmetries.";
UniqueSectorsDen::usage="UniqueSectorsDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of unique sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\), with respect to mapping of denominators, i.e., those sectors in UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] onto which all other sectors UniqueSectors[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] can be mapped (those are gathered in MappedSectorsDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\)]).";
MappedSectorsDen::usage="MappedSectorsDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] is the list of sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\) which can be mapped onto the UniqueSectorsDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\)].";
jRulesDen::usage="jRulesDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] gives the reduction rule(s) for the integrals without numerators in a given sector.";
jSymmetriesDen::usage="jSymmetriesDen[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\):(0|1)..] gives the list of rules mapping the integrals without numerators in unique sector js[\!\(\*
StyleBox[\"basis\", \"TI\"]\),\!\(\*
StyleBox[\"ns\", \"TI\"]\)] onto themselves.";


Options[FindSymmetriesDen]={NamingFunction->Automatic(*,jsOrderingFunction\[Rule]Identity*)};
FindSymmetriesDen[nm_,OptionsPattern[]]:=Module[{i,mon="",jsecs,x,g,t,xs,a,inds,jj,ptrnrule,ujs,mjs,uss={},mss={},d=MetricTensor[]},
inds=Replace[OptionValue[NamingFunction],Automatic:>$NamingFunction][Length@Ds@nm];
jj=0&/@inds;

LiteRedPrintTemporary["Constructing Feynman parametrization..."];
{g,t,xs}=FeynParUF[nm,NamingFunction->(Array[x,{#}]&),Function->False];g=g+t/.(#->a # &/@Pick[xs,CutDs[nm],1]);
LiteRedPrintTemporary["Using Feynman parametrization to determine equivalent sectors..."];
jsecs=UniqueSectors[nm];t=Length@NonZeroSectors@nm;
LiteRedMonitor[i=0;
jsecs=(i++;polyNF[g/.Thread[Pick[xs,Rest[List@@#],0]->0],Pick[xs,Rest[List@@#],1]]/.x->Identity)&/@jsecs,
ProgressIndicator[i,{0,t}]
];
LiteRedPrintTemporary["Grouping equivalent sectors..."];
jsecs=GatherBy[jsecs,First][[All,All,2]];
LiteRedPrintTemporary["Constructing shifts for all unique sectors..."];
LiteRedMonitor[i=0;t=Length@jsecs;
Scan[Function[l,i++;
mon=ujs=js[nm,##]&@@ReplacePart[jj,Thread[First@First@l->1]];
AppendTo[uss,ujs];
nm/:jSymmetriesDen[Sequence@@ujs]={(j[(*Added 23.11.2016*)nm(*/Added 23.11.2016*)(*(*Deleted 23.11.2016*){nm,Pattern[#,Blank[]]&@d}(*/Deleted 23.11.2016*)*),##]&@@ReplacePart[jj,Thread[#->(\!\(\*
TagBox[
StyleBox[
RowBox[{"PatternTest", "[", 
RowBox[{
RowBox[{"Pattern", "[", 
RowBox[{"#", ",", 
RowBox[{"Blank", "[", "]"}]}], "]"}], ",", "Positive"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)&/@inds[[#]])]])->(j[(*Added 23.11.2016*)nm(*/Added 23.11.2016*)(*(*Deleted 23.11.2016*){nm,d}(*/Deleted 23.11.2016*)*),##]&@@ReplacePart[jj,Thread[First@First@l->inds[[#]]]])}&/@ First[l];
(mon=ujs\[LeftArrow](mjs=(js[nm,##]&@@ReplacePart[jj,Thread[#->1]]));AppendTo[mss,mjs];
nm/:jRulesDen[Sequence@@mjs]=(*Added 23.11.2016*){
(j[nm,##]&@@ReplacePart[jj,Thread[#->(\!\(\*
TagBox[
StyleBox[
RowBox[{"PatternTest", "[", 
RowBox[{
RowBox[{"Pattern", "[", 
RowBox[{"#", ",", 
RowBox[{"Blank", "[", "]"}]}], "]"}], ",", "Positive"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)&/@inds[[#]])]])->(j[nm,##]&@@ReplacePart[jj,Thread[First@First@l->inds[[#]]]])}(*/Added 23.11.2016*)(*(*Deleted 23.11.2016*){
ptrnrule=Inner[#1\[Rule]Pattern[#1,_]?#2&,inds,(Rest[List@@mjs]/.{1\[Rule]Positive,0\[Rule]NonPositive}),List];
((#1/.ptrnrule/.{d\[Rule]Pattern[#,Blank[]]&@d})/;#2\[RuleDelayed]NumeratorsToDShifts[#1])&[j[{nm,d},##]&@@inds,Or@@Thread[Pick[inds,Rest[List@@mjs],0]\[NotEqual]0]],
(j[{nm,Pattern[#,Blank[]]&@d},##]&@@ReplacePart[jj,Thread[#\[Rule](PatternTest[Pattern[#,Blank[]],Positive]&/@inds[[#]])]])->(j[{nm,d},##]&@@ReplacePart[jj,Thread[First@First@l\[Rule]inds[[#]]]])}(*/Deleted 23.11.2016*)*))&/@ Rest[First/@l]],
jsecs];
Scan[(mon=""\[LeftArrow](mjs=#);i++;AppendTo[mss,mjs];
nm/:jRulesDen[Sequence@@mjs]=MapAt[(#1/.d->(Pattern[#,Blank[]]&@d))&,(jRules[Sequence@@mjs](*/.j[nm,inds__]\[Rule]j[{nm,d},inds]*)),1])&,
MappedSectors@nm],
TableForm[{{ProgressIndicator[i,{0,t}]},{mon}}]
];

UniqueSectorsDen[nm]^=SortBy[uss,{Count[#,1],#}&];
MappedSectorsDen[nm]^=SortBy[mss,{Count[#,1],#}&];
LiteRedPrintTemporary["Saving definitions..."];
If[Not@TrueQ@Not@BasisDirectory[nm],Quiet[DiskSave[nm,Save->"Basis"]]];LiteRedPrint["Found "<>ToString[Length@MappedSectorsDen@nm]<>" mapped sectors and "<>ToString[Length@UniqueSectorsDen@nm]<>" unique sectors.\n\    UniqueSectorsDen["<>ToString[nm]<>"] \[LongDash] unique sectors.\n\    MappedSectorsDen["<>ToString[nm]<>"] \[LongDash] mapped sectors.\n\    jSymmetriesDen["<>ToString[nm]<>",\[Ellipsis]] \[LongDash] symmetry rules for the sector js["<>ToString[nm]<>",\[Ellipsis]] in UniqueSectorsDen["<>ToString[nm]<>"].\n\    jRulesDen["<>ToString[nm]<>",\[Ellipsis]] \[LongDash] reduction rules for j["<>ToString[nm]<>",\[Ellipsis]] from MappedSectorsDen["<>ToString[nm]<>"]."];
]


SolvejSectorDen::usage="SolvejSectorDen[\!\(\*
StyleBox[\"sector\", \"TI\"]\):js[\[Ellipsis]]] tries to find symbolic rules for the reduction of the integrals without numerators in the \!\(\*
StyleBox[\"sector\", \"TI\"]\).\n\
Options:\n\
    NamingFunction\[Rule]Function[\[Ellipsis]]|Automatic:Automatic, see ?NamingFunction;\n\
    Depth\[Rule]_Integer:2, the Depth of the heuristic search. If the search did not succeeded in reducing the sector to a finite number of integrals, search depth is incereased automatically;\n\
    NMIs\[Rule]n:0, expected number of master integrals. If the number of the integrals left is less or equal to n, the program terminates assuming those integrals are masters, which may save some time.\n\
    MIs\[Rule]{\[Ellipsis]}:{}, expected masters in the sector.\n\ 
    SR\[Rule]False|True:True determines whether the symmetry relations should be used on the last step;\n\
    DiskSave\[Rule]True|False|\!\(\*
StyleBox[\"directory\", \"TI\"]\):False determines whether to save the found rules on the disk.";
NumDepth::usage="NumDepth is an option of SolvejSectorDen, determining the highest possible sum of the numerators indices in the search of the reductrion rules.";


SolvejSectorDen::leak="Discrepancy detected. Reduction is not full: `1`.";


Options[SolvejSectorDen]={NamingFunction->Automatic,
Depth->2(*\:0433\:043b\:0443\:0431\:0438\:043d\:0430 \:043f\:043e\:0438\:0441\:043a\:0430*),
Numerator->0,
NumDepth->\[Infinity],
SR->True(*\:0438\:0441\:043f\:043e\:043b\:044c\:0437\:043e\:0432\:0430\:0442\:044c \:0441\:043e\:043e\:0442\:043d\:043e\:0448\:0435\:043d\:0438\:044f \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0438?*),
NMIs->-1,
(*UseRules\[Rule]False,*)
DiskSave->True(*\:0421\:043e\:0445\:0440\:0430\:043d\:044f\:0442\:044c \:043d\:0430\:0439\:0434\:0435\:043d\:043d\:044b\:0435 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:043d\:0430 \:0434\:0438\:0441\:043a\:0435?*),
DiskRecover->False,
Replace->True,
TimeConstrained->False,
CheckZeroFunction->Factor2,
CheckZeroAlways->True,
SimplifyFunction->Factor2,
SimplifyAlways->False,
SubstituteAlways->False
};
SolvejSectorDen::parse="Could not parse `1`.";
SolvejSectorDen::dim="Please, set dimension to be a symbol. Use SetDim[\[Ellipsis]]. Aborting...";


SolvejSectorDen[sects_List,opts:OptionsPattern[]]:=SolvejSectorDen[#,opts]&/@sects


SolvejSectorDen[sect_js,OptionsPattern[]]:=Block[{jComplexity},
SetAttributes[jComplexity,Listable];
jComplexity[j[nm_,n__]]:=Module[
{jsec0=jSector@nm,jsec,jsec1,
jsorder,num},
If[Head[jsec0]=!=js,Message[jSector::jtop,nm];Abort[]];
jsec0=Rest[List@@jsec0];
{jsec1,jsec}=Transpose[Replace[Transpose[{{n},jsec0}],{x_Integer,_}:>{x,Boole[Positive[x]]},{1}]];
(*added 19.07.2014*)jsec0=FromDigits[jsec,2];(*/added 19.07.2014*)
jsorder=jsOrder[nm,##]&@@jsec;
If[MatrixQ[jsorder],
jsorder[[2]]=jsorder[[1]]*(jsec);
jsorder[[1]]=jsorder[[1]]*(1-jsec);(*only numerators*)
Return[{nm,Plus@@jsec,jsec0,Sequence@@(jsorder.jsec1)}]
,
(*DEPRECATED branch*)
jsorder=PadLeft[jsorder,Length@{n}+1,1];(*just in case*)
num=First@jsorder;jsorder=Rest[jsorder];
{jsec1,jsec}={permute[jsec1,jsorder],permute[jsec,jsorder]};
Return[{nm,Plus@@jsec,jsec0,Plus@@(#*(1-jsec)),-num*#.jsec,Sequence@@(-#)}&[jsec1*(2 jsec-1)]]
(*/DEPRECATED branch*)
]
];
jComplexity[j1_j,j2_j]:=Expand[jComplexity@j1-jComplexity@j2];
Module[{(*debug,*)sec=List@@Rest@sect,dim=Length@sect-1,rsrvd=False,inds,scond,numcond,indication$numberOfPoints=0,indication$numberOfPointsToGo=0,n=0,pds,nds,sec1,List$signs,indication$outputToDelete={},mis={},nmis,nm=First@sect,Bool$numericIndices,secS=ToString[HoldForm[jRulesDen[##]]&@@sect],NoRules={{}},nrordrd,FoundRules={},params,d=MetricTensor[],ndepth,ids,rules1,rules2,startp,pat1,ptrnrule,jRules1,jRulesF,jRulesDB,pos,searchDepth,useSR,sr,recover,continue,mir,nr,fr,tcnd,ds,dr,onmis,tc,tcf,sjopts,whenBad,smartReduce,smartReduce1,eqr,cf,fromRules,expandRules,found,depth,npower},
CheckAbort[
(*init*)
nds=Count[sec,1];(*number of denominators*)
pds=Flatten[Position[sec,1]];(*position of denominators*)
List$signs=(sec1=1-sec;sec1[[pds]]=(1-2 IntegerDigits[#,2,nds]);sec1(*1-2 IntegerDigits[#,2,nds]*))&/@Range[0,2^nds-1];
(*\:0412\:044b\:0447\:0438\:0441\:043b\:044f\:0435\:043c \:043e\:043f\:0446\:0438\:0438*)
{ndepth,npower,inds,searchDepth,useSR,ds,dr,onmis,tc}={OptionValue[NumDepth],OptionValue[Numerator],Replace[OptionValue[NamingFunction],Automatic:>$NamingFunction][dim],OptionValue@Depth,OptionValue@SR,Replace[OptionValue@DiskSave,True:>BasisDirectory[nm]],Replace[OptionValue@DiskRecover,{Automatic|True->True,_->False}],OptionValue@NMIs,OptionValue@TimeConstrained};Declare[Evaluate@inds,Number];
(*inds\[LongDash]\:043f\:0435\:0440\:0435\:043c\:0435\:043d\:043d\:044b\:0435 \:0434\:043b\:044f \:0438\:043d\:0434\:0435\:043a\:0441\:043e\:0432*)tcf=If[Not@TrueQ@Not@tc,TimeConstrained,#&];sjopts=FilterRules[(#->OptionValue[SolvejSectorDen,#])&/@First/@Options[SolvejSectorDen],Options[Solvej]];onmis=Replace[onmis,{Automatic:>If[MemberQ[$ContextPath,"Mint`"],If[IntegerQ[#],#,0]&@Symbol["CountMIs"]@sect,0]}];
(*Recovering from disk*)
If[Not@TrueQ@Not@ds&&dr&&FileExistsQ[ds<>"/"<>secS],jRulesF=Get[ds<>"/"<>secS];If[jRulesF==="reserved",LiteRedPrint["Sector ",sect," is likely being solved by another kernel. Execute SolvejSectorDen["<>ToString[sect]<>",DiskRecover\[Rule]True] later to update MIs["<>ToString[nm]<>"]."];
Return[Indeterminate],
mis=j[nm,##]&@@inds/.#&/@{ToRules[LogicalExpand@Reduce[Not[Or@@Thread[Pick[inds,sec,0]!=0]||Or@@Select[jRulesF,MatchQ[#[[1,1,1]],nm]&][[All,1,2]]]]]};If[!FreeQ[mis,Alternatives@@inds],Message[SolvejSectorDen::leak,mis]]];If[ds===BasisDirectory[nm],ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[BasisDirectory["<>ToString[nm]<>"]<>\"/"<>secS<>"\"]"],ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[\""<>ds<>"/"<>secS<>"\"]"]];LiteRedPrint["Sector ",sect," is recovered from file"];,
(**)
tcf[
LiteRedPrint["Sector ",sect];
If[Not[TrueQ@Not@ds||FileExistsQ[ds<>"/"<>secS]],If[!DirectoryQ[ds],CreateDirectory[ds];Message[DiskSave::dir,ds]];Put["reserved",ds<>"/"<>secS];rsrvd=True];scond=Inner[#2[#1]&,inds,(sec/.{1->(GreaterEqual[#,1]&),0->(LessEqual[#,0]&)}),List];ptrnrule=Inner[#1->Pattern[#1,_]?#2&,inds,(sec/.{1->Positive,0->NonPositive}),List];(*ptrnrule\[LongDash]\:0437\:0430\:043c\:0435\:043d\:0430 inds \:043d\:0430 \:043f\:0430\:0442\:0442\:0435\:0440\:043d\:044b*)(*nrordrd=Which[Length[#1]<Length[#2],True,Length[#1]>Length[#2],False,LessEqual@@((j[nm,##]&@@inds)/.{#2,#1}),True,True,False]&;*)nrordrd[x_]:=First/@Flatten[Sort[#,(Last@#1)>(Last@#2)&]&/@SortBy[Gather[{#,j[nm,##]&@@inds/.#}&/@x(*\:0421\:0430\:043c\:0438 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:0438 \:0438\:043d\:0434\:0435\:043a\:0441\:044b \:043f\:043e\:0441\:043b\:0435 \:0438\:0445 \:043f\:0440\:0438\:043c\:0435\:043d\:0435\:043d\:0438\:044f*),MatchQ[Expand[List@@Last@#1-List@@Last@#2],{__Integer}]&(*\:0421\:043e\:0431\:0438\:0440\:0430\:0435\:043c \:0432 \:0433\:0440\:0443\:043f\:043f\:044b\\:0440\:043e\:0434\:0441\:0442\:0432\:0435\:043d\:043d\:044b\:0445*)],{Length@First@First@#,Count[Last@First@#,_Integer],Sort@Flatten@Position[Take[jComplexity[Last@First@#],-dim],Except[_Integer],{1}]}&],1];(*\:0414\:0443\:0440\:0430\:043a\:043e\:0437\:0430\:0449\:0438\:0442\:0430*)If[NumericQ[d],Message[SolvejSectorDen::dim];Abort[]];(*\:0434\:043e\:043f\:0438\:0441\:0430\:0442\:044c \:043f\:043e\:0442\:043e\:043c*)
(*\:0413\:043e\:0442\:043e\:0432\:0438\:043c\:0441\:044f \:043a \:0440\:0435\:0448\:0435\:043d\:0438\:044e \:0443\:0440\:0430\:0432\:043d\:0435\:043d\:0438\:0439 \:0432 \:0434\:0430\:043d\:043d\:043e\:043c \:0441\:0435\:043a\:0442\:043e\:0440\:0435*)
jSector[nm]=sect;
jRulesF={};
ids=Join[IBP[nm]@@inds,LI[nm]@@inds];
params=Complement[Variables[Last@Reap[Collect[ids,_j,Sow]]],inds];
AppendTo[indication$outputToDelete,LiteRedPrintTemporary["Parameters "<>ToString[params]<>" are assumed to be independent."]];
If[onmis>=0,AppendTo[indication$outputToDelete,LiteRedPrintTemporary["Expecting "<>ToString[onmis]<>" masters."]]];
ids=Function@@{sharpen[ids]/.MapIndexed[#->Slot@@#2&,inds]};
If[useSR,
sr=Function[If[MemberQ[UniqueSectorsDen@nm,sect],
DeleteCases[DeleteDuplicates[Collectj[j[nm,##]-(j[nm,##]/.jSymmetriesDen@@sect)]],0],
{}
]],
sr={}&
];
(*whenBad*)
numcond[{a_,b___},c_]:=(a<= -1&&numcond[{b},a+c]||a>=0&&numcond[{b},c]);
numcond[{},c_]:=c<=-npower-1;
whenBad[expr_]:=Module[{jl=Cases[CollectjList[expr],{_j,_}],dconds,nconds},dconds=LogicalExpand[Or@@(And@@Thread[0==Flatten[CoefficientList[#,params]]]&/@Union@@((First/@FactorList[#])&/@Denominator/@Last/@jl))];nconds={#2,smartReduce[numcond[List@@Rest@#,0](*Or@@Thread[Pick[List@@#1,sect,1]\[LessEqual]-1]*)]}&@@@jl;If[MemberQ[nconds,{_,True}],Return[True]];
nconds=Or@@DeleteDuplicates@Flatten@Cases[nconds,{b_,a:Except[False]}:>Cases[Replace[{a},Or->Sequence,{2},Heads->True],x_/;0=!=Expand[Numerator[b]/.ToRules[x]]]];(*If[nconds=!=False,Print[nconds]];*)
smartReduce[LogicalExpand[dconds||nconds]]
];
(*/whenBad*)
(*smartReduce*)
smartReduce[expr_]:=Module[{exprl=Replace[{expr},Or->Sequence,{2},Heads->True],t,l},(Or@@((t=Replace[{#},And->Sequence,{2},Heads->True];t=And@@(Function[l,cf[LogicalExpand@TimeConstrained[(*\[LeftArrow]added 25.12.2012*)Reduce[#,l[[1,2]],Integers],300,#]&[And@@l[[All,1]]&&(And@@Select[scond,MemberQ[l[[1,2]],First@#]&])]]]/@GatherBy[Transpose[{t,FixedPoint[Function[l,Union@@Cases[l,x_/;{}!=Intersection[#,x]]&/@l],Cases[inds,n_/;Not[FreeQ[#,n]]]&/@t]}],Last]))&/@exprl))];
cf[x_Or]:=cf/@x;
cf[x_]:=Module[{Cs=Union@Cases[{x},_C,\[Infinity]](*\:0441\:0433\:0435\:043d\:0435\:0440\:0438\:0440\:043e\:0432\:0430\:043d\:043d\:044b\:0435 Reduce\\:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*),
l=Replace[{x},And->Sequence,{2},Heads->True],c,dens=Alternatives@@Pick[inds,sec,1],nums=Alternatives@@Pick[inds,sec,0]},
If[MatchQ[x,True|False],Return[x]];
l=Replace[l,(*\:0417\:0430\:043c\:0435\:043d\:044f\:0435\:043c \:043d\:0430 \:043a\:0430\:043d\:043e\:043d\:0438\:0447\:0435\:0441\:043a\:0443\:044e \:0444\:043e\:0440\:043c\:0443*)HoldPattern[y_Alternatives\[Element]Integers]:>Sequence@@((#\[Element]Integers)&/@List@@y),{1}];If[Cs=!={},(*\:0415\:0441\:0442\:044c \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*)(*\:041f\:0440\:043e\:0432\:0435\:0440\:044f\:0435\:043c,\:0447\:0442\:043e Reduce \:0441\:0433\:0435\:043d\:0435\:0440\:0438\:043b \:0442\:043e\:043b\:044c\:043a\:043e \:0446\:0435\:043b\:044b\:0435 \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*)If[And@@(MemberQ[l,HoldPattern[#\[Element]Integers]]&/@Cs),l=DeleteCases[l,Alternatives@@Cs\[Element]Integers],(*Message[SolvejSectorDen::parse,eqr];*)Return[True]];c=Cases[l,(y_>=#)|(y_<=#)|(#<=y_)|(#>=y_)]&/@Cs;If[Not[And@@(Length[#]===1&/@c)],(*Message[SolvejSectorDen::parse,eqr];*)Return[True]];c=Flatten@c;l=Complement[l,c];c=(*\:0417\:0434\:0435\:0441\:044c \:043d\:0435 \:0441\:043e\:0432\:0441\:0435\:043c \:043f\:043e\:043d\:044f\:043b*)Cases[l,t:((z:#+1)==(y:dens)|(y:dens)==(z:#+1)|(z:-#)==(y:nums)|(y:nums)==(z:-#)):>{y,t}]&/@MapThread[Replace[#1,{y_>=#2|#2<=y_:>Expand[y-#2],y_<=#2|#2>=y_:>Expand[#2-y]}]&,{c,Cs}];If[MemberQ[c,{}],(*Message[SolvejSectorDen::parse,eqr];*)Return[True]];c=Last@Last@SortBy[#,Position[inds,First@#1,1]&]&/@c;l=Complement[l,c];c=ExpandAll[Flatten[Solve[c,Cs]]],c={}];(*\:041e\:0447\:0435\:0432\:0438\:0434\:043d\:044b\:0435 \:043e\:0433\:0440\:0430\:043d\:0438\:0447\:0435\:043d\:0438\:044f \:043d\:0430 \:0438\:043d\:0434\:0435\:043a\:0441\:044b \:0441\:0440\:0430\:0437\:0443 \:0443\:0434\:0430\:043b\:044f\:0435\:043c*)l=DeleteCases[l,Alternatives@@inds\[Element]Integers|dens>=1|1<=dens|nums<=0|0>=nums];(*\:0414\:043e\:043b\:0436\:043d\:044b \:043e\:0441\:0442\:0430\:0442\:044c\:0441\:044f \:0442\:043e\:043b\:044c\:043a\:043e \:0440\:0430\:0432\:0435\:043d\:0441\:0442\:0432\:0430*)If[!MatchQ[l,{(Alternatives@@inds==_|_==Alternatives@@inds)...}],(*Message[SolvejSectorDen::parse,eqr];*)Return[True]];l=ExpandAll[Replace[l,(y_==(z:Alternatives@@inds))|((z:Alternatives@@inds)==y_):>z==(y/.c),{1}]];And@@l];
(*/smartReduce*)
(*fromRules*)
fromRules[x_]:=Or@@And@@@(x/.Rule->Equal);
(*/fromRules*)
(*expandRules*)
expandRules[x_]:=(Pick[#1,Table[!MemberQ[Delete[#2,i]/.#1[[i]],True],{i,Length[#1]}]]&[#,Apply[And,#/.Rule->Equal,{1}]])&[Union[Sort/@x]];
(*/expandRules*)
(* *******************************************************************************************************\ *)
NoRules=(*Thread[Pick[inds,sec,0]\[Rule]#]&/@Flatten[-Compositions[#,Count[sec,0]]&/@Reverse[Range[0,OptionValue[Numerator]]],1]*){Thread[Pick[inds,sec,0]->0]};
jRulesF=(*Added 23.11.2016*){}(*/Added 23.11.2016*)(*(*Deleted 23.11.2016*){(#1/.ptrnrule/.{d\[Rule]Pattern[#,Blank[]]&@d})/;#2\[RuleDelayed]NumeratorsToDShifts[#1]}&[j[{nm,d},##]&@@inds,Or@@Thread[Pick[inds,sec,0]\[NotEqual]0]](*/Deleted 23.11.2016*)*);
nr=Length[jRulesF];
LiteRedMonitor[
While[NoRules=!={},
(*Consider first case*)
rules1=First@NoRules;
(*form a starting point,a pattern,and a position list of the independent indices*)
startp=inds/.rules1;Bool$numericIndices=FreeQ[startp,Alternatives@@inds];
found=False;
NoRules=Rest@NoRules;
If[!Bool$numericIndices||(Length[mis]+Length[NoRules]>=onmis),
(*\:0418\:043d\:043e\:0433\:0434\:0430 \:0431\:043e\:043b\:0435\:0435 \:0441\:043f\:0435\:0446\:0438\:0444\:0438\:0447\:0435\:0441\:043a\:0438\:0435 \:0441\:043b\:0443\:0447\:0430\:0438 \:043f\:043e\:043f\:0430\:0434\:0430\:044e\:0442 \:0432 \:0443\:0436\:0435 \:0440\:0435\:0448\:0435\:043d\:043d\:044b\:0435*)If[(fr=Select[FoundRules,TrueQ[First[#]/.rules1]&&Not[TrueQ[Simplify[Last[#]/.rules1]]]&,1])=!={},(*\:0417\:0434\:0435\:0441\:044c \:0432 \:0431\:0443\:0434\:0443\:0449\:0435\:043c \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0443 \:043d\:0443\:0436\:043d\:043e \:0443\:0442\:043e\:0447\:043d\:0438\:0442\:044c*)NoRules=nrordrd[expandRules[{ToRules@smartReduce[LogicalExpand[fromRules[NoRules]||fromRules[{rules1}]&&fr[[1,2]]]]}]];Continue[]];nr++;pat1=(j[nm,##]&@@(Pattern[#,Blank[]]&/@inds))/;"condition"/."condition"->fromRules[{rules1}];
pos=Flatten[Position[inds,Alternatives@@Complement[inds,First/@rules1],1]];
jRulesDB={};
depth=0;
While[depth<=searchDepth,
(indication$numberOfPoints++;n=0;(
(*Solve equations*)
If[Solvej[n++;#,jRulesDB,Evaluate[Sequence@@sjopts]],
jRules1=First[jRulesDB];If[(Bool$numericIndices&&First@jRules1<j[nm,##]&@@startp),jRulesDB=Rest[jRulesDB];
(*Collect garbage when doing\Laporta*),(*added 23.06.2014*)
If[TrueQ[jSector@First@jRules1<jSector@j[nm,##]&@@startp],jRulesDB=Rest[jRulesDB];(*Useless rule*)(*later join*),
If[(*If found possible rule*)MatchQ[First@jRules1,pat1],jRules1=(#/.MapThread[#1->Expand[2 #1-#2]&,{inds[[pos]],Rest[List@@First[#]][[pos]]}])&[jRules1];(*Patternize the left sides of the rules and form a\list of rules for the integrals to consider later*){jRules1,rules2}=Reap[(j[nm,##]&@@inds/.ptrnrule)/;"condition"->Collectj[#[[2]],Factor1]/."condition"->fromRules[{rules1}]&&Not[Sow[whenBad[#[[2]]]]]&@jRules1];(*Just for safety:do not expect empty list*)If[rules2==={},Print["Abnormality: rules have not been sown. Aborting...",Abort[]]];{rules2}=First@rules2;(*If found suitable rule*)
If[rules2=!=True,(*Found the rule!*)
AppendTo[FoundRules,{fromRules[{rules1}],rules2}];(*\:0417\:0434\:0435\:0441\:044c \:0432 \:0431\:0443\:0434\:0443\:0449\:0435\:043c \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0443 \:043d\:0443\:0436\:043d\:043e \:0443\:0442\:043e\:0447\:043d\:0438\:0442\:044c*)NoRules=nrordrd[expandRules[{ToRules@smartReduce[LogicalExpand[fromRules[NoRules]||fromRules[{rules1}]&&rules2]]}]];AppendTo[jRulesF,MapAt[#/.{d->\!\(\*
TagBox[
StyleBox[
RowBox[{"Pattern", "[", 
RowBox[{"#", ",", 
RowBox[{"Blank", "[", "]"}]}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)&@d}&,jRules1(*(*Deleted 23.11.2016*)/.{j[nm,inds__]->j[{nm,d},inds]}(*/Deleted 23.11.2016*)*),1]];
(* Put[jRulesF,ds<>"/"<>secS];*)found=True;
Break[]];]]]];)&/@(DeleteDuplicates@If[useSR&&Bool$numericIndices,DeleteCases[Join[ids@@#,sr@@#]/.ZerojRule[nm],0],ids@@#/.ZerojRule[nm]]))&/@((indication$numberOfPointsToGo=indication$numberOfPoints+Length[#];#)&@(
(*\:0421\:043f\:0438\:0441\:043e\:043a \:0442\:043e\:0447\:0435\:043a \:0434\:043b\:044f \:043f\:043e\:0438\:0441\:043a\:0430*)(*\:0423\:0431\:043e\:0433\:0430\:044f \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0430,\:043f\:043e\:0442\:043e\:043c \:043f\:0435\:0440\:0435\:043f\:0438\:0441\:0430\:0442\:044c*)Sort[Cases[
startp+#&/@DeleteDuplicates[Join@@Outer[Times,List$signs,layer[sec,depth,ndepth],1]](*(sec1=sec;sec1[[pds]]=#;startp+sec1)&/@
Union@@Outer[Times,List$signs,Join@@(Compositions[#,nds]&/@Range[0,searchDepth]),1]*),x_/;(jSector[j[nm,##]&@@x]==sect)],Which[(*(tcnd=(Plus@@Abs[#1-startp]-Plus@@Abs[#2-startp]))\[NotEqual]0,tcnd<0,*)(tcnd=(Abs[Plus@@((2 sec-1) (#1-startp))]-Abs[Plus@@((2 sec-1) (#2-startp))]))!=0,tcnd<0,True,(j[nm,##]&@@(#1))<=(j[nm,##]&@@(#2))]&]));(************************************************************************************************************************************)
If[++depth>searchDepth&&!Bool$numericIndices,searchDepth=depth;AppendTo[indication$outputToDelete,LiteRedPrintTemporary["Increasing search depth to "<>ToString[searchDepth]]]]
]
];
If[!found,
AppendTo[indication$outputToDelete,LiteRedPrintTemporary["Found master integral "<>ToString[startp]]];AppendTo[mis,j[nm,##]&@@startp]
]
],TableForm[{Overlay[{ProgressIndicator[Count[inds,x_/;FreeQ[startp,x]]-Count[sec,0],{0,nds+1/2}],ToString[indication$numberOfPoints]<>"("<>ToString[n]<>")"<>"\[Rule]"<>ToString[indication$numberOfPointsToGo]},Alignment->Center],ToString[nr]<>" point: "<>ToString[startp]}]],tc,If[!Bool$numericIndices,If[rsrvd,DeleteFile[ds<>"/"<>secS]];Return[$Failed],mis=j[nm,##]&@@inds/.#&/@{ToRules[LogicalExpand@Reduce[Not[Or[Or@@Thread[Pick[inds,sec,0]!=0],Or@@jRulesF[[All,1,2]]]]]]};If[!FreeQ[mis,Alternatives@@inds],Message[SolvejSectorDen::leak,mis]]]];If[TrueQ[Not[ds]],(#1/:jRulesDen[##]=jRulesF),If[!DirectoryQ[ds],CreateDirectory[ds];Message[DiskSave::dir,ds]];If[!FileExistsQ[ds<>"/"<>secS]||OptionValue[Replace],If[!rsrvd&&FileExistsQ[ds<>"/"<>secS],Message[DiskSave::overwrite,ds<>"/"<>secS]];ReleaseHold[Hold[Put[##]]]&[jRulesF,ds<>"/"<>secS];If[ds===BasisDirectory[nm],ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[BasisDirectory["<>ToString[nm]<>"]<>\"/"<>secS<>"\"]"],ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[\""<>ds<>"/"<>secS<>"\"]"]]]]&@@sect;fr=Reduce[Not[Or@@(And@@Thread[inds==Rest[List@@#]]&/@mis)||Or@@jRulesF[[All,1,2]]||Or@@Thread[Pick[inds,sec,0]!=0]]];If[Not[TrueQ[Not[fr]]],Message[SolvejSectorDen::leak,j[nm,##]&@@inds/.{ToRules[LogicalExpand@fr]}]];];MIs[nm]^=jVars[{DeleteCases[MIs[nm],_?(jSector[#]===sect&)],mis},Sort->jSector];LiteRedPrint["    "<>ToString[Length@mis]<>" master integrals found"<>If[mis==={},"",":\n"<>StringTrim[ToString[mis]," "|"{"|"}"]]<>".\n    "<>ToString["jRulesDen"@@sect]<>" \[LongDash] reduction rules for the sector.\n    MIs["<>ToString[nm]<>"] \[LongDash] updated list of the masters."];NotebookDelete/@indication$outputToDelete;If[Not@TrueQ@Not@BasisDirectory[nm],Quiet[DiskSave[nm,Save->"Basis"]]];Length@mis,(*Cleaning up*)If[rsrvd,DeleteFile[ds<>"/"<>secS]];Abort[]]]]


SolvejSectorDen::nots="The first argument of SolvejSectorDen should be js[\[Ellipsis]]. Received instead:\n`1`";


SolvejSectorDen[sect_,OptionsPattern[]]:=(Message[SolvejSectorDen::nots,sect];$Failed)


SolvejSectorD::leak="Discrepancy detected. Reduction is not full: `1`.";


Options[SolvejSectorD]={NamingFunction->Automatic,
Depth->2(*\:0433\:043b\:0443\:0431\:0438\:043d\:0430 \:043f\:043e\:0438\:0441\:043a\:0430*),
SR->True(*\:0438\:0441\:043f\:043e\:043b\:044c\:0437\:043e\:0432\:0430\:0442\:044c \:0441\:043e\:043e\:0442\:043d\:043e\:0448\:0435\:043d\:0438\:044f \:0441\:0438\:043c\:043c\:0435\:0442\:0440\:0438\:0438?*),
NMIs->0,
(*UseRules\[Rule]False,*)
DiskSave->True(*\:0421\:043e\:0445\:0440\:0430\:043d\:044f\:0442\:044c \:043d\:0430\:0439\:0434\:0435\:043d\:043d\:044b\:0435 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:043d\:0430 \:0434\:0438\:0441\:043a\:0435?*),
DiskRecover->False,
Replace->True,
TimeConstrained->False,
CheckZeroFunction->Factor2,
CheckZeroAlways->True,
SimplifyFunction->Factor2,
SimplifyAlways->False,
SubstituteAlways->False
};
SolvejSectorD::parse="Could not parse `1`.";
SolvejSectorD::dim="Please, set dimension to be a symbol. Use SetDim[\[Ellipsis]]. Aborting...";


SolvejSectorD[sect_js,OptionsPattern[]]:=Block[{jComplexity},
jComplexity[j[a_,n__]]:=Module[{nm,d,jsec,jsec1},
{nm,d}=Replace[a,b_Symbol:>{b,MetricTensor[]}];
jsec=jSector@nm;
If[Head[jsec]=!=js,Message[jSector::jtop,nm];Abort[]];
{jsec1,jsec}=Transpose[Replace[Transpose[{{n},Rest[List@@jsec]}],{x_Integer,_}:>{x,Boole[Positive[x]]},{1}]];
(*added 19.07.2014*){jsec1,jsec}={permute[jsec1,jsOrder[nm,##]&@@jsec],permute[jsec,jsOrder[nm,##]&@@jsec]};
Return[{nm,Length@#2,-(Plus@@#1),Plus@@#2,FromDigits[jsec,2],d,Sequence@@-#2,Sequence@@#1}&[Pick[jsec1,jsec,0],Pick[jsec1,jsec,1]]]
];
Module[
{(*debug,*)
sec=List@@Rest@sect,
dim=Length@sect-1,
rsrvd=False,
inds,scond,ne=0,ne1=0,n=0,
sign,ptl={},
mis={},nmis,
nm=First@sect,numi,
secS=ToString[HoldForm[jRulesDen[##]]&@@sect],
NoRules={{}},nrordrd,FoundRules={},
params,d=MetricTensor[],ids,rules1,rules2,
startp,pat1,ptrnrule,jRules1,jRulesF,jRulesDB,pos,
searchDepth,useSR,recover,continue,mir,
nr,fr,tcnd,ds,dr,onmis,tc,tcf,sjopts,
whenBad,smartReduce,smartReduce1,eqr,cf,fromRules,expandRules
},
CheckAbort[
(**)
(*nums1=First/@Flatten[SplitCases[Transpose[{Range[dim],sec}],{{_,0}}],1];*)
(*\:0412\:044b\:0447\:0438\:0441\:043b\:044f\:0435\:043c \:043e\:043f\:0446\:0438\:0438*)
{inds,searchDepth,useSR,ds,dr,onmis,tc}={Replace[OptionValue[NamingFunction],Automatic:>$NamingFunction][dim],OptionValue@Depth,OptionValue@SR,
Replace[OptionValue@DiskSave,True:>BasisDirectory[nm]],
Replace[OptionValue@DiskRecover,{Automatic|True->True,_->False}],OptionValue@NMIs,OptionValue@TimeConstrained};Declare[Evaluate@inds,Number];(*inds \[LongDash] \:043f\:0435\:0440\:0435\:043c\:0435\:043d\:043d\:044b\:0435 \:0434\:043b\:044f \:0438\:043d\:0434\:0435\:043a\:0441\:043e\:0432*)
tcf=If[Not@TrueQ@Not@tc,TimeConstrained,#&];
sjopts=FilterRules[(#->OptionValue[SolvejSectorDen,#])&/@First/@Options[SolvejSectorDen],Options[Solvej]];
onmis=Replace[onmis,{Automatic:>If[MemberQ[$ContextPath,"Mint`"],If[IntegerQ[#],#,0]&@Symbol["CountMIs"]@sect,0]}];
(*Recovering from disk*)
If[Not@TrueQ@Not@ds&&dr&&FileExistsQ[ds<>"/"<>secS],
jRulesF=Get[ds<>"/"<>secS];
If[jRulesF==="reserved", 
LiteRedPrint["The sector ",sect," is likely being solved by another kernel. Execute SolvejSectorDen["<>ToString[sect]<>",DiskRecover\[Rule]True] later to update MIs["<>ToString[nm]<>"]."];
,
mis=j[nm,##]&@@inds/.#&/@{ToRules[LogicalExpand@Reduce[Not[Or@@jRulesF[[All,1,2]]]]]};
If[!FreeQ[mis,Alternatives@@inds],Message[SolvejSectorDen::leak,mis]]
];
If[ds===BasisDirectory[nm],
ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[BasisDirectory["<>ToString[nm]<>"]<>\"/"<>secS<>"\"]"],
ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[\""<>ds<>"/"<>secS<>"\"]"]
];LiteRedPrint["Sector ",sect," is recovered from file"];
,
(**)
tcf[
LiteRedPrint["Sector ",sect];
If[Not[TrueQ@Not@ds||FileExistsQ[ds<>"/"<>secS]],If[!DirectoryQ[ds],CreateDirectory[ds];Message[DiskSave::dir,ds]];Put["reserved",ds<>"/"<>secS];rsrvd=True];
scond=Inner[#2[#1]&,inds,(sec/.{1->(GreaterEqual[#,1]&),0->(LessEqual[#,0]&)}),List];
ptrnrule=Inner[#1-> Pattern[#1,_]?#2&,inds,(sec/.{1->Positive,0->NonPositive}),List];
(*ptrnrule \[LongDash] \:0437\:0430\:043c\:0435\:043d\:0430 inds \:043d\:0430 \:043f\:0430\:0442\:0442\:0435\:0440\:043d\:044b*)
(*nrordrd=Which[Length[#1]<Length[#2],True,Length[#1]>Length[#2],False,LessEqual@@((j[nm,##]&@@inds)/.{#2,#1}),True,True,False]&;*)
nrordrd[x_]:=First/@Flatten[Sort[#,(Last@#1)>(Last@#2)&]&/@SortBy[Gather[
{#,j[nm,##]&@@inds/.#}&/@x(*\:0421\:0430\:043c\:0438 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:0438 \:0438\:043d\:0434\:0435\:043a\:0441\:044b \:043f\:043e\:0441\:043b\:0435 \:0438\:0445 \:043f\:0440\:0438\:043c\:0435\:043d\:0435\:043d\:0438\:044f*)
,MatchQ[Expand[List@@Last@#1-List@@Last@#2],{__Integer}]&(*\:0421\:043e\:0431\:0438\:0440\:0430\:0435\:043c \:0432 \:0433\:0440\:0443\:043f\:043f\:044b \:0440\:043e\:0434\:0441\:0442\:0432\:0435\:043d\:043d\:044b\:0445*)
],{Length@First@First@#,Count[Last@First@#,_Integer],Sort@Flatten@Position[Take[jComplexity[Last@First@#],-dim],Except[_Integer],{1}]}&
],1];
(*\:0414\:0443\:0440\:0430\:043a\:043e\:0437\:0430\:0449\:0438\:0442\:0430*)
If[NumericQ[d]||!MatchQ[d,_Symbol],Message[SolvejSectorDen::dim];Abort[]];(*\:0434\:043e\:043f\:0438\:0441\:0430\:0442\:044c \:043f\:043e\:0442\:043e\:043c*)
(*\:0441\:0432\:043e\:0431\:043e\:0434\:043d\:044b\:0435 \:043f\:0430\:0440\:0430\:043c\:0435\:0442\:0440\:044b*)
params=Select[Variables[{d,Outer[sp,EMs@nm,EMs@nm],LFDistribute@Ds@nm}],FreeQ[#,Alternatives@@LMs@nm]&];
AppendTo[ptl,LiteRedPrintTemporary["Parameters "<>ToString[params]<>" are assumed to be independent."]];
(*\:0413\:043e\:0442\:043e\:0432\:0438\:043c\:0441\:044f \:043a \:0440\:0435\:0448\:0435\:043d\:0438\:044e \:0443\:0440\:0430\:0432\:043d\:0435\:043d\:0438\:0439 \:0432 \:0434\:0430\:043d\:043d\:043e\:043c \:0441\:0435\:043a\:0442\:043e\:0440\:0435*)
jSector[nm]=sect;jRulesF={};
(*ids="Function"[Join[First@IBP[nm],First@LI[nm]]]/."Function"->Function;*)
ids=Function@@{sharpen[Join[IBP[nm]@@inds,LI[nm]@@inds]]/.MapIndexed[#->Slot@@#2&,inds]};
sign=(1-2IntegerDigits[#,2,dim])&/@Range[0,2^dim-1];
(*whenBad*)
whenBad[expr_]:=Module[{jl=Cases[CollectjList[expr],{_j,_}],dconds,nconds},
dconds=LogicalExpand[Or@@(And@@Thread[0==Flatten[CoefficientList[#,params]]]&/@Union@@((First/@FactorList[#])&/@Denominator/@Last/@jl))];
nconds={#2,smartReduce[Or@@Thread[Pick[List@@#1,sect,0]>=1]]}&@@@jl;
If[MemberQ[nconds,{_,True}],Return[True]];
nconds=Or@@Flatten@Cases[nconds,{b_,a:Except[False]}:>Cases[Replace[{a},Or->Sequence,{2},Heads->True],x_/;0=!=Expand[Numerator[b]/.ToRules[x]]]];
(*LogicalExpand@*)smartReduce[LogicalExpand[dconds||nconds]]
];
(*/whenBad *)
(*smartReduce *)
(*smartReduce[expr_Or]:=cf[LogicalExpand[smartReduce1/@expr]];
smartReduce[expr_]:=cf[LogicalExpand@smartReduce1@expr];
smartReduce1[expr_]:=(Reduce[expr&&And@@#,First/@#,Integers]&[Select[scond,!FreeQ[expr,First@#]&]]);*)
smartReduce[expr_]:=Module[
{exprl=Replace[{expr},Or->Sequence,{2},Heads->True],t,l},
(*WriteString["stdout","<"];
(WriteString["stdout",ToString[#]<>">\n"];#)&@*)(Or@@((t=Replace[{#},And->Sequence,{2},Heads->True];
t=And@@(Function[l,cf[LogicalExpand@TimeConstrained[(*\[LeftArrow] added 25.12.2012*)Reduce[#,l[[1,2]],Integers],300,#]&[And@@l[[All,1]]&&(And@@Select[scond,MemberQ[l[[1,2]],First@#]&])]]]/@GatherBy[Transpose[{t,FixedPoint[Function[l,Union@@Cases[l,x_/;{}!=Intersection[#,x]]&/@l],
Cases[inds,n_/;Not[FreeQ[#,n]]]&/@t]}],Last])
)&/@exprl))
];
cf[x_Or]:=cf/@x;
cf[x_]:=Module[{
Cs=Union@Cases[{x},_C,\[Infinity]](*\:0441\:0433\:0435\:043d\:0435\:0440\:0438\:0440\:043e\:0432\:0430\:043d\:043d\:044b\:0435 Reduce \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*),
l=Replace[{x},And->Sequence,{2},Heads->True],
c,
dens=Alternatives@@Pick[inds,sec,1],
nums=Alternatives@@Pick[inds,sec,0]
},
If[MatchQ[x,True|False],Return[x]];
l=Replace[l,(*\:0417\:0430\:043c\:0435\:043d\:044f\:0435\:043c \:043d\:0430 \:043a\:0430\:043d\:043e\:043d\:0438\:0447\:0435\:0441\:043a\:0443\:044e \:0444\:043e\:0440\:043c\:0443*)
HoldPattern[y_Alternatives\[Element]Integers]:>Sequence@@((#\[Element]Integers)&/@List@@y),{1}];
If[Cs=!={},
(*\:0415\:0441\:0442\:044c \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*)
(*\:041f\:0440\:043e\:0432\:0435\:0440\:044f\:0435\:043c, \:0447\:0442\:043e Reduce \:0441\:0433\:0435\:043d\:0435\:0440\:0438\:043b \:0442\:043e\:043b\:044c\:043a\:043e \:0446\:0435\:043b\:044b\:0435 \:043a\:043e\:043d\:0441\:0442\:0430\:043d\:0442\:044b*)
If[And@@(MemberQ[l,HoldPattern[#\[Element]Integers]]&/@Cs),
l=DeleteCases[l,Alternatives@@Cs\[Element]Integers],(*Message[SolvejSectorDen::parse,eqr];*)Return[True]];
c=Cases[l,(y_>= #)|(y_<=  #)|(#<= y_)|(#>=y_)]&/@Cs;If[Not[And@@(Length[#]===1&/@c)],(*Message[SolvejSectorDen::parse,eqr];*)Return[True]];c=Flatten@c;l=Complement[l,c];
c=(*\:0417\:0434\:0435\:0441\:044c \:043d\:0435 \:0441\:043e\:0432\:0441\:0435\:043c \:043f\:043e\:043d\:044f\:043b*)Cases[l,t:((z:#+1)==(y:dens)|(y:dens)==(z:#+1)|(z:-#)==(y:nums)|(y:nums)==(z:-#)):>{y,t}]&/@MapThread[Replace[#1,{y_>=#2|#2<=y_:>Expand[y-#2],y_<=#2|#2>=y_:>Expand[#2-y]}]&,{c,Cs}];
If[MemberQ[c,{}],(*Message[SolvejSectorDen::parse,eqr];*)Return[True]];
c=Last@Last@SortBy[#,Position[inds,First@#1,1]&]&/@c;
l=Complement[l,c];
c=ExpandAll[Flatten[Solve[c,Cs]]],
c={}
];
(*\:041e\:0447\:0435\:0432\:0438\:0434\:043d\:044b\:0435 \:043e\:0433\:0440\:0430\:043d\:0438\:0447\:0435\:043d\:0438\:044f \:043d\:0430 \:0438\:043d\:0434\:0435\:043a\:0441\:044b \:0441\:0440\:0430\:0437\:0443 \:0443\:0434\:0430\:043b\:044f\:0435\:043c*)
l=DeleteCases[l,Alternatives@@inds\[Element]Integers|dens>=1|1<=dens|nums<=0|0>=nums];
(*\:0414\:043e\:043b\:0436\:043d\:044b \:043e\:0441\:0442\:0430\:0442\:044c\:0441\:044f \:0442\:043e\:043b\:044c\:043a\:043e \:0440\:0430\:0432\:0435\:043d\:0441\:0442\:0432\:0430*)
If[!MatchQ[l,{(Alternatives@@inds==_|_==Alternatives@@inds)...}],(*Message[SolvejSectorDen::parse,eqr];*)Return[True]];l=ExpandAll[Replace[l,(y_==(z:Alternatives@@inds))|((z:Alternatives@@inds)==y_):>z==(y/.c),{1}]];
And@@l];
(*/smartReduce *)
(*fromRules *)
fromRules[x_]:=Or@@And@@@(x/.Rule->Equal);
(*/fromRules *)
(*expandRules *)
expandRules[x_]:=(Pick[#1,Table[!MemberQ[Delete[#2,i]/.#1[[i]],True],{i,Length[#1]}]]&[#,Apply[And,#/.Rule->Equal,{1}]])&[Union[Sort/@x]];
(*/expandRules *)
(* ******************************************************************************************************* *)
(* First, solve identities in general case *)
(*debugt=AbsoluteTime[];*)
NoRules={Thread[Pick[inds,sec,0]->0]};
jRulesF={(j[nm,##]&@@inds/.ptrnrule)/;#->0}&[Or@@Thread[Pick[inds,sec,0]!=0]];
nr=Length[jRulesF];
(*Print[jRulesF];****debug****)
LiteRedMonitor[
While[(* Do we have cases to analyze? *)
NoRules=!={},
(*Print["NoRules:",NoRules];*)
(* Consider first case*)
rules1=First@NoRules;
(* form a starting point, a pattern, and a position list of the independent indices*)
startp=inds/.rules1;
numi=FreeQ[startp,Alternatives@@inds];
If[!numi||(Length[mis]+Length[NoRules]>onmis),
(*\:0418\:043d\:043e\:0433\:0434\:0430 \:0431\:043e\:043b\:0435\:0435 \:0441\:043f\:0435\:0446\:0438\:0444\:0438\:0447\:0435\:0441\:043a\:0438\:0435 \:0441\:043b\:0443\:0447\:0430\:0438 \:043f\:043e\:043f\:0430\:0434\:0430\:044e\:0442 \:0432 \:0443\:0436\:0435 \:0440\:0435\:0448\:0435\:043d\:043d\:044b\:0435*)
If[(fr=Select[FoundRules,TrueQ[First[#]/.rules1]&&Not[TrueQ[Simplify[Last[#]/.rules1]]]&,1])=!={},
(*\:0417\:0434\:0435\:0441\:044c \:0432 \:0431\:0443\:0434\:0443\:0449\:0435\:043c \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0443 \:043d\:0443\:0436\:043d\:043e \:0443\:0442\:043e\:0447\:043d\:0438\:0442\:044c*)
NoRules=nrordrd[expandRules[{ToRules@smartReduce[LogicalExpand[fromRules[Rest@NoRules]||fromRules[{rules1}]&&fr[[1,2]]]]}]];
Continue[]];
nr++;
pat1=(j[nm,##]&@@(Pattern[#,Blank[]]&/@inds))/;"condition"/."condition"->fromRules[{rules1}];
pos=Flatten[Position[inds,Alternatives@@Complement[inds,First/@rules1],1]];
jRulesDB={};
(ne++;n=0;((* Solve equations *)
If[Solvej[n++;#,jRulesDB,Evaluate[Sequence@@sjopts]],
jRules1=First[jRulesDB];
If[(numi&&First@jRules1<j[nm,##]&@@startp),
jRulesDB=Rest[jRulesDB];(*Collect garbage when doing Laporta*)
,
(*added 23.06.2014*)
If[TrueQ[jSector@First@jRules1<jSector@j[nm,##]&@@startp],
(*Print["useless rule ",First@jRules1\[Rule]"\[Ellipsis]"," for ",j[nm,##]&@@startp];*)
jRulesDB=Rest[jRulesDB];(*Useless rule*)
(*later join*)
,
(* If found possible rule *)
If[MatchQ[First@jRules1,pat1],
jRules1=(#/.MapThread[#1->Expand[2#1-#2]&,{inds[[pos]],Rest[List@@First[#]][[pos]]}])&[jRules1];
(* Patternize the left sides of the rules and form a list of rules for the integrals to consider later*)
{jRules1,rules2}=Reap[(j[nm,##]&@@inds/.ptrnrule)/;"condition"->Collectj[#[[2]],Factor1]/."condition"->fromRules[{rules1}]&&Not[Sow[whenBad[#[[2]]]]]&@jRules1];
(* Just for safety: do not expect empty list*)If[rules2==={},Print["Abnormality: rules have not been sown. Aborting...",Abort[]]];
{rules2}=First@rules2;
(* If found suitable rule *)
If[rules2=!=True,
(* Found the rule! *)
AppendTo[FoundRules,{fromRules[{rules1}],rules2}];
(*\:0417\:0434\:0435\:0441\:044c \:0432 \:0431\:0443\:0434\:0443\:0449\:0435\:043c \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0443 \:043d\:0443\:0436\:043d\:043e \:0443\:0442\:043e\:0447\:043d\:0438\:0442\:044c*)
NoRules=nrordrd[expandRules[{ToRules@smartReduce[LogicalExpand[fromRules[Rest@NoRules]||fromRules[{rules1}]&&rules2]]}]];
AppendTo[jRulesF,jRules1];
ReleaseHold[Hold[Put[##]]]&[jRulesF,ds<>"/"<>secS];
Continue[]
];
]]]];)&/@(DeleteDuplicates@If[useSR&&numi,DeleteCases[Join[ids@@#,SR[nm]@@#],0],ids@@#]))&/@
((ne1=ne+Length[#];#)&@((*\:0421\:043f\:0438\:0441\:043e\:043a \:0442\:043e\:0447\:0435\:043a \:0434\:043b\:044f \:043f\:043e\:0438\:0441\:043a\:0430*)
(*Put[Sort[Cases[startp+#&/@Union@@Outer[Times,sign,Join@@(Compositions[#,dim]&/@Range[0,searchDepth]),1],x_/;(jSector[j[nm,##]&@@x]===sect)],
Which[(tcnd=(Plus@@Abs[#1-startp]-Plus@@Abs[#2-startp]))!=0,tcnd<0,
(tcnd=(Abs[Plus@@((2sec-1)(#1-startp))]-Abs[Plus@@((2sec-1)(#2-startp))]))!=0,tcnd<0,True,(j[nm,##]&@@(#1))<=(j[nm,##]&@@(#2))]&],"sjsd"];
Abort[];*)


(*\:0423\:0431\:043e\:0433\:0430\:044f \:0441\:043e\:0440\:0442\:0438\:0440\:043e\:0432\:043a\:0430, \:043f\:043e\:0442\:043e\:043c \:043f\:0435\:0440\:0435\:043f\:0438\:0441\:0430\:0442\:044c*)
Sort[Cases[startp+#&/@Union@@Outer[Times,sign,Join@@(Compositions[#,dim]&/@Range[0,searchDepth]),1],x_/;(jSector[j[nm,##]&@@x]===sect)],
Which[(tcnd=(Plus@@Abs[#1-startp]-Plus@@Abs[#2-startp]))!=0,tcnd<0,
(tcnd=(Abs[Plus@@((2sec-1)(#1-startp))]-Abs[Plus@@((2sec-1)(#2-startp))]))!=0,tcnd<0,True,(j[nm,##]&@@(#1))<=(j[nm,##]&@@(#2))]&]
));
(************************************************************************************************************************************)
If[!numi,AppendTo[ptl,LiteRedPrintTemporary["Increasing search depth to "<>ToString[++searchDepth]]];Continue[]]
];
AppendTo[ptl,LiteRedPrintTemporary["Found master integral "<>ToString[startp]]];
AppendTo[mis,j[nm,##]&@@startp];
NoRules=Rest@NoRules;
]
,
TableForm[{Overlay[{ProgressIndicator[Count[inds,x_/;FreeQ[startp,x]],{0,Length@inds+1/2}],
ToString[ne]<>"("<>ToString[n]<>")"<>"\[Rule]"<>ToString[ne1]},Alignment->Center],
ToString[nr]<>" point: "<>ToString[startp]}]
],
tc,
If[!numi,
If[rsrvd,DeleteFile[ds<>"/"<>secS]];Return[$Failed],
mis=j[nm,##]&@@inds/.#&/@{ToRules[LogicalExpand@Reduce[Not[Or@@jRulesF[[All,1,2]]]]]};
If[!FreeQ[mis,Alternatives@@inds],Message[SolvejSectorDen::leak,mis]]
]
];
If[TrueQ[Not[ds]],
(#1/:jRulesDen[##]=jRulesF),
If[!DirectoryQ[ds],CreateDirectory[ds];Message[DiskSave::dir,ds]];
If[!FileExistsQ[ds<>"/"<>secS]||OptionValue[Replace],
If[!rsrvd&&FileExistsQ[ds<>"/"<>secS],Message[DiskSave::overwrite,ds<>"/"<>secS]];
ReleaseHold[Hold[Put[##]]]&[jRulesF,ds<>"/"<>secS];
If[ds===BasisDirectory[nm],
ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[BasisDirectory["<>ToString[nm]<>"]<>\"/"<>secS<>"\"]"],
ToExpression[ToString[nm]<>"/:"<>secS<>":=Get[\""<>ds<>"/"<>secS<>"\"]"]
]
]]&@@sect;
fr=Reduce[Not[Or@@(And@@Thread[inds==Rest[List@@#]]&/@mis)||Or@@jRulesF[[All,1,2]]]];
If[Not[TrueQ[Not[fr]]],Message[SolvejSectorDen::leak,j[nm,##]&@@inds/.{ToRules[LogicalExpand@fr]}]];
];
MIs[nm]^=jVars[{DeleteCases[MIs[nm],_?(jSector[#]===sect&)],mis},Sort->jSector];
LiteRedPrint["    Master integrals found: "<>If[mis==={},"none",StringTrim[ToString[mis]," "|"{"|"}"]]<>".\n\
    "<>ToString["jRulesDen"@@sect]<>" \[LongDash] reduction rules for the sector.\n\
    MIs["<>ToString[nm]<>"] \[LongDash] updated list of the masters."];
NotebookDelete/@ptl;
If[Not@TrueQ@Not@BasisDirectory[nm],Quiet[DiskSave[nm,Save->"Basis"]]];
Length@mis
,
(*Cleaning up*)
If[rsrvd,DeleteFile[ds<>"/"<>secS]];Abort[]
]
]
];


IBPReduceDen::usage="IBPReduceDen[\!\(\*
StyleBox[\"expr\", \"TI\"]\)] performs the reduction of the \!\(\*
StyleBox[\"expr\", \"TI\"]\) applying rules found by FindSymmetries and SolvejSector";
(*DWeight::usage="DWeight\[Rule]n  is an option for IBPReduceDen which determines the extra priority points for each denominator.";*)


Options[IBPReduceDen]={jExtRules->True};


IBPReduceDen[expr_,OptionsPattern[]]:=Module[
{
er,d=MetricTensor[],
dir,i=0,res,
jplist,jplist1,jlist,jsd,nd,nd1,
jlist1,lock,
rs0,rs,nrs,f,jc,(*jsector=Replace[js@@#,{_?Positive\[Rule]1,_?NonPositive\[Rule]0},{1}]&,*)
jsec,lsecs,hjsec,hjsecn,
t1,t2,jrules,jrules1,jrules2,rc,
pos,mis={},
nr=0,nr1=0,level,
lvl,
status},
Block[{jRulesDen(*,jRules*)},
jRulesDen[__]={};
er=OptionValue[jExtRules];
While[DirectoryQ[dir="IBPReduction"<>ToString[++i]],Continue[]];CreateDirectory[dir];
(*\:0441\:043e\:0431\:0438\:0440\:0430\:0435\:043c \:0432\:0441\:0435 j, \:043e\:043f\:0440\:0435\:0434\:0435\:043b\:044f\:0435\:043c \:0441\:043b\:043e\:0436\:043d\:0435\:0439\:0448\:0438\:0439 \:0441\:0435\:043a\:0442\:043e\:0440*)
CheckAbort[
jplist={#,jSector@#}&/@DeleteDuplicates@Cases[{expr},_j,\[Infinity]];
If[jplist==={},Return[expr]];
jsd={"res"->((*{#1,FromDigits[{##2},2]}&@@@*)DeleteDuplicates[Last/@jplist])};
Put[{1,{"res"->expr}},dir<>"/res"];
nd=Max[Count[Last@#,1]&/@jplist];
LiteRedMonitor[
While[jplist=!={},
(*\:043d\:0430\:0445\:043e\:0434\:0438\:043c hjsec*)
jsec=DeleteDuplicates[Last/@jplist];hjsec={Count[#,1],#}&@First@jsec;Scan[(t1={Count[#,1],#};If[OrderedQ[{hjsec,t1}],hjsec=t1])&,Rest@jsec];
{nd1,hjsec}=hjsec;hjsecn=hjsec(*{First@hjsec,FromDigits[Rest[List@@hjsec],2]}*);
(*\:0420\:0430\:0437\:0431\:0438\:0432\:0430\:0435\:043c \:043d\:0430 \:043f\:0430\:0441\:0441\:0438\:0432\:043d\:044b\:0439 \:0441\:043f\:0438\:0441\:043e\:043a \:0438 \:0430\:043a\:0442\:0438\:0432\:043d\:044b\:0439*)
If[MemberQ[ZeroSectors@First@hjsec,hjsec],
Put[{Replace[j[{#1,Pattern[#,Blank[]]&@d},##2]&@@hjsec,{1->(_?Positive),0->(_?NonPositive)},{1}]->0},dir<>"/"<>ToString[hjsecn]];
(*nr+=1;*)
jplist=DeleteCases[jplist,{_,hjsec}];
,
jlist=Cases[jplist,{x_,hjsec}:>x];jplist=DeleteCases[jplist,{_,hjsec}];
(*\:041f\:0440\:0438\:0432\:043e\:0434\:0438\:043c \:0438\:043d\:0442\:0435\:0433\:0440\:0430\:043b\:044b \:0441\:043b\:043e\:0436\:043d\:0435\:0439\:0448\:0435\:0433\:043e \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
rs0={};rs={};jplist1={};
jrules=jRulesDen@@hjsec/.PatternTest->(#1&);
(*Print[hjsec,":",jrules];*)
(*If[Head@jrules===jRulesDen,
jrules=MapAt[#/.(#\[Rule]Pattern[#,Blank[]]&@d)&,#,1]&/@(Flatten[{jRules@@hjsec}]/.PatternTest\[Rule](#1&)/.{j[nm_Symbol,inds__]:>j[{nm,d},inds]});(*No rules*)
];*)
t1=Length@jlist;
While[jlist=!={},
dbg={0,0};
dbg1=PrintTemporary[Dynamic[dbg],"/",Length[jlist]];
nrs=(dbg={#,Last@dbg+1};Replace[#,jrules])&/@jlist;
NotebookDelete[dbg1];
rs0=Join[jlist,rs0];rs=Join[nrs,rs];
nr+=Length@jlist;
jlist={#,jSector@#}&/@DeleteDuplicates@Cases[{nrs}/.Dispatch[Thread[rs0->0]],_j,\[Infinity]];
jplist1=Join[jplist1,DeleteCases[jlist,{_,hjsec}]];
jlist=Cases[jlist,{x_,hjsec}:>x];
];
t2=Thread[rs0-> rs];
mis={mis,Cases[t2,HoldPattern[x_->x_]:>x]};
Put[{t1,t2},dir<>"/"<>ToString[hjsecn]];
AppendTo[jsd,hjsecn->((*{#1,FromDigits[{##2},2]}&@@@*)DeleteDuplicates[Last/@jplist1])];
jplist=Join[jplist,jplist1];
];
jplist=DeleteDuplicates@jplist;
]
,
TableForm[{{Overlay[{ProgressIndicator[nd-nd1,{0,nd}],nr},Alignment->Center]},{hjsec}}]
];
mis=Flatten@mis;
LiteRedPrintTemporary["MIs: ",mis];
nr1=0;
(*\:0411\:0435\:0440\:0435\:043c \:0432\:0441\:0435 \:043a\:043e\:043d\:0435\:0447\:043d\:044b\:0435 \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
LiteRedMonitor[
While[jsd=!={},
(*\:041d\:0435\:0437\:0430\:0432\:0438\:0441\:0438\:043c\:044b\:0435 \:0441\:0435\:043a\:0442\:043e\:0440\:0430*)
hjsec=Dispatch[Thread[First/@jsd->0]];
hjsec=MapThread[SameQ,{#,#/.hjsec}]&@jsd[[All,2]];
hjsec=Pick[jsd,hjsec,True];
jsd=Complement[jsd,hjsec];
(*SetSharedVariable[jsec,dir];
SetSharedFunction[j,js];
jsec={};Print[hjsec];*)
((*CriticalSection[{lock},jsec=Append[jsec,#1]]*)
jsec=#1;
{t2,jrules}=Get[dir<>"/"<>ToString[#1]];
t2=Append[Thread[First/@Take[jrules,-t2]->True],_j->False];
(*******************************************************)
(*status="Applying rules from "<>ToString[Length@#2]<>" lower sectors";*)
jrules=jrules/.Dispatch[Join@@(Get[dir<>"/"<>ToString[#]]&/@#2)];
(*status="Finished applying from lower sectors";*)
(*******************************************************)
(*\:0420\:0430\:0437\:0431\:0438\:0435\:043d\:0438\:0435 \:043d\:0430 \:0441\:0442\:0443\:043f\:0435\:043d\:0438*)
(*status="Layering sector";*)
(*\:0443\:0434\:0430\:043b\:044f\:0435\:043c \:0442\:0440\:0438\:0432\:0438\:0430\:043b\:044c\:043d\:044b\:0435 \:043f\:0440\:0430\:0432\:0438\:043b\:0430 \:0434\:043b\:044f \:043c\:0430\:0441\:0442\:0435\:0440\:043e\:0432*)
jrules={0,First@#,Cases[{Last@#},_j,\[Infinity]],#}&/@DeleteCases[jrules,HoldPattern[x_->x_]];
level[_]=0;
jrules=FixedPoint[{level[#2]=1+Max[0,level/@#3],##2}&@@@#&,jrules];
Clear[level];
jrules=Map[Last,SortBy[GatherBy[jrules,First],First[First@#]&],{2}];
(*status="Finished layering sector";*)
(*\:0420\:0430\:0441\:043f\:0443\:0442\:044b\:0432\:0430\:0435\:043c \:0441\:0435\:043a\:0442\:043e\:0440*)
jrules1={};
Scan[(
(*lvl++;*)
(*status="Substituing!";*)
t1=#/.Dispatch[jrules1];
(*status="Finished substituing!";*)
(*status="Collecting!";*)
t1=(#1->Collect[#2,_j,Together])&@@@t1;
jrules1=Join[jrules1,t1];
nr1+=Length@t1
(*status="Finished collecting!";*)
)&,
jrules
];
jrules=First/@jrules1/.t2;
Put[Pick[jrules1,jrules,True],dir<>"/"<>ToString[#1]];
(*CriticalSection[{lock},jsec=DeleteCases[jsec,#1]];*))&@@@hjsec;
],
TableForm[{{Overlay[{ProgressIndicator[nr1,{0,nr}],nr1},Alignment->Center]},{jsec}}]
];
res=Collect[Get[dir<>"/res"][[1,-1]]/.jc->j,_j,Factor],
res:=Abort[]
];
DeleteDirectory[dir,DeleteContents->True];
res
]]


csow[x_Plus,y_]:=csow[#,y]&/@x;
csow[x__*y_j,z_]/;FreeQ[{x},_j]:=csow[y,x*z];
(*csow[times[x___,y_j,x1___],z_]:=csow[y,x*x1*z];
csow[x_times,z_]:=csow[#2,#1*z]&@@SplitCases[Times@@x,{_?(FreeQ[#,_j]&)}];*)
csow[times[x___,y_?(!FreeQ[#,_j]&),x1___],z_]:=csow[y,x*x1*z];
csow[x_j,y_]:=(Sow[y,x];0);
csow[0,y_]:=0;
csow[x__?(FreeQ[#,_j]&)*y_,z_]:=csow[y,x*z];
csow[x_,y_]:=(x*y);
(*csow[times[x___?(FreeQ[#,_j]&),y_,x1___?(FreeQ[#,_j]&)],z_]:=csow[y,x*x1*z];*)


sid[ids_,id_]:=sid[ids,id,Highj[id]];
sid[ids_List,id_,jj_j]:=sid[#,id,jj]&/@ids;
sid[id1_,id_,jj_j]:=Module[{
c1=Coefficient[id1,jj],
c=Coefficient[id,jj],
vars=Alternatives@@Variables[Rest[List@@jj]]
},
If[jj==={},Return[id1]];(*no j needs to be canceled*)
If[c1===0,Return[id1]](*already no jj*);
Assert[c=!=0];
{c,c1}={Numerator@#,Denominator@#}&[Factor[c/c1]];
If[FreeQ[{c,c1},vars],
Return[Collect[(c*id1-c1*id),_j,Factor]],
Return[id1]
]
];
sharpen[ids0_List]:=Module[{
ids=ids0,idsr={},id,
hj,
i
},
While[(hj=Highj@ids)=!={},
{{i}}=Position[ids,_?(Not[FreeQ[#,hj]]&),{1},1];(*definitely exists*)
id=ids[[i]];
ids=sid[Delete[ids,i],id,hj];
idsr=Prepend[sid[ idsr,id,hj],id];
];
Return[idsr]
];


jsectlt[x1_List]:=x1=!=(0&/@x1)&&Not[Or@@Positive[x1]];
jsectle[x1_List]:=Not[Or@@Positive@x1];
jsectgt[x1_List]:=x1=!=(0&/@x1)&&Not[Or@@Negative@x1];
jsectge[x1_List]:=Not[Or@@Negative@x1];


nfGraph[g_]:=Module[
{vs,gn=g/._Integer?NonPositive->0},
vs=Sort@Union[Sequence@@@First/@gn];
gn/.Thread[vs->Range[0,Length@vs-1]]
]


(* ::Code::Initialization:: *)
toNickel[g_]:=Module[
{vs,vs1,v,v1,et,e1,t={},h},
vs1=Sort@Union[Sequence@@@First/@g,{0}];
et=Sort@Union@(Last/@g);
While[vs1=!={},
v=First@vs1;t={t,h@@Map[Sort[Cases[g,{(Rule|RightArrow|LeftRightArrow|UndirectedEdge)[v,v1_],#}|{(Rule|UndirectedEdge)[v1_,v],#}/;MemberQ[vs1,v1]:>v1]]&,et]};vs1=Rest@vs1;
];Flatten@t/.h->List
]


(* ::Code::Initialization:: *)
fromNickel[nickel_]:=Sort@Flatten[MapIndexed[Function[{etl,ind},MapIndexed[Function[{vl,et},{First@ind-1->#,ToExpression["e"<>ToString[First@et]]}&/@vl],etl]],nickel],2]


(* ::Code::Initialization:: *)
cfNickel[nickel_]:=Module[{p,f=0,f1,s,g,i,t,t1,cand={nickel}},
Do[
cand=First/@First@SplitBy[SortBy[{#,signature[Join[#[[p]],List/@Range[f]]]}&/@cand,Last],Last];
(*\:0432\:044b\:0431\:0438\:0440\:0430\:0435\:043c \:043f\:043e \:0434\:043b\:0438\:043d\:0430\:043c, \:0430\:043a\:043a\:0443\:0440\:0430\:0442\:043d\:043e \:0443\:0447\:0438\:0442\:044b\:0432\:0430\:044f \:0434\:0443\:0431\:043b\:0438\:043a\:0430\:0442\:044b.*)
f1=f;f+=Length[DeleteCases[DeleteDuplicates@Flatten@cand[[1,p]],_?(#<=f&)]];
If[f>=p,t1=Range[f1+1,f];
Do[
t=Thread[#->t1]&/@permutations[DeleteCases[cand[[i,p]],_?(#<=f1&),{2}]];
t=Function[h,Join[h,Thread[Complement[#2,#1]->Complement[#1,#2]]]&[First/@h,Last/@h]]/@t;
cand[[i]]=(fromNickel[cand[[i]]]/.t);
cand[[i]]=toNickel/@cand[[i]];
,{i,Length@cand}],
Do[
t={#->p,p->#}&/@Range[p,Length@nickel-1];
cand[[i]]=(fromNickel[cand[[i]]]/.t);
cand[[i]]=toNickel/@cand[[i]];
,{i,Length@cand}];f=p
];
cand=Union@@cand
,{p,Length@nickel-1}];
First@cand
]


(* ::Code::Initialization:: *)
cfGraph[graph_]:=Module[
{nick=toNickel@graph,p,f=0,f1,g,i,t,t1,cand},
cand={g[nick,graph]};
Do[
cand=First/@First@SplitBy[SortBy[{#,signature[Join[First[#][[p]],List/@Range[f]]]}&/@cand,Last],Last];
(*\:0432\:044b\:0431\:0438\:0440\:0430\:0435\:043c \:043f\:043e \:0434\:043b\:0438\:043d\:0430\:043c, \:0430\:043a\:043a\:0443\:0440\:0430\:0442\:043d\:043e \:0443\:0447\:0438\:0442\:044b\:0432\:0430\:044f \:0434\:0443\:0431\:043b\:0438\:043a\:0430\:0442\:044b.*)
f1=f;f+=Length[DeleteCases[DeleteDuplicates@Flatten@cand[[1,1,p]],_?(#<=f&)]];
If[f>=p,t1=Range[f1+1,f];
Do[
t=Thread[#->t1]&/@permutations[DeleteCases[cand[[i,1,p]],_?(#<=f1&),{2}]];
t=Function[h,Join[h,Thread[Complement[#2,#1]->Complement[#1,#2]]]&[First/@h,Last/@h]]/@t;
cand[[i]]=(cand[[i,2]]/.t);
cand[[i]]={toNickel@#1,#1}&/@cand[[i]];
,{i,Length@cand}],
Do[
t={#->p,p->#}&/@Range[p,Length@nick-1];
cand[[i]]=(cand[[i,2]]/.t);
cand[[i]]={toNickel@#1,#1}&/@cand[[i]];
,{i,Length@cand}];f=p
];
cand=Union@@cand
,{p,Length@nick-1}];
Sort[({Sort[#1],#2}&@@@Last[#])&@First@cand]
]


(* ::Code::Initialization:: *)
automorphisms[graph_]:=Module[
{nick=toNickel@graph,gr={Sort[#1],#2}&@@@graph,vs=Sort@Union[Sequence@@@First/@graph,{0}],p,f=0,f1,g,i,t,t1,cand},
cand={g[nick,vs,graph]};
Do[
cand=First/@First@SplitBy[SortBy[{#,signature[Join[First[#][[p]],List/@Range[f]]]}&/@cand,Last],Last];
(*\:0432\:044b\:0431\:0438\:0440\:0430\:0435\:043c \:043f\:043e \:0434\:043b\:0438\:043d\:0430\:043c, \:0430\:043a\:043a\:0443\:0440\:0430\:0442\:043d\:043e \:0443\:0447\:0438\:0442\:044b\:0432\:0430\:044f \:0434\:0443\:0431\:043b\:0438\:043a\:0430\:0442\:044b.*)
f1=f;f+=Length[DeleteCases[DeleteDuplicates@Flatten@cand[[1,1,p]],_?(#<=f&)]];
If[f>=p,
t1=Range[f1+1,f];
Do[
t=Thread[#->t1]&/@permutations[DeleteCases[cand[[i,1,p]],_?(#<=f1&),{2}]];
t=Function[h,Join[h,Thread[Complement[#2,#1]->Complement[#1,#2]]]&[First/@h,Last/@h]]/@t;
cand[[i]]=(cand[[i,{2,3}]]/.t);
cand[[i]]=g[toNickel@#2,#1,#2]&@@@cand[[i]];
,{i,Length@cand}],
Do[
t={#->p,p->#}&/@Range[p,Length@nick-1];
cand[[i]]=(cand[[i,{2,3}]]/.t);
cand[[i]]=g[toNickel@#2,#1,#2]&@@@cand[[i]];
,{i,Length@cand}];f=p
];
cand=Union@@cand
,{p,Length@nick-1}];
cand={#2,System`Permute[Range[Length[graph]],FindPermutation[{Sort[#1],#2}&@@@#3]]}&@@@cand;
g=Thread/@MapThread[Rule,{cand[[1]],{vs,Range[Length[graph]]}}];
MapThread[Thread[#->#2]&,{{vs,Range[Length[graph]]},MapThread[ReplaceAll[##]&,{#,g}]}]&/@cand
]


(* ::Code::Initialization:: *)
isomorphisms[graph1_,graph2_]:=Module[
{nick1=toNickel@graph1,nick2=toNickel@graph2,
gr1={Sort[#1],#2}&@@@graph1,gr2={Sort[#1],#2}&@@@graph2,
vs1=Sort@Union[Sequence@@@First/@graph1,{0}],vs2=Sort@Union[Sequence@@@First/@graph2,{0}],
cand1,cand2,
p,f=0,h,h2,g,i,t,t1},
If[vs1=!=vs2,Return[{}]];
cand1={g[nick1,vs1,graph1]};cand2={g[nick2,vs2,graph2]};
Catch[Do[
cand1=First@SplitBy[SortBy[{#,signature[Join[First[#][[p]],List/@Range[f]]]}&/@cand1,Last],Last];
cand2=First@SplitBy[SortBy[{#,signature[Join[First[#][[p]],List/@Range[f]]]}&/@cand2,Last],Last];
(*\:0432\:044b\:0431\:0438\:0440\:0430\:0435\:043c \:043f\:043e \:0434\:043b\:0438\:043d\:0430\:043c, \:0430\:043a\:043a\:0443\:0440\:0430\:0442\:043d\:043e \:0443\:0447\:0438\:0442\:044b\:0432\:0430\:044f \:0434\:0443\:0431\:043b\:0438\:043a\:0430\:0442\:044b.*)
If[cand1[[1,-1]]=!=cand2[[1,-1]],Throw[{}]];
cand1=First/@cand1;
cand2=First/@cand2;
h=f;f+=Length[DeleteCases[DeleteDuplicates@Flatten@cand1[[1,1,p]],_?(#<=f&)]];
If[f>=p,
t1=Range[h+1,f];
Do[
t=Thread[#->t1]&/@permutations[DeleteCases[cand1[[i,1,p]],_?(#<=h&),{2}]];
t=Function[h,Join[h,Thread[Complement[#2,#1]->Complement[#1,#2]]]&[First/@h,Last/@h]]/@t;
cand1[[i]]=(cand1[[i,{2,3}]]/.t);
cand1[[i]]=g[toNickel@#2,#1,#2]&@@@cand1[[i]];
,{i,Length@cand1}];
Do[
t=Thread[#->t1]&/@permutations[DeleteCases[cand2[[i,1,p]],_?(#<=h&),{2}]];
t=Function[h,Join[h,Thread[Complement[#2,#1]->Complement[#1,#2]]]&[First/@h,Last/@h]]/@t;
cand2[[i]]=(cand2[[i,{2,3}]]/.t);
cand2[[i]]=g[toNickel@#2,#1,#2]&@@@cand2[[i]];
,{i,Length@cand2}]
,
t={#->p,p->#}&/@Range[p,Length@nick1-1];
Do[
(**\:0412\:044b\:043d\:0435\:0441\:0442\:0438 \:0438\:0437-\:043f\:043e\:0434 \:0446\:0438\:043a\:043b\:0430!!!**)
cand1[[i]]=(cand1[[i,{2,3}]]/.t);
cand1[[i]]=g[toNickel@#2,#1,#2]&@@@cand1[[i]];
,{i,Length@cand1}];
Do[
cand2[[i]]=(cand2[[i,{2,3}]]/.t);
cand2[[i]]=g[toNickel@#2,#1,#2]&@@@cand2[[i]];
,{i,Length@cand2}];f=p
];
cand1=Union@@cand1;
cand2=Union@@cand2;
,{p,Length@nick1-1}];
cand1={#2,System`Permute[Range[Length[graph1]],FindPermutation[{Sort[#1],#2}&@@@#3]]}&@@@cand1;
g=Thread/@MapThread[Rule,{{#2,System`Permute[Range[Length[graph2]],FindPermutation[{Sort[#1],#2}&@@@#3]]}&@@cand2[[1]],{vs1,Range[Length[graph2]]}}];
MapThread[Thread[#1->#2]&,{{vs1,Range[Length[graph2]]},MapThread[ReplaceAll[##]&,{#,g}]}]&/@cand1
]
]


(* ::Code::Initialization:: *)
signature[set_List]:=Sort[Outer[Count[#2,#1]&,DeleteDuplicates@Flatten@set,set,1]];
(*signature[set_List]:=Sort[Function[v,FromDigits[Boole[MemberQ[#,v]]&/@set,2]]/@DeleteDuplicates@Flatten@set];*)
permutations[set_List]:=Module[{h},Flatten[Outer[h@@Join[##]&,##,1]&@@Permutations/@Map[First,GatherBy[Function[v,{v,Count[#,v]&/@set}]/@DeleteDuplicates@Flatten@set,Last],{2}]]/.h->List];
permutations[{{}...}]:={{}};


If[FindLibrary["APtsort"]=!=$Failed,matrixSP=LibraryFunctionLoad["APtsort", "tableSortingPermutationsMI",{{Integer, 2},True|False},{Integer, 2}(*Integer*)];
Print["Found \"APtsort\" library. "]
];
matrixSP=.;


Options[polyNF]={Monitor->False};
polyNF[p_]:=polyNF[p,Variables[p]];
polyNF[0,vars_List]/;FreeQ[p,Alternatives@@vars]:={{},Permutations[vars]}
polyNF[p_,vars_List]/;FreeQ[p,Alternatives@@vars]:={{0&/@vars->p},Permutations[vars]}
If[ValueQ[matrixSP],
polyNF[p_,vars_List]:=Module[
{t,b,ss,r,c=Length@vars,pp,sig},
b=Max[Exponent[p,vars]]+1;(*coding base*)
t=Transpose[List@@@CoefficientRules[p,vars]];
ss=MapIndexed[#->First@#2&,Union[Last@t]];
t=MapThread[Prepend,{First@t,Replace[Last@t,ss,{1}]}](*table constructed*);
r=Length@t;
pp=TakeDrop[#,r]&/@matrixSP[t,True];
(*Calculate signature*)
sig=Transpose[t[[pp[[1,1]],pp[[1,2]]]]];
(*sig={Replace[First[sig],(Reverse/@ss),{1}],FromDigits[#,b]&/@Rest[sig],b};*)
sig=Sort@Thread[Transpose[Rest[sig]]->Replace[First[sig],(Reverse/@ss),{1}]];
{sig,Sort[vars[[-1+Rest@Last@#]]&/@pp]}
],
polyNF[p_,vars_List]:=Module[
{cand,coefs,candn,nt,b,crit,n,k,i,c,c1,fc,t,rfc,lfc,vt,vt1,vt2,ct},
b=Max[Exponent[p,vars]]+1;(*\:0431\:0430\:0437\:0430 \:0434\:043b\:044f \:043a\:043e\:0434\:0438\:0440\:043e\:0432\:0430\:043d\:0438\:044f*)
cand=CoefficientRules[p,vars];nt=Length@cand;
crit=Function[x,Last@x(*{-Plus@@(First@x^#)&/@Range[b-1],Last@x}*)];
(*\:043f\:0435\:0440\:0432\:0438\:0447\:043d\:044b\:0439 \:043a\:0440\:0438\:0442\:0435\:0440\:0438\:0439 \[LongDash] {{\:0441\:0443\:043c\:043c\:0430 \:0441\:0442\:0435\:043f\:0435\:043d\:0435\:0439,\:0441\:0443\:043c\:043c\:0430 \:043a\:0432\:0430\:0434\:0440\:0430\:0442\:043e\:0432 \:0441\:0442\:0435\:043f\:0435\:043d\:0435\:0439, \:0438 \:0442.\:0434.},\:043a\:043e\:044d\:0444\:0444\:0438\:0446\:0438\:0435\:043d\:0442}*)
cand=SplitBy[Reverse@SortBy[cand,crit],crit];
coefs=Flatten@cand/.Rule->(#2&);
cand=cand/.Rule->(#1&);
vt=0&/@vars;(*\:0442\:0438\:043f\:044b \:043f\:0435\:0440\:0435\:043c\:0435\:043d\:043d\:044b\:0445, \:0438\:043d\:0438\:0446\:0438\:0430\:043b\:0438\:0437\:0438\:0440\:043e\:0432\:0430\:043d\:043d\:044b\:0435 \:0432 \:043d\:043e\:043b\:044c, \:0442.\:0435. \:0441\:043d\:0430\:0447\:0430\:043b\:0430 \:0432\:0441\:0435 \:043f\:0435\:0440\:0435\:043c\:0435\:043d\:043d\:044b\:0435 \:0440\:0430\:0432\:043d\:044b*)
cand={Append[cand,vt]};(*\:041f\:043e\:0441\:043b\:0435\:0434\:043d\:0438\:0439 \:0430\:0440\:0433\:0443\:043c\:0435\:043d\:0442 \[LongDash] \:0441\:043f\:0438\:0441\:043e\:043a \:0442\:0438\:043f\:043e\:0432*)(*\:0441 \:044d\:0442\:043e\:0433\:043e \:043c\:043e\:043c\:0435\:043d\:0442\:0430 \:043a\:0430\:0436\:0434\:044b\:0439 \:0438\:0437 \:043a\:0430\:043d\:0434\:0438\:0434\:0430\:0442\:043e\:0432 \[LongDash] \:0441\:043f\:0438\:0441\:043e\:043a \:043c\:043e\:043d\:043e\:043c\:043e\:0432, \:0440\:0430\:0437\:0431\:0438\:0442\:044b\:0439 \:043f\:043e \:043a\:0440\:0438\:0442\:0435\:0440\:0438\:044e \:0438  \:0434\:043e\:043f\:043e\:043b\:043d\:0435\:043d\:043d\:044b\:0439 \:0441\:043f\:0438\:0441\:043a\:043e\:043c \:0442\:0438\:043f\:043e\:0432*)
Do[
vt=b*(vt+1);
candn={};
Scan[
Function[c,
fc=First@c;lfc=Length@fc;
Do[
vt1=b*Last@c+fc[[i]];
vt2=Reverse@Sort@vt1;
If[!OrderedQ[{vt,vt2}],
vt=vt2;candn={ReplacePart[c,{1:>Replace[Delete[fc,i],{}->Sequence[]],-1->vt1}]},If[vt===vt2,AppendTo[candn,ReplacePart[c,{1:>Replace[Delete[fc,i],{}->Sequence[]],-1->vt1}]]]
]
,{i,lfc}];
]
,cand];
cand=candn
,{n,nt}];
(*{{coefs,vt,b},Reverse[vars[[Ordering[Last@#]]]]&/@cand}*)
{Sort@Thread[Transpose[IntegerDigits[#,b,nt]&/@vt]->coefs],Sort[Reverse[vars[[Ordering[Last@#]]]]&/@cand]}
];]


polyMapToSig[p_,vars_,{coefs1_List,inds_List,b1_Integer}]:=Module[
{cand,coefs,candn,nt,b,crit,n,k,i,c,c1,fc,t,rfc,lfc,vt,vt1,vt2,ct},
b=Max[Exponent[p,vars]]+1;
If[b=!=b1,Return[{}]];
cand=CoefficientRules[p,vars];nt=Length@cand;
crit=Function[x,{-Plus@@(First@x^#)&/@Range[b-1],Last@x}];
cand=SplitBy[SortBy[cand,crit],crit];
coefs=Flatten@cand/.Rule->(#2&);
If[coefs=!=coefs1,Return[{}]];
cand=cand/.Rule->(#1&);
vt=0&/@vars;
cand={Append[cand,vt]};(*\:041f\:043e\:0441\:043b\:0435\:0434\:043d\:0438\:0439 \:0430\:0440\:0433\:0443\:043c\:0435\:043d\:0442 -- \:0441\:043f\:0438\:0441\:043e\:043a \:0442\:0438\:043f\:043e\:0432*)
Catch[Do[
vt=b*(vt+1);
candn={};
Scan[
Function[c,
fc=First@c;lfc=Length@fc;
Do[
vt1=b*Last@c+fc[[i]];
vt2=Reverse@Sort@vt1;
If[!OrderedQ[{vt,vt2}],
vt=vt2;candn={ReplacePart[c,{1:>Replace[Delete[fc,i],{}->Sequence[]],-1->vt1}]},If[vt===vt2,AppendTo[candn,ReplacePart[c,{1:>Replace[Delete[fc,i],{}->Sequence[]],-1->vt1}]]]
]
,{i,lfc}];
]
,cand];
If[candn==={},Throw[{}]];
cand=candn;
,{n,nt}];
Function[c,
{coefs,SortBy[Thread[vars->Last@c],Last],b}
]/@cand]
];


$LiteRedSyzygy::usage="Set $LiteRedSyzygy to the function, so that $LiteRedSyzygy[\!\(\*
StyleBox[\"polynomials\", \"TI\"]\),\!\(\*
StyleBox[\"variables\", \"TI\"]\)] returns syzygy basis.";
$LiteRedSyzygy::err="Have no tool to calculate syzygy. Set $LiteRedSyzygy to the function, so that $LiteRedSyzygy[\!\(\*
StyleBox[\"polynomials\", \"TI\"]\),\!\(\*
StyleBox[\"variables\", \"TI\"]\)] returns syzygy basis.";
syzygy:=Which[
ValueQ[$LiteRedSyzygy],$LiteRedSyzygy,
MemberQ[$ContextPath,"Singular`"],$LiteRedSyzygy=Symbol["SingularSyz"],
True,Message[$LiteRedSyzygy::err];Abort[]
];


fds[P_(*list of numbers*),n_(*number*),l_(*digits number*)]:=Module[
{t=2^l(*leading bit*),p,nn,i,r},
Assert[And@@Thread[P<t]&&n<t];
Catch[
i=Position[IntegerDigits[n,2,l],0,{1}];
If[i=={},Throw[{n}],i=First@First@i];(*i is*)
p=Select[P,BitAnd[t+#,n]==0&];(*select elements with no intersection*)
nn=Select[p,(BitGet[#,l-i]==1)&];
If[nn=={},Throw[{}]];(*no direct sum*)
Scan[(r=fds[p,n+#,l];If[r=!={},Throw[Join[{n,#},Rest@r]]])&,nn];{}
]
]


plusFlatten::usage="PlusFlatten[{{a,b},{{c,d},f,g},{h}}] gives {a,b+c,d+f+h,g}.";
plusFlatten[a_List]:=Module[{pf},
pf[x_List,n_]:=MapIndexed[pf[#1,n+First@#2-1]&,x];
pf[x_,n_]:=Sow[x,n];
Plus@@@Last@Reap[pf[a,0]]
]


permute=If[Permute[{1,2,3},{2,3,1}]==={2,3,1},Permute,Permute[#1,InversePermutation[#2]]&];
ipermute=If[Permute[{1,2,3},{2,3,1}]==={2,3,1},Permute[#1,InversePermutation[#2]]&,Permute];


layer[sec:{(0|1)...},depth_Integer,numdepth:(_Integer|\[Infinity]):\[Infinity]]:=Module[
{ndepth=Min[numdepth,depth],nds,nns,pds,pns,perm},
{pds,pns}=Replace[{1,0},Append[Last[Reap[MapIndexed[Sow[First@#2,#1]&,sec],0|1,Rule]],0|1->{}],{1}];
{nds,nns}=Length/@{pds,pns};
perm=Join[pns,pds];
ipermute[#,perm]&/@Flatten[Table[Outer[Join,-Compositions[i,nns],Compositions[depth-i,nds],1],{i,0,ndepth}],2]
]


layer[l_Integer,d_Integer]:=Differences@Join[{0},#1,{d+l}]&/@Subsets[Range[d+l-1],{l-1}]-1


diamond[l_Integer,d_Integer]:=Module[{list},Flatten[Outer[list,Sequence@@Replace[#,{n_?Positive:>{n,-n},n_:>{n}},{1}]]&/@layer[l,d]]/.list->List]


GenerateFPIBP::usage="GenerateFPIBP[\!\(\*
StyleBox[\"basis\", \"TI\"]\)] generate Integration-By-Part identities in parametric representation for unique sectors of the \!\(\*
StyleBox[\"basis\", \"TI\"]\).";
jsFPIBP::usage="jsFPIBP[nm,0,1,\[Ellipsis]] returns a function for the IBP identities in parametric representation in the sector js[nm,0,1,\[Ellipsis]].";
FPIBP::usage="FPIBP[nm,0,2,1\[Ellipsis]] returns a list of the IBP identities in parametric representation.";


Options[GenerateFPIBP]={DiskRecover->True,MonomialOrder->Automatic,TimeConstrained->False};


GenerateFPIBP::us="Calling GenerateFPIBP[`1`] requires UniqueSectors[`1`]";
GenerateFPIBP[nm_,opts:OptionsPattern[]]:=Module[{us=UniqueSectors[nm],lus,rcv=OptionValue[DiskRecover],rcvrd={},fn,i=0,jsec},
If[Head@us===UniqueSectors,Message[GenerateFPIBP::us,nm];Abort[]];
lus=Length@us;
LiteRedPrint["Generating Integration-By-Part identities in parametric representation for unique sectors."];
LiteRedMonitor[
(jsec=js[##];If[TrueQ[rcv]&&FileExistsQ[fn=BasisDirectory[nm]<>"/jsFPIBP["<>StringTake[ToString[{##}],{2,-2}]<>"]"],Function[x,nm /: jsFPIBP[##] := Get[x]][fn];AppendTo[rcvrd,ToString[HoldForm[jsFPIBP[##]]]],
jsFPIBP[##,FilterRules[Flatten@{opts},Options[jsFPIBP]]]
];i++)&@@@us,
TableForm[{ProgressIndicator[i,{0,lus}],
jsec,Row[Prepend[rcvrd,"Recovered: "]]}]
];
LiteRedPrint["Generated Integration-By-Part identities in parametric representation for "<>ToString[Length@us]<>" sectors."];
];


Options[jsFPIBP]={MonomialOrder->Automatic,Throw->100,TimeConstrained->False};
jsFPIBP::failed="Failed to construct syzygy for the sector `1`";


jsFPIBP[nm_,inds__,opts:OptionsPattern[]]:=Module[
{tp,i=0,pl,syz,jsec=js[nm,inds],L=Length@LMs@nm,\[Nu]=MetricTensor[]/2,G,t,xs,ns,gradG,pb,p,b,jf,f,attempts=OptionValue[Throw],mo=OptionValue@MonomialOrder,tc=OptionValue[TimeConstrained]/.False|None->Infinity},{G,t,xs}=FeynParUF[jsec,NamingFunction->(Table[Unique["x"],{#}]&),Function->False];G+=t;
gradG=D[G,#]&/@xs;
ns=Table[Unique["n"],{Length@xs}];
b=IdentityMatrix[Length@xs];
Function[ps,jf=ReplacePart[j[nm,inds],Thread[ps->#]]&][Flatten@Position[jsec,1,{1}]];
If[mo===Automatic,
t=Catch[TimeConstrained[
NotebookDelete[tp];
tp=LiteRedPrintTemporary["Attempt #",++i,": ",pl=PermutationList[#,Length@xs]];
Quiet[syz=syzygy[Append[gradG,G],Permute[xs,#]]];If[syz=!=$Failed,Throw[syz]],tc,$Failed]&/@Prepend[RandomPermutation[Length@xs,attempts-1],Cycles[{}]];$Failed]
,
t=TimeConstrained[syzygy[Append[gradG,G],xs,MonomialOrder->mo],tc,$Failed](*Reverse@xs,MonomialOrder\[Rule] DegreeReverseLexicographic]*);
];
NotebookDelete[tp];
If[t===$Failed,Message[jsFPIBP::failed,js[nm,inds]];Return[$Failed]];(*exit if failed*)
f=f[Function[syz,
pb=CoefficientRules[syz,xs];p=Last@pb;pb=Most@pb;
Plus@@(Flatten@{MapIndexed[Function[{l,i},(#2*Pochhammer[(L+1)\[Nu]-Plus@@ns,1-Plus@@#1]Times@@Pochhammer[ns,#1](jf[ns+#1-b[[First@i]]]))&@@@l],pb],
(\[Nu]*#2*Pochhammer[(L+1)\[Nu]-Plus@@ns,-Plus@@#1]Times@@Pochhammer[ns,#1](jf[ns+#1]))&@@@p
})]/@t/.Thread[ns->Array[Slot,Length@ns]]]/.f->Function;
LiteRedPrint["    jsFPIBP["<>#<>"] \[LongDash] IBP identities in parametric representation."]&@StringTake[ToString[{nm,inds}],{2,-2}];
(Put[f, #]; nm /: jsFPIBP[nm, inds] := Get[#])&[BasisDirectory[nm]<>"/jsFPIBP["<>StringTake[ToString[{nm,inds}],{2,-2}]<>"]"];Remove/@xs;
f]


FPIBP::nonum="Numerators are not allowed.";
FPIBP[nm_,inds__]:=Module[{jsec=jSector@j[nm,inds]},
If[DeleteCases[Pick[{inds},Rest[List@@jsec],0],0]=!={},Message[FPIBP::nonum];Return[{}]];
(jsFPIBP@@jsec)@@Pick[{inds},Rest[List@@jsec],1]
]


CellPrint[Cell["TODO list:", "Text", CellFrame->{{0, 0}, {0, 1}}]];
Print[Style["\[FilledSmallCircle] "<>#,{"Text",Small}]]&/@todolist;


End[]


Protect[{j,A,B}];


EndPackage[]


If[LiteRed`Private`template,
CellPrint[Cell[BoxData[{RowBox[{RowBox[{"SetDim","[","d","]"}],";"}],"\[IndentingNewLine]",RowBox[{"Declare","[",RowBox[{RowBox[{"{",TagBox[FrameBox["\<\"\\!\\(\\*SubscriptBox[\\(l\\), \\(1\\)]\\),\\!\\(\\*SubscriptBox[\\(l\\), \\(2\\)]\\),\[Ellipsis]\"\>"],"Placeholder"],"}"}],",","Vector",",",RowBox[{"{",TagBox[FrameBox["\<\"s,t,u,...\"\>"],"Placeholder"],"}"}],",","Number"}],"]"}],"\[IndentingNewLine]",RowBox[{"SetConstraints","[",RowBox[{RowBox[{"{",TagBox[FrameBox["\<\"\\!\\(\\*SubscriptBox[\\(p\\), \\(1\\)]\\),\\!\\(\\*SubscriptBox[\\(p\\), \\(2\\)]\\),\[Ellipsis]\"\>"],"Placeholder"],"}"}],",","\[IndentingNewLine]",TagBox[FrameBox["\<\"sp[\\!\\(\\*SubscriptBox[\\(p\\), \\(1\\)]\\),\\!\\(\\*SubscriptBox[\\(p\\), \\(2\\)]\\)]=\[Ellipsis];\[Ellipsis]\"\>"],"Placeholder"]}],"]"}]}],"Input"]];
CellPrint[Cell[BoxData[RowBox[{RowBox[{"NewDsBasis","[",RowBox[{TagBox[FrameBox["\<\"nm\"\>"],"Placeholder"],",",RowBox[{"{",TagBox[FrameBox["\<\"denominators\"\>"],"Placeholder"],"}"}],",",RowBox[{"{",TagBox[FrameBox["\<\"\\!\\(\\*SubscriptBox[\\(l\\), \\(1\\)]\\),\\!\\(\\*SubscriptBox[\\(l\\), \\(2\\)]\\),\[Ellipsis]\"\>"],"Placeholder"],"}"}],",",RowBox[{"Directory","\[Rule]",TagBox[FrameBox["\<\"directory\"\>"],"Placeholder"]}],",",RowBox[{"SectorsPattern","\[Rule]",RowBox[{"{",TagBox[FrameBox["\<\"__,\[Ellipsis],0\"\>"],"Placeholder"],"}"}]}],",",RowBox[{"FindSymmetries","\[Rule]","True"}]}],"]"}],";"}]],"Input"]];
CellPrint[Cell[BoxData[RowBox[{"SolvejSector","[",TagBox[FrameBox["\<\"nm\"\>"],"Placeholder"],"]"}]],"Input"]];
CellPrint[Cell[BoxData[RowBox[{"DiskSave","[",TagBox[FrameBox["\<\"nm\"\>"],"Placeholder"],"]"}]],"Input"]];
]
