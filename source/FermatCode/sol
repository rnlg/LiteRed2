; (c) Roman Lee 2018
; Library of functions for LiteRed2 program

  &(u=4);

; Globals

; database
;  db[1,1] Sparse;

; eqs
; eqs[1,1] Sparse;

; wanted
; wanted[1,1] Sparse;

; remapping index
; remap[1,1] Sparse;

; found rule
Array rule[1,1] Sparse;



; Firstcol([m],i) returns the index of the first nonzero element on the ith row.
Function Firstcol(m,i,j) = for j = [m]i do &> od; j.;

; Lastrow([m]) returns the index of the last row containing nonzero elements.
Function Lastrow(m,i,last,j) =
  if i=0 then i := Rows[m] fi;
  while i>0 do
    for j = [m]i do
      last:=i;
      i:=1;
      &>
    od;
    i:-
  od;
  last.;

Function Addrow(mat,rows,ind,till,i,j) =
  {`
  Addrow([m],[m1],i) adds i-th row of matrix m1 to matrix m and performs Rowech. `
  Addrow([m],[m1],i) should be equivalent to Addrows([m],[m1],i-1,i)`
  }
  if till=0 then till := Rows[mat] fi;
  for j = [rows]ind do
    mat[till,j] := rows[ind,j];
  od;
  Rowech([mat]);
  {return last row #}
  till:=Lastrow([mat],till);
  till.;

Function Addrows(mat,rows,skip,last,off,i,j) =
  { `
    Addrows([m],[r]) adds new rows to matrix m and performs Rowech.`
    Addrows([m],[r],sk) skips first sk rows of [r] `
    Addrows([m],[r],sk,l) takes rows sk+1,sk+2,...,r of l `
  }
  if last=0 then last := Lastrow([rows]) fi;
  last:-(skip);
  if off=0 then off := Rows[mat]-last fi;
  for i = 1,last do
    skip:+;
    off:+;
    for j = [rows]skip do
      mat[off,j] := rows[skip,j];
    od
  od;
  Rowech([mat]);
  {return last row #}
  off:=Lastrow([mat],off);
  off.;


; Accel is the acceleration function:
; If lst=[x,dx,ddx,...], it recalculates
; x:=x+dx, dx=dx+ddx,...
Function Accel(lst,i) =
  for i=1,Cols[lst]-1 do
    lst[i]:= lst[i] + lst[i+1]
  od;
  0.;


; Rpos(eqs,list) returns the index of the first row with first nonzero column index being in list.
Function Rpos(eqs,list,r,i,j,k) =
  if r=0 then
    r := Rows[eqs]
  fi;
  for i = 1,r do
    for j = [eqs]i do
      if list[1,j]=1 then
        k := i
      fi;
      & >;
    od;
    if k>0 then &> fi;
  od;
  k.;

; Ulist(eqs,list) updates list to contain the integrals lying above the ones being in list.
; Ulist(eqs,list,r) restricts the search within r first rows
Function Ulist(eqs,list,r,i,j,k) =
  if r=0 then r := Rows[eqs] fi;
  Array dlist[1,Cols[list]];
  for i = 1,r do
    for j = [eqs]i do
      if list[1,j]=1 then
        for k = [dlist]1 do
          list[1,k]:=1;
        od;
        & >
      fi;
      dlist[1,j] := 1;
    od;
  od;
  @([dlist]);
  0.;

; SortUp(eqs,list) sorts the rows putting rows containing list first
; SortUp returns the index of the last row containing indices from list list.
Function SortUp(eqs,list,r,i,j,k) =
  r := Rows[eqs];
  for i = 1,r do
    for j = [eqs]i do
      if list[1,j]=1 then
        k:+;
        Switchrow([eqs],k,i);
        & >
      fi
    od
  od; {here sorting of the first k lines should happen}
  k.;

Function Member(list,el,re,i) =
  for i = [list]1 do
    if i = el then
      re:=1;
      & >
    fi;
  od;
  re.;

Function SparseCopy(new,mat,off,skip,lst,i,j) =
  if lst=0 then lst:=Rows[mat] fi;
  lst:-(skip);
  for i = 1,lst do
    for j = [mat](skip+i) do
      new[off+i,j] := mat[skip+i,j]
    od
  od;
  lst.;

Function RareCopy(new,mat,inds,off,skip,lst,i,j) =
  {RareCopy([new],[mat],[inds],,,)}
  if lst=0 then lst:=Rows[mat] fi;
  lst:-(skip);
  for i = 1,lst do
    for j = [mat](skip+i) do
      new[off+i,inds[j]] := mat[skip+i,j]
    od
  od;
  lst.;



; Hound
Function Fetch(from, lst, till, off) =
  { `
    1. db=[ ], remap=[ ], eqs=[*]: clean start`
    2. db=[*], remap=[ ], eqs=[*]: continue same level`
    3. db=[*], remap=[*], eqs=[*]: continue new level`
  }
  lst := Lastrow([eqs]);
  off := Lastrow([db]);
    @[rule]; Array rule[1,1] Sparse;
  if off=0 then
    @[db]; Array db[lst+1,Cols[eqs]] Sparse
  else
    {continuing}
    {reinit db}
    Array dbnew[off+lst,Cols[eqs]] Sparse;
    if Lastrow([remap])=0 then
      {no remapping needed}
      SparseCopy([dbnew],[db],0,0,off)
    else
      RareCopy([dbnew],[db],[remap],0,0,off)
    fi;
    @[db];Rname[dbnew]:='[db]'
  fi;
  while from<lst do
    {check whether there is already a rule}
    rpos := Rpos([db],[wanted],off);
    if rpos>0 then &> fi;
    {not found yet, add rules}
    Accel([dyn]);
    till := from+dyn[1];
    if till>lst then till := lst fi;
    if off+till-from>Rows[db] then
      !!('increasing size to ',$(1.6*Rows[db]));
      Array dbnew[$(1.6*Rows[db]),Cols[db]] Sparse;
      SparseCopy([dbnew],[db]);
      @([db]);
      Rname[dbnew]:='[db]'
    fi;
    off:=Addrows([db],[eqs],from,till,off);
    !!(till-from,' eqs solved.');
    from := till;
  od;
  @[remap];
  if rpos>0 then
    !!('[',rpos,',',Firstcol([db],rpos),']');
    {SAVING RESULTS}
    {save rule}
    @[rule]; Array rule[1,Cols[eqs]] Sparse;  {respawn}
    SparseCopy([rule],[db],0,rpos-1,rpos);
    {save remaing eqs}
    if lst>till then
      {some equations left}
      Array remap[1,Cols[eqs]] Sparse;
      Array eqsr[lst-till,Cols[eqs]] Sparse;
      SparseCopy([eqsr],[eqs],0,till,lst);
      @[eqs]; Rname[eqsr] := '[eqs]'
    fi
  else
    @[rule]; Array rule[1,Cols[eqs]] Sparse;
    @[eqs]
  fi;
  @[wanted];{always reappend wanted}
  rpos.;

rpos := 0;

[dyn] := [(1)];

Array db[1,1] Sparse;
