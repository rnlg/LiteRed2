; (c) Roman Lee 2018
; Library of functions for LiteRed2 program

  &(u=4);

; Globals

; database
;  db[1,1] Sparse;

; eqs
; eqs[1,1] Sparse;

; wanted
; wanted[1,1] Sparse;

; remapping index
; remap[1,1] Sparse;

; found rule
Array rule[1,1] Sparse;



; Firstcol([m],i) returns the index of the first nonzero element on the ith row.
Function Firstcol(m,i,j) = for j = [m]i do &> od; j.;

; Lastrow([m]) returns the index of the last row containing nonzero elements.
Function Lastrow(m,i,last,j) =
  if i=0 then i := Rows[m] fi;
  while i>0 do
    for j = [m]i do
      last:=i;
      i:=1;
      &>
    od;
    i:-
  od;
  last.;

; Rpos(eqs,list) returns the index of the first row with
; first nonzero column index being in list.
Function Rpos(eqs,list,r,i,j,k) =
  if r=0 then
    r := Rows[eqs]
  fi;
  for i = 1,r do
    for j = [eqs]i do
      if list[1,j]=1 then k := i fi;
      & >;
    od;
    if k>0 then &> fi;
  od;
  k.;

; Ulist(eqs,list) updates list to contain the integrals lying above the ones being in list.
; Ulist(eqs,list,r) restricts the search within r first rows
Function Ulist(eqs,list,r,i,j,k) =
  if r=0 then r := Rows[eqs] fi;
  Array dlist[1,Cols[list]];
  for i = 1,r do
    for j = [eqs]i do
      if list[1,j]=1 then
        for k = [dlist]1 do
          list[1,k]:=1;
        od;
        & >
      fi;
      dlist[1,j] := 1;
    od;
  od;
  @([dlist]);
  0.;

; SortUp(eqs,list) sorts the rows putting rows containing list first
; SortUp returns the index of the last row containing indices from list list.
Function SortUp(eqs,list,r,i,j,k) =
  r := Rows[eqs];
  for i = 1,r do
    for j = [eqs]i do
      if list[1,j]=1 then
        k:+;
        Switchrow([eqs],k,i);
        & >
      fi
    od
  od; {here sorting of the first k lines should happen}
  k.;

Function Member(list,el,re,i) =
  for i = [list]1 do
    if i = el then
      re:=1;
      & >
    fi;
  od;
  re.;

Function SparseCopy(new,mat,off,skip,lst,i,j) =
  if lst=0 then lst:=Rows[mat] fi;
  lst:-(skip);
  for i = 1,lst do
    for j = [mat](skip+i) do
      new[off+i,j] := mat[skip+i,j]
    od
  od;
  lst.;

Function RareCopy(new,mat,inds,off,skip,lst,i,j) =
  {RareCopy([new],[mat],[inds],,,)}
  if lst=0 then lst:=Rows[mat] fi;
  lst:-(skip);
  for i = 1,lst do
    for j = [mat](skip+i) do
      new[off+i,inds[j]] := mat[skip+i,j]
    od
  od;
  lst.;


Function IncRowech(mat,eqs,ind,off,perm,h,h1,i,p,j,l,w,c) =
  {
      IncRowech --- incremental row echelon form.`
  }
  w := Cols[eqs];
  {copy eq}
  Array eq [1,w] Sparse;
  for j = [eqs]ind do eq[1,j] := eqs[ind,j] od;
  {leftmost column}
  h := Firstcol([eq],1);
  {# of rows}
  l := Lastrow([mat]);
  while h>0 do
    {search for an equation with the same leftmost column}
    for p = 1,l+1 do
      if h = 0 then &> fi;
      i := perm[p];
      h1 := Firstcol([mat],i);
      if h1=0 then h1 := w+1 fi;

      if h < h1 then
        {add new row}
        off:+;
        for j = [eq]1 do mat[off,j] := eq[1,j] od;
        {recalculate perm}
        for j = l,p,-1 do perm[j+1]:=perm[j] od;
        perm[p]:=off;
        h:=0;
        &>
      else if h = h1 then
        {modify new row}
        c := - eq[1,h]/mat[i,h];
        Array eq1 [1,w] Sparse;
        for j = [mat]i do eq1[1,j] :=mat[i,j] od;
        [eq] := [eq] + c*[eq1];
        @[eq1];
        h := Firstcol([eq],1);
      fi fi;
    od
  od;
  @([eq]);
  {return last row #}
  off.;


; Hound
Function Fetch(from, lst, off,w) =
  { `
    1. db=[ ], remap=[ ], eqs=[*]: clean start`
    2. db=[*], remap=[ ], eqs=[*]: continue same level`
    3. db=[*], remap=[*], eqs=[*]: continue new level`
  }
  w := Cols[eqs];
  lst := Lastrow([eqs]);
  off := Lastrow([db]);
  if off=0 then
    @[db]; Array db[lst,w] Sparse;
    Array perm[lst];
    [perm]:=lst
  else
    {continuing}
    {reinit db}
    Array dbnew[off+lst,w] Sparse;
    if Lastrow([remap])=0 then
      {no remapping needed}
      SparseCopy([dbnew],[db],0,0,off)
    else
      RareCopy([dbnew],[db],[remap],0,0,off)
    fi;
    {permutations}
    Array perm1[off+lst];
    [perm1]:=off+lst;
    [perm1[~off]]:=[perm[~off]];
    @[perm];Rname[perm1]:='[perm]';
    @[db];Rname[dbnew]:='[db]'
  fi;
  @[remap];
  while from<lst do
    {check whether there is already a rule}
    rpos := Rpos([db],[wanted],off);
    if rpos>0 then &> fi;
    {not found yet, add rules}
    from:+;
    off:=IncRowech([db],[eqs],from,off,[perm]);
    !!('1 eqs solved.');
  od;
  if rpos>0 then
    {save rule}
    @[rule]; Array rule[1,w] Sparse;  {respawn}
    SparseCopy([rule],[db],0,rpos-1,rpos);
    {save remaing eqs}
    if lst>from then
      {some equations left}
      Array remap[1,w] Sparse;
      Array eqsr[lst-from,w] Sparse;
      SparseCopy([eqsr],[eqs],0,from,lst);
      @[eqs]; Rname[eqsr] := '[eqs]'
    else
      {all equations are solved}
      @[eqs]
    fi
  else
    @[rule]; Array rule[1,w] Sparse;
    @[eqs]
  fi;
  @[wanted];{always reappend wanted}
  rpos.;

rpos := 0;

[dyn] := [(1)];

Array db[1,1] Sparse;
